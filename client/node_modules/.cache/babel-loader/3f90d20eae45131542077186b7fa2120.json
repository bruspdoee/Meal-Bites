{"ast":null,"code":"'use strict';\n\nvar DataTypes = require('../../data-types');\n\nvar Promise = require('../../promise');\n\nvar QueryTypes = require('../../query-types');\n\nvar _ = require('lodash');\n/**\n Returns an object that handles Postgres special needs to do certain queries.\n\n @class QueryInterface\n @static\n @private\n */\n\n/**\n   * Ensure enum and their values.\n   *\n   * @param {QueryInterface} qi\n   * @param {string} tableName  Name of table to create\n   * @param {Object} attributes Object representing a list of normalized table attributes\n   * @param {Object} [options]\n   * @param {Model}  [model]\n   *\n   * @returns {Promise}\n   * @private\n   */\n\n\nfunction ensureEnums(qi, tableName, attributes, options, model) {\n  var keys = Object.keys(attributes);\n  var keyLen = keys.length;\n  var sql = '';\n  var promises = [];\n  var i = 0;\n\n  for (i = 0; i < keyLen; i++) {\n    var attribute = attributes[keys[i]];\n    var type = attribute.type;\n\n    if (type instanceof DataTypes.ENUM || type instanceof DataTypes.ARRAY && type.type instanceof DataTypes.ENUM //ARRAY sub type is ENUM\n    ) {\n        sql = qi.QueryGenerator.pgListEnums(tableName, attribute.field || keys[i], options);\n        promises.push(qi.sequelize.query(sql, Object.assign({}, options, {\n          plain: true,\n          raw: true,\n          type: QueryTypes.SELECT\n        })));\n      }\n  }\n\n  return Promise.all(promises).then(function (results) {\n    promises = [];\n    var enumIdx = 0; // This little function allows us to re-use the same code that prepends or appends new value to enum array\n\n    var addEnumValue = function addEnumValue(field, value, relativeValue) {\n      var position = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'before';\n      var spliceStart = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : promises.length;\n\n      var valueOptions = _.clone(options);\n\n      valueOptions.before = null;\n      valueOptions.after = null;\n\n      switch (position) {\n        case 'after':\n          valueOptions.after = relativeValue;\n          break;\n\n        case 'before':\n        default:\n          valueOptions.before = relativeValue;\n          break;\n      }\n\n      promises.splice(spliceStart, 0, function () {\n        return qi.sequelize.query(qi.QueryGenerator.pgEnumAdd(tableName, field, value, valueOptions), valueOptions);\n      });\n    };\n\n    var _loop = function _loop() {\n      var attribute = attributes[keys[i]];\n      var type = attribute.type;\n      var enumType = type.type || type;\n      var field = attribute.field || keys[i];\n\n      if (type instanceof DataTypes.ENUM || type instanceof DataTypes.ARRAY && enumType instanceof DataTypes.ENUM //ARRAY sub type is ENUM\n      ) {\n          // If the enum type doesn't exist then create it\n          if (!results[enumIdx]) {\n            promises.push(function () {\n              return qi.sequelize.query(qi.QueryGenerator.pgEnum(tableName, field, enumType, options), Object.assign({}, options, {\n                raw: true\n              }));\n            });\n          } else if (!!results[enumIdx] && !!model) {\n            var enumVals = qi.QueryGenerator.fromArray(results[enumIdx].enum_value);\n            var vals = enumType.values; // Going through already existing values allows us to make queries that depend on those values\n            // We will prepend all new values between the old ones, but keep in mind - we can't change order of already existing values\n            // Then we append the rest of new values AFTER the latest already existing value\n            // E.g.: [1,2] -> [0,2,1] ==> [1,0,2]\n            // E.g.: [1,2,3] -> [2,1,3,4] ==> [1,2,3,4]\n            // E.g.: [1] -> [0,2,3] ==> [1,0,2,3]\n\n            var lastOldEnumValue;\n            var rightestPosition = -1;\n\n            for (var oldIndex = 0; oldIndex < enumVals.length; oldIndex++) {\n              var enumVal = enumVals[oldIndex];\n              var newIdx = vals.indexOf(enumVal);\n              lastOldEnumValue = enumVal;\n\n              if (newIdx === -1) {\n                continue;\n              }\n\n              var newValuesBefore = vals.slice(0, newIdx);\n              var promisesLength = promises.length; // we go in reverse order so we could stop when we meet old value\n\n              for (var reverseIdx = newValuesBefore.length - 1; reverseIdx >= 0; reverseIdx--) {\n                if (~enumVals.indexOf(newValuesBefore[reverseIdx])) {\n                  break;\n                }\n\n                addEnumValue(field, newValuesBefore[reverseIdx], lastOldEnumValue, 'before', promisesLength);\n              } // we detect the most 'right' position of old value in new enum array so we can append new values to it\n\n\n              if (newIdx > rightestPosition) {\n                rightestPosition = newIdx;\n              }\n            }\n\n            if (lastOldEnumValue && rightestPosition < vals.length - 1) {\n              var remainingEnumValues = vals.slice(rightestPosition + 1);\n\n              for (var _reverseIdx = remainingEnumValues.length - 1; _reverseIdx >= 0; _reverseIdx--) {\n                addEnumValue(field, remainingEnumValues[_reverseIdx], lastOldEnumValue, 'after');\n              }\n            }\n\n            enumIdx++;\n          }\n        }\n    };\n\n    for (i = 0; i < keyLen; i++) {\n      _loop();\n    }\n\n    return promises.reduce(function (promise, asyncFunction) {\n      return promise.then(asyncFunction);\n    }, Promise.resolve()).tap(function () {\n      // If ENUM processed, then refresh OIDs\n      if (promises.length) {\n        return qi.sequelize.dialect.connectionManager._refreshDynamicOIDs();\n      }\n    });\n  });\n}\n\nexports.ensureEnums = ensureEnums;","map":null,"metadata":{},"sourceType":"script"}