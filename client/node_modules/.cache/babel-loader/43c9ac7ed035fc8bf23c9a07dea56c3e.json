{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('sequelize-pool'),\n    Pool = _require.Pool,\n    TimeoutError = _require.TimeoutError;\n\nvar _ = require('lodash');\n\nvar semver = require('semver');\n\nvar Promise = require('../../promise');\n\nvar errors = require('../../errors');\n\nvar _require2 = require('../../utils/logger'),\n    logger = _require2.logger;\n\nvar debug = logger.debugContext('pool');\n/**\n * Abstract Connection Manager\n *\n * Connection manager which handles pooling & replication.\n * Uses sequelize-pool for pooling\n *\n * @private\n */\n\nvar ConnectionManager = /*#__PURE__*/function () {\n  function ConnectionManager(dialect, sequelize) {\n    _classCallCheck(this, ConnectionManager);\n\n    var config = _.cloneDeep(sequelize.config);\n\n    this.sequelize = sequelize;\n    this.config = config;\n    this.dialect = dialect;\n    this.versionPromise = null;\n    this.dialectName = this.sequelize.options.dialect;\n\n    if (config.pool === false) {\n      throw new Error('Support for pool:false was removed in v4.0');\n    }\n\n    config.pool = _.defaults(config.pool || {}, {\n      max: 5,\n      min: 0,\n      idle: 10000,\n      acquire: 60000,\n      evict: 1000,\n      validate: this._validate.bind(this)\n    });\n    this.initPools();\n  }\n\n  _createClass(ConnectionManager, [{\n    key: \"refreshTypeParser\",\n    value: function refreshTypeParser(dataTypes) {\n      var _this = this;\n\n      _.each(dataTypes, function (dataType) {\n        if (Object.prototype.hasOwnProperty.call(dataType, 'parse')) {\n          if (dataType.types[_this.dialectName]) {\n            _this._refreshTypeParser(dataType);\n          } else {\n            throw new Error(\"Parse function not supported for type \".concat(dataType.key, \" in dialect \").concat(_this.dialectName));\n          }\n        }\n      });\n    }\n    /**\n     * Try to load dialect module from various configured options.\n     * Priority goes like dialectModulePath > dialectModule > require(default)\n     *\n     * @param {string} moduleName Name of dialect module to lookup\n     *\n     * @private\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"_loadDialectModule\",\n    value: function _loadDialectModule(moduleName) {\n      try {\n        if (this.sequelize.config.dialectModulePath) {\n          return require(this.sequelize.config.dialectModulePath);\n        }\n\n        if (this.sequelize.config.dialectModule) {\n          return this.sequelize.config.dialectModule;\n        } // This is needed so that bundlers (like webpack) know which library to include in the bundle\n\n\n        switch (moduleName) {\n          case 'pg':\n            return require('pg');\n\n          case 'mysql2':\n            return require('mysql2');\n\n          case 'mariadb':\n            return require('mariadb');\n\n          case 'sqlite3':\n            return require('sqlite3');\n\n          case 'tedious':\n            return require('tedious');\n\n          default:\n            return require(moduleName);\n        }\n      } catch (err) {\n        if (err.code === 'MODULE_NOT_FOUND') {\n          if (this.sequelize.config.dialectModulePath) {\n            throw new Error(\"Unable to find dialect at \".concat(this.sequelize.config.dialectModulePath));\n          }\n\n          throw new Error(\"Please install \".concat(moduleName, \" package manually\"));\n        }\n\n        throw err;\n      }\n    }\n    /**\n     * Handler which executes on process exit or connection manager shutdown\n     *\n     * @private\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"_onProcessExit\",\n    value: function _onProcessExit() {\n      var _this2 = this;\n\n      if (!this.pool) {\n        return Promise.resolve();\n      }\n\n      return this.pool.drain().then(function () {\n        debug('connection drain due to process exit');\n        return _this2.pool.destroyAllNow();\n      });\n    }\n    /**\n     * Drain the pool and close it permanently\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      // Mark close of pool\n      this.getConnection = function getConnection() {\n        return Promise.reject(new Error('ConnectionManager.getConnection was called after the connection manager was closed!'));\n      };\n\n      return this._onProcessExit();\n    }\n    /**\n     * Initialize connection pool. By default pool autostart is set to false, so no connection will be\n     * be created unless `pool.acquire` is called.\n     */\n\n  }, {\n    key: \"initPools\",\n    value: function initPools() {\n      var _this3 = this;\n\n      var config = this.config;\n\n      if (!config.replication) {\n        this.pool = new Pool({\n          name: 'sequelize',\n          create: function create() {\n            return _this3._connect(config);\n          },\n          destroy: function destroy(connection) {\n            return _this3._disconnect(connection).tap(function () {\n              debug('connection destroy');\n            });\n          },\n          validate: config.pool.validate,\n          max: config.pool.max,\n          min: config.pool.min,\n          acquireTimeoutMillis: config.pool.acquire,\n          idleTimeoutMillis: config.pool.idle,\n          reapIntervalMillis: config.pool.evict\n        });\n        debug(\"pool created with max/min: \".concat(config.pool.max, \"/\").concat(config.pool.min, \", no replication\"));\n        return;\n      }\n\n      if (!Array.isArray(config.replication.read)) {\n        config.replication.read = [config.replication.read];\n      } // Map main connection config\n\n\n      config.replication.write = _.defaults(config.replication.write, _.omit(config, 'replication')); // Apply defaults to each read config\n\n      config.replication.read = config.replication.read.map(function (readConfig) {\n        return _.defaults(readConfig, _.omit(_this3.config, 'replication'));\n      }); // custom pooling for replication (original author @janmeier)\n\n      var reads = 0;\n      this.pool = {\n        release: function release(client) {\n          if (client.queryType === 'read') {\n            _this3.pool.read.release(client);\n          } else {\n            _this3.pool.write.release(client);\n          }\n        },\n        acquire: function acquire(queryType, useMaster) {\n          useMaster = useMaster === undefined ? false : useMaster;\n\n          if (queryType === 'SELECT' && !useMaster) {\n            return _this3.pool.read.acquire();\n          }\n\n          return _this3.pool.write.acquire();\n        },\n        destroy: function destroy(connection) {\n          _this3.pool[connection.queryType].destroy(connection);\n\n          debug('connection destroy');\n        },\n        destroyAllNow: function destroyAllNow() {\n          return Promise.join(_this3.pool.read.destroyAllNow(), _this3.pool.write.destroyAllNow()).tap(function () {\n            debug('all connections destroyed');\n          });\n        },\n        drain: function drain() {\n          return Promise.join(_this3.pool.write.drain(), _this3.pool.read.drain());\n        },\n        read: new Pool({\n          name: 'sequelize:read',\n          create: function create() {\n            // round robin config\n            var nextRead = reads++ % config.replication.read.length;\n            return _this3._connect(config.replication.read[nextRead]).tap(function (connection) {\n              connection.queryType = 'read';\n            });\n          },\n          destroy: function destroy(connection) {\n            return _this3._disconnect(connection);\n          },\n          validate: config.pool.validate,\n          max: config.pool.max,\n          min: config.pool.min,\n          acquireTimeoutMillis: config.pool.acquire,\n          idleTimeoutMillis: config.pool.idle,\n          reapIntervalMillis: config.pool.evict\n        }),\n        write: new Pool({\n          name: 'sequelize:write',\n          create: function create() {\n            return _this3._connect(config.replication.write).tap(function (connection) {\n              connection.queryType = 'write';\n            });\n          },\n          destroy: function destroy(connection) {\n            return _this3._disconnect(connection);\n          },\n          validate: config.pool.validate,\n          max: config.pool.max,\n          min: config.pool.min,\n          acquireTimeoutMillis: config.pool.acquire,\n          idleTimeoutMillis: config.pool.idle,\n          reapIntervalMillis: config.pool.evict\n        })\n      };\n      debug(\"pool created with max/min: \".concat(config.pool.max, \"/\").concat(config.pool.min, \", with replication\"));\n    }\n    /**\n     * Get connection from pool. It sets database version if it's not already set.\n     * Call pool.acquire to get a connection\n     *\n     * @param {Object}   [options]                 Pool options\n     * @param {string}   [options.type]            Set which replica to use. Available options are `read` and `write`\n     * @param {boolean}  [options.useMaster=false] Force master or write replica to get connection from\n     *\n     * @returns {Promise<Connection>}\n     */\n\n  }, {\n    key: \"getConnection\",\n    value: function getConnection(options) {\n      var _this4 = this;\n\n      options = options || {};\n      var promise;\n\n      if (this.sequelize.options.databaseVersion === 0) {\n        if (this.versionPromise) {\n          promise = this.versionPromise;\n        } else {\n          promise = this.versionPromise = this._connect(this.config.replication.write || this.config).then(function (connection) {\n            var _options = {};\n            _options.transaction = {\n              connection: connection\n            }; // Cheat .query to use our private connection\n\n            _options.logging = function () {};\n\n            _options.logging.__testLoggingFn = true; //connection might have set databaseVersion value at initialization,\n            //avoiding a useless round trip\n\n            if (_this4.sequelize.options.databaseVersion === 0) {\n              return _this4.sequelize.databaseVersion(_options).then(function (version) {\n                var parsedVersion = _.get(semver.coerce(version), 'version') || version;\n                _this4.sequelize.options.databaseVersion = semver.valid(parsedVersion) ? parsedVersion : _this4.defaultVersion;\n                _this4.versionPromise = null;\n                return _this4._disconnect(connection);\n              });\n            }\n\n            _this4.versionPromise = null;\n            return _this4._disconnect(connection);\n          }).catch(function (err) {\n            _this4.versionPromise = null;\n            throw err;\n          });\n        }\n      } else {\n        promise = Promise.resolve();\n      }\n\n      return promise.then(function () {\n        return _this4.pool.acquire(options.type, options.useMaster).catch(function (error) {\n          if (error instanceof TimeoutError) throw new errors.ConnectionAcquireTimeoutError(error);\n          throw error;\n        });\n      }).tap(function () {\n        debug('connection acquired');\n      });\n    }\n    /**\n     * Release a pooled connection so it can be utilized by other connection requests\n     *\n     * @param {Connection} connection\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"releaseConnection\",\n    value: function releaseConnection(connection) {\n      var _this5 = this;\n\n      return Promise.try(function () {\n        _this5.pool.release(connection);\n\n        debug('connection released');\n      });\n    }\n    /**\n     * Call dialect library to get connection\n     *\n     * @param {*} config Connection config\n     * @private\n     * @returns {Promise<Connection>}\n     */\n\n  }, {\n    key: \"_connect\",\n    value: function _connect(config) {\n      var _this6 = this;\n\n      return this.sequelize.runHooks('beforeConnect', config).then(function () {\n        return _this6.dialect.connectionManager.connect(config);\n      }).then(function (connection) {\n        return _this6.sequelize.runHooks('afterConnect', connection, config).return(connection);\n      });\n    }\n    /**\n     * Call dialect library to disconnect a connection\n     *\n     * @param {Connection} connection\n     * @private\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"_disconnect\",\n    value: function _disconnect(connection) {\n      var _this7 = this;\n\n      return this.sequelize.runHooks('beforeDisconnect', connection).then(function () {\n        return _this7.dialect.connectionManager.disconnect(connection);\n      }).then(function () {\n        return _this7.sequelize.runHooks('afterDisconnect', connection);\n      });\n    }\n    /**\n     * Determine if a connection is still valid or not\n     *\n     * @param {Connection} connection\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"_validate\",\n    value: function _validate(connection) {\n      if (!this.dialect.connectionManager.validate) {\n        return true;\n      }\n\n      return this.dialect.connectionManager.validate(connection);\n    }\n  }]);\n\n  return ConnectionManager;\n}();\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":null,"metadata":{},"sourceType":"script"}