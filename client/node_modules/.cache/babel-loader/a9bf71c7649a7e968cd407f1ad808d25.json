{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar _ = require('lodash');\n\nvar Utils = require('./utils');\n\nvar DataTypes = require('./data-types');\n\nvar SQLiteQueryInterface = require('./dialects/sqlite/query-interface');\n\nvar MSSQLQueryInterface = require('./dialects/mssql/query-interface');\n\nvar MySQLQueryInterface = require('./dialects/mysql/query-interface');\n\nvar PostgresQueryInterface = require('./dialects/postgres/query-interface');\n\nvar Transaction = require('./transaction');\n\nvar Promise = require('./promise');\n\nvar QueryTypes = require('./query-types');\n\nvar Op = require('./operators');\n/**\n * The interface that Sequelize uses to talk to all databases\n *\n * @class QueryInterface\n */\n\n\nvar QueryInterface = /*#__PURE__*/function () {\n  function QueryInterface(sequelize) {\n    _classCallCheck(this, QueryInterface);\n\n    this.sequelize = sequelize;\n    this.QueryGenerator = this.sequelize.dialect.QueryGenerator;\n  }\n  /**\n   * Create a database\n   *\n   * @param {string} database  Database name to create\n   * @param {Object} [options] Query options\n   * @param {string} [options.charset] Database default character set, MYSQL only\n   * @param {string} [options.collate] Database default collation\n   * @param {string} [options.encoding] Database default character set, PostgreSQL only\n   * @param {string} [options.ctype] Database character classification, PostgreSQL only\n   * @param {string} [options.template] The name of the template from which to create the new database, PostgreSQL only\n   *\n   * @returns {Promise}\n   */\n\n\n  _createClass(QueryInterface, [{\n    key: \"createDatabase\",\n    value: function createDatabase(database, options) {\n      options = options || {};\n      var sql = this.QueryGenerator.createDatabaseQuery(database, options);\n      return this.sequelize.query(sql, options);\n    }\n    /**\n     * Drop a database\n     *\n     * @param {string} database  Database name to drop\n     * @param {Object} [options] Query options\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"dropDatabase\",\n    value: function dropDatabase(database, options) {\n      options = options || {};\n      var sql = this.QueryGenerator.dropDatabaseQuery(database);\n      return this.sequelize.query(sql, options);\n    }\n    /**\n     * Create a schema\n     *\n     * @param {string} schema    Schema name to create\n     * @param {Object} [options] Query options\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"createSchema\",\n    value: function createSchema(schema, options) {\n      options = options || {};\n      var sql = this.QueryGenerator.createSchema(schema);\n      return this.sequelize.query(sql, options);\n    }\n    /**\n     * Drop a schema\n     *\n     * @param {string} schema    Schema name to drop\n     * @param {Object} [options] Query options\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"dropSchema\",\n    value: function dropSchema(schema, options) {\n      options = options || {};\n      var sql = this.QueryGenerator.dropSchema(schema);\n      return this.sequelize.query(sql, options);\n    }\n    /**\n     * Drop all schemas\n     *\n     * @param {Object} [options] Query options\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"dropAllSchemas\",\n    value: function dropAllSchemas(options) {\n      var _this = this;\n\n      options = options || {};\n\n      if (!this.QueryGenerator._dialect.supports.schemas) {\n        return this.sequelize.drop(options);\n      }\n\n      return this.showAllSchemas(options).map(function (schemaName) {\n        return _this.dropSchema(schemaName, options);\n      });\n    }\n    /**\n     * Show all schemas\n     *\n     * @param {Object} [options] Query options\n     *\n     * @returns {Promise<Array>}\n     */\n\n  }, {\n    key: \"showAllSchemas\",\n    value: function showAllSchemas(options) {\n      options = Object.assign({}, options, {\n        raw: true,\n        type: this.sequelize.QueryTypes.SELECT\n      });\n      var showSchemasSql = this.QueryGenerator.showSchemasQuery(options);\n      return this.sequelize.query(showSchemasSql, options).then(function (schemaNames) {\n        return _.flatten(schemaNames.map(function (value) {\n          return value.schema_name ? value.schema_name : value;\n        }));\n      });\n    }\n    /**\n     * Return database version\n     *\n     * @param {Object}    [options]      Query options\n     * @param {QueryType} [options.type] Query type\n     *\n     * @returns {Promise}\n     * @private\n     */\n\n  }, {\n    key: \"databaseVersion\",\n    value: function databaseVersion(options) {\n      return this.sequelize.query(this.QueryGenerator.versionQuery(), Object.assign({}, options, {\n        type: QueryTypes.VERSION\n      }));\n    }\n    /**\n     * Create a table with given set of attributes\n     *\n     * ```js\n     * queryInterface.createTable(\n     *   'nameOfTheNewTable',\n     *   {\n     *     id: {\n     *       type: Sequelize.INTEGER,\n     *       primaryKey: true,\n     *       autoIncrement: true\n     *     },\n     *     createdAt: {\n     *       type: Sequelize.DATE\n     *     },\n     *     updatedAt: {\n     *       type: Sequelize.DATE\n     *     },\n     *     attr1: Sequelize.STRING,\n     *     attr2: Sequelize.INTEGER,\n     *     attr3: {\n     *       type: Sequelize.BOOLEAN,\n     *       defaultValue: false,\n     *       allowNull: false\n     *     },\n     *     //foreign key usage\n     *     attr4: {\n     *       type: Sequelize.INTEGER,\n     *       references: {\n     *         model: 'another_table_name',\n     *         key: 'id'\n     *       },\n     *       onUpdate: 'cascade',\n     *       onDelete: 'cascade'\n     *     }\n     *   },\n     *   {\n     *     engine: 'MYISAM',    // default: 'InnoDB'\n     *     charset: 'latin1',   // default: null\n     *     schema: 'public',    // default: public, PostgreSQL only.\n     *     comment: 'my table', // comment for table\n     *     collate: 'latin1_danish_ci' // collation, MYSQL only\n     *   }\n     * )\n     * ```\n     *\n     * @param {string} tableName  Name of table to create\n     * @param {Object} attributes Object representing a list of table attributes to create\n     * @param {Object} [options] create table and query options\n     * @param {Model}  [model] model class\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"createTable\",\n    value: function createTable(tableName, attributes, options, model) {\n      var _this2 = this;\n\n      var sql = '';\n      var promise;\n      options = _.clone(options) || {};\n\n      if (options && options.uniqueKeys) {\n        _.forOwn(options.uniqueKeys, function (uniqueKey) {\n          if (uniqueKey.customIndex === undefined) {\n            uniqueKey.customIndex = true;\n          }\n        });\n      }\n\n      if (model) {\n        options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n      }\n\n      attributes = _.mapValues(attributes, function (attribute) {\n        return _this2.sequelize.normalizeAttribute(attribute);\n      }); // Postgres requires special SQL commands for ENUM/ENUM[]\n\n      if (this.sequelize.options.dialect === 'postgres') {\n        promise = PostgresQueryInterface.ensureEnums(this, tableName, attributes, options, model);\n      } else {\n        promise = Promise.resolve();\n      }\n\n      if (!tableName.schema && (options.schema || !!model && model._schema)) {\n        tableName = this.QueryGenerator.addSchema({\n          tableName: tableName,\n          _schema: !!model && model._schema || options.schema\n        });\n      }\n\n      attributes = this.QueryGenerator.attributesToSQL(attributes, {\n        table: tableName,\n        context: 'createTable'\n      });\n      sql = this.QueryGenerator.createTableQuery(tableName, attributes, options);\n      return promise.then(function () {\n        return _this2.sequelize.query(sql, options);\n      });\n    }\n    /**\n     * Drop a table from database\n     *\n     * @param {string} tableName Table name to drop\n     * @param {Object} options   Query options\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"dropTable\",\n    value: function dropTable(tableName, options) {\n      var _this3 = this;\n\n      // if we're forcing we should be cascading unless explicitly stated otherwise\n      options = _.clone(options) || {};\n      options.cascade = options.cascade || options.force || false;\n      var sql = this.QueryGenerator.dropTableQuery(tableName, options);\n      return this.sequelize.query(sql, options).then(function () {\n        var promises = []; // Since postgres has a special case for enums, we should drop the related\n        // enum type within the table and attribute\n\n        if (_this3.sequelize.options.dialect === 'postgres') {\n          var instanceTable = _this3.sequelize.modelManager.getModel(tableName, {\n            attribute: 'tableName'\n          });\n\n          if (instanceTable) {\n            var getTableName = (!options || !options.schema || options.schema === 'public' ? '' : \"\".concat(options.schema, \"_\")) + tableName;\n            var keys = Object.keys(instanceTable.rawAttributes);\n            var keyLen = keys.length;\n\n            for (var i = 0; i < keyLen; i++) {\n              if (instanceTable.rawAttributes[keys[i]].type instanceof DataTypes.ENUM) {\n                sql = _this3.QueryGenerator.pgEnumDrop(getTableName, keys[i]);\n                options.supportsSearchPath = false;\n                promises.push(_this3.sequelize.query(sql, Object.assign({}, options, {\n                  raw: true\n                })));\n              }\n            }\n          }\n        }\n\n        return Promise.all(promises).get(0);\n      });\n    }\n    /**\n     * Drop all tables from database\n     *\n     * @param {Object} [options] query options\n     * @param {Array}  [options.skip] List of table to skip\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"dropAllTables\",\n    value: function dropAllTables(options) {\n      var _this4 = this;\n\n      options = options || {};\n      var skip = options.skip || [];\n\n      var dropAllTables = function dropAllTables(tableNames) {\n        return Promise.each(tableNames, function (tableName) {\n          // if tableName is not in the Array of tables names then don't drop it\n          if (!skip.includes(tableName.tableName || tableName)) {\n            return _this4.dropTable(tableName, Object.assign({}, options, {\n              cascade: true\n            }));\n          }\n        });\n      };\n\n      return this.showAllTables(options).then(function (tableNames) {\n        if (_this4.sequelize.options.dialect === 'sqlite') {\n          return _this4.sequelize.query('PRAGMA foreign_keys;', options).then(function (result) {\n            var foreignKeysAreEnabled = result.foreign_keys === 1;\n\n            if (foreignKeysAreEnabled) {\n              return _this4.sequelize.query('PRAGMA foreign_keys = OFF', options).then(function () {\n                return dropAllTables(tableNames);\n              }).then(function () {\n                return _this4.sequelize.query('PRAGMA foreign_keys = ON', options);\n              });\n            }\n\n            return dropAllTables(tableNames);\n          });\n        }\n\n        return _this4.getForeignKeysForTables(tableNames, options).then(function (foreignKeys) {\n          var queries = [];\n          tableNames.forEach(function (tableName) {\n            var normalizedTableName = tableName;\n\n            if (_.isObject(tableName)) {\n              normalizedTableName = \"\".concat(tableName.schema, \".\").concat(tableName.tableName);\n            }\n\n            foreignKeys[normalizedTableName].forEach(function (foreignKey) {\n              queries.push(_this4.QueryGenerator.dropForeignKeyQuery(tableName, foreignKey));\n            });\n          });\n          return Promise.each(queries, function (q) {\n            return _this4.sequelize.query(q, options);\n          }).then(function () {\n            return dropAllTables(tableNames);\n          });\n        });\n      });\n    }\n    /**\n     * Drop specified enum from database (Postgres only)\n     *\n     * @param {string} [enumName]  Enum name to drop\n     * @param {Object} options Query options\n     *\n     * @returns {Promise}\n     * @private\n     */\n\n  }, {\n    key: \"dropEnum\",\n    value: function dropEnum(enumName, options) {\n      if (this.sequelize.getDialect() !== 'postgres') {\n        return Promise.resolve();\n      }\n\n      options = options || {};\n      return this.sequelize.query(this.QueryGenerator.pgEnumDrop(null, null, this.QueryGenerator.pgEscapeAndQuote(enumName)), Object.assign({}, options, {\n        raw: true\n      }));\n    }\n    /**\n     * Drop all enums from database (Postgres only)\n     *\n     * @param {Object} options Query options\n     *\n     * @returns {Promise}\n     * @private\n     */\n\n  }, {\n    key: \"dropAllEnums\",\n    value: function dropAllEnums(options) {\n      var _this5 = this;\n\n      if (this.sequelize.getDialect() !== 'postgres') {\n        return Promise.resolve();\n      }\n\n      options = options || {};\n      return this.pgListEnums(null, options).map(function (result) {\n        return _this5.sequelize.query(_this5.QueryGenerator.pgEnumDrop(null, null, _this5.QueryGenerator.pgEscapeAndQuote(result.enum_name)), Object.assign({}, options, {\n          raw: true\n        }));\n      });\n    }\n    /**\n     * List all enums (Postgres only)\n     *\n     * @param {string} [tableName]  Table whose enum to list\n     * @param {Object} [options]    Query options\n     *\n     * @returns {Promise}\n     * @private\n     */\n\n  }, {\n    key: \"pgListEnums\",\n    value: function pgListEnums(tableName, options) {\n      options = options || {};\n      var sql = this.QueryGenerator.pgListEnums(tableName);\n      return this.sequelize.query(sql, Object.assign({}, options, {\n        plain: false,\n        raw: true,\n        type: QueryTypes.SELECT\n      }));\n    }\n    /**\n     * Rename a table\n     *\n     * @param {string} before    Current name of table\n     * @param {string} after     New name from table\n     * @param {Object} [options] Query options\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"renameTable\",\n    value: function renameTable(before, after, options) {\n      options = options || {};\n      var sql = this.QueryGenerator.renameTableQuery(before, after);\n      return this.sequelize.query(sql, options);\n    }\n    /**\n     * Get all tables in current database\n     *\n     * @param {Object}    [options] Query options\n     * @param {boolean}   [options.raw=true] Run query in raw mode\n     * @param {QueryType} [options.type=QueryType.SHOWTABLE] query type\n     *\n     * @returns {Promise<Array>}\n     * @private\n     */\n\n  }, {\n    key: \"showAllTables\",\n    value: function showAllTables(options) {\n      options = Object.assign({}, options, {\n        raw: true,\n        type: QueryTypes.SHOWTABLES\n      });\n      var showTablesSql = this.QueryGenerator.showTablesQuery(this.sequelize.config.database);\n      return this.sequelize.query(showTablesSql, options).then(function (tableNames) {\n        return _.flatten(tableNames);\n      });\n    }\n    /**\n     * Describe a table structure\n     *\n     * This method returns an array of hashes containing information about all attributes in the table.\n     *\n     * ```js\n     * {\n     *    name: {\n     *      type:         'VARCHAR(255)', // this will be 'CHARACTER VARYING' for pg!\n     *      allowNull:    true,\n     *      defaultValue: null\n     *    },\n     *    isBetaMember: {\n     *      type:         'TINYINT(1)', // this will be 'BOOLEAN' for pg!\n     *      allowNull:    false,\n     *      defaultValue: false\n     *    }\n     * }\n     * ```\n     *\n     * @param {string} tableName table name\n     * @param {Object} [options] Query options\n     *\n     * @returns {Promise<Object>}\n     */\n\n  }, {\n    key: \"describeTable\",\n    value: function describeTable(tableName, options) {\n      if (this.sequelize.options.dialect === 'sqlite') {\n        // sqlite needs some special treatment as it cannot rename a column\n        return SQLiteQueryInterface.describeTable(this, tableName, options);\n      }\n\n      var schema = null;\n      var schemaDelimiter = null;\n\n      if (typeof options === 'string') {\n        schema = options;\n      } else if (typeof options === 'object' && options !== null) {\n        schema = options.schema || null;\n        schemaDelimiter = options.schemaDelimiter || null;\n      }\n\n      if (typeof tableName === 'object' && tableName !== null) {\n        schema = tableName.schema;\n        tableName = tableName.tableName;\n      }\n\n      var sql = this.QueryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);\n      options = Object.assign({}, options, {\n        type: QueryTypes.DESCRIBE\n      });\n      return this.sequelize.query(sql, options).then(function (data) {\n        /*\n         * If no data is returned from the query, then the table name may be wrong.\n         * Query generators that use information_schema for retrieving table info will just return an empty result set,\n         * it will not throw an error like built-ins do (e.g. DESCRIBE on MySql).\n         */\n        if (_.isEmpty(data)) {\n          throw new Error(\"No description found for \\\"\".concat(tableName, \"\\\" table. Check the table name and schema; remember, they _are_ case sensitive.\"));\n        }\n\n        return data;\n      }).catch(function (e) {\n        if (e.original && e.original.code === 'ER_NO_SUCH_TABLE') {\n          throw Error(\"No description found for \\\"\".concat(tableName, \"\\\" table. Check the table name and schema; remember, they _are_ case sensitive.\"));\n        }\n\n        throw e;\n      });\n    }\n    /**\n     * Add a new column to a table\n     *\n     * ```js\n     * queryInterface.addColumn('tableA', 'columnC', Sequelize.STRING, {\n     *    after: 'columnB' // after option is only supported by MySQL\n     * });\n     * ```\n     *\n     * @param {string} table     Table to add column to\n     * @param {string} key       Column name\n     * @param {Object} attribute Attribute definition\n     * @param {Object} [options] Query options\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"addColumn\",\n    value: function addColumn(table, key, attribute, options) {\n      if (!table || !key || !attribute) {\n        throw new Error('addColumn takes at least 3 arguments (table, attribute name, attribute definition)');\n      }\n\n      options = options || {};\n      attribute = this.sequelize.normalizeAttribute(attribute);\n      return this.sequelize.query(this.QueryGenerator.addColumnQuery(table, key, attribute), options);\n    }\n    /**\n     * Remove a column from a table\n     *\n     * @param {string} tableName      Table to remove column from\n     * @param {string} attributeName  Column name to remove\n     * @param {Object} [options]      Query options\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"removeColumn\",\n    value: function removeColumn(tableName, attributeName, options) {\n      options = options || {};\n\n      switch (this.sequelize.options.dialect) {\n        case 'sqlite':\n          // sqlite needs some special treatment as it cannot drop a column\n          return SQLiteQueryInterface.removeColumn(this, tableName, attributeName, options);\n\n        case 'mssql':\n          // mssql needs special treatment as it cannot drop a column with a default or foreign key constraint\n          return MSSQLQueryInterface.removeColumn(this, tableName, attributeName, options);\n\n        case 'mysql':\n        case 'mariadb':\n          // mysql/mariadb need special treatment as it cannot drop a column with a foreign key constraint\n          return MySQLQueryInterface.removeColumn(this, tableName, attributeName, options);\n\n        default:\n          return this.sequelize.query(this.QueryGenerator.removeColumnQuery(tableName, attributeName), options);\n      }\n    }\n    /**\n     * Change a column definition\n     *\n     * @param {string} tableName          Table name to change from\n     * @param {string} attributeName      Column name\n     * @param {Object} dataTypeOrOptions  Attribute definition for new column\n     * @param {Object} [options]          Query options\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"changeColumn\",\n    value: function changeColumn(tableName, attributeName, dataTypeOrOptions, options) {\n      var attributes = {};\n      options = options || {};\n\n      if (_.values(DataTypes).includes(dataTypeOrOptions)) {\n        attributes[attributeName] = {\n          type: dataTypeOrOptions,\n          allowNull: true\n        };\n      } else {\n        attributes[attributeName] = dataTypeOrOptions;\n      }\n\n      attributes[attributeName] = this.sequelize.normalizeAttribute(attributes[attributeName]);\n\n      if (this.sequelize.options.dialect === 'sqlite') {\n        // sqlite needs some special treatment as it cannot change a column\n        return SQLiteQueryInterface.changeColumn(this, tableName, attributes, options);\n      }\n\n      var query = this.QueryGenerator.attributesToSQL(attributes, {\n        context: 'changeColumn',\n        table: tableName\n      });\n      var sql = this.QueryGenerator.changeColumnQuery(tableName, query);\n      return this.sequelize.query(sql, options);\n    }\n    /**\n     * Rename a column\n     *\n     * @param {string} tableName        Table name whose column to rename\n     * @param {string} attrNameBefore   Current column name\n     * @param {string} attrNameAfter    New column name\n     * @param {Object} [options]        Query option\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"renameColumn\",\n    value: function renameColumn(tableName, attrNameBefore, attrNameAfter, options) {\n      var _this6 = this;\n\n      options = options || {};\n      return this.describeTable(tableName, options).then(function (data) {\n        if (!data[attrNameBefore]) {\n          throw new Error(\"Table \".concat(tableName, \" doesn't have the column \").concat(attrNameBefore));\n        }\n\n        data = data[attrNameBefore] || {};\n        var _options = {};\n        _options[attrNameAfter] = {\n          attribute: attrNameAfter,\n          type: data.type,\n          allowNull: data.allowNull,\n          defaultValue: data.defaultValue\n        }; // fix: a not-null column cannot have null as default value\n\n        if (data.defaultValue === null && !data.allowNull) {\n          delete _options[attrNameAfter].defaultValue;\n        }\n\n        if (_this6.sequelize.options.dialect === 'sqlite') {\n          // sqlite needs some special treatment as it cannot rename a column\n          return SQLiteQueryInterface.renameColumn(_this6, tableName, attrNameBefore, attrNameAfter, options);\n        }\n\n        var sql = _this6.QueryGenerator.renameColumnQuery(tableName, attrNameBefore, _this6.QueryGenerator.attributesToSQL(_options));\n\n        return _this6.sequelize.query(sql, options);\n      });\n    }\n    /**\n     * Add an index to a column\n     *\n     * @param {string|Object}  tableName Table name to add index on, can be a object with schema\n     * @param {Array}   [attributes]     Use options.fields instead, List of attributes to add index on\n     * @param {Object}  options          indexes options\n     * @param {Array}   options.fields   List of attributes to add index on\n     * @param {boolean} [options.concurrently] Pass CONCURRENT so other operations run while the index is created\n     * @param {boolean} [options.unique] Create a unique index\n     * @param {string}  [options.using]  Useful for GIN indexes\n     * @param {string}  [options.operator] Index operator\n     * @param {string}  [options.type]   Type of index, available options are UNIQUE|FULLTEXT|SPATIAL\n     * @param {string}  [options.name]   Name of the index. Default is <table>_<attr1>_<attr2>\n     * @param {Object}  [options.where]  Where condition on index, for partial indexes\n     * @param {string}  [rawTablename]   table name, this is just for backward compatibiity\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"addIndex\",\n    value: function addIndex(tableName, attributes, options, rawTablename) {\n      // Support for passing tableName, attributes, options or tableName, options (with a fields param which is the attributes)\n      if (!Array.isArray(attributes)) {\n        rawTablename = options;\n        options = attributes;\n        attributes = options.fields;\n      }\n\n      if (!rawTablename) {\n        // Map for backwards compat\n        rawTablename = tableName;\n      }\n\n      options = Utils.cloneDeep(options);\n      options.fields = attributes;\n      var sql = this.QueryGenerator.addIndexQuery(tableName, options, rawTablename);\n      return this.sequelize.query(sql, Object.assign({}, options, {\n        supportsSearchPath: false\n      }));\n    }\n    /**\n     * Show indexes on a table\n     *\n     * @param {string} tableName table name\n     * @param {Object} [options]   Query options\n     *\n     * @returns {Promise<Array>}\n     * @private\n     */\n\n  }, {\n    key: \"showIndex\",\n    value: function showIndex(tableName, options) {\n      var sql = this.QueryGenerator.showIndexesQuery(tableName, options);\n      return this.sequelize.query(sql, Object.assign({}, options, {\n        type: QueryTypes.SHOWINDEXES\n      }));\n    }\n  }, {\n    key: \"getForeignKeysForTables\",\n    value: function getForeignKeysForTables(tableNames, options) {\n      var _this7 = this;\n\n      if (tableNames.length === 0) {\n        return Promise.resolve({});\n      }\n\n      options = Object.assign({}, options || {}, {\n        type: QueryTypes.FOREIGNKEYS\n      });\n      return Promise.map(tableNames, function (tableName) {\n        return _this7.sequelize.query(_this7.QueryGenerator.getForeignKeysQuery(tableName, _this7.sequelize.config.database), options);\n      }).then(function (results) {\n        var result = {};\n        tableNames.forEach(function (tableName, i) {\n          if (_.isObject(tableName)) {\n            tableName = \"\".concat(tableName.schema, \".\").concat(tableName.tableName);\n          }\n\n          result[tableName] = Array.isArray(results[i]) ? results[i].map(function (r) {\n            return r.constraint_name;\n          }) : [results[i] && results[i].constraint_name];\n          result[tableName] = result[tableName].filter(_.identity);\n        });\n        return result;\n      });\n    }\n    /**\n     * Get foreign key references details for the table\n     *\n     * Those details contains constraintSchema, constraintName, constraintCatalog\n     * tableCatalog, tableSchema, tableName, columnName,\n     * referencedTableCatalog, referencedTableCatalog, referencedTableSchema, referencedTableName, referencedColumnName.\n     * Remind: constraint informations won't return if it's sqlite.\n     *\n     * @param {string} tableName table name\n     * @param {Object} [options]  Query options\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"getForeignKeyReferencesForTable\",\n    value: function getForeignKeyReferencesForTable(tableName, options) {\n      var queryOptions = Object.assign({}, options, {\n        type: QueryTypes.FOREIGNKEYS\n      });\n      var catalogName = this.sequelize.config.database;\n\n      switch (this.sequelize.options.dialect) {\n        case 'sqlite':\n          // sqlite needs some special treatment.\n          return SQLiteQueryInterface.getForeignKeyReferencesForTable(this, tableName, queryOptions);\n\n        case 'postgres':\n          {\n            // postgres needs some special treatment as those field names returned are all lowercase\n            // in order to keep same result with other dialects.\n            var query = this.QueryGenerator.getForeignKeyReferencesQuery(tableName, catalogName);\n            return this.sequelize.query(query, queryOptions).then(function (result) {\n              return result.map(Utils.camelizeObjectKeys);\n            });\n          }\n\n        case 'mssql':\n        case 'mysql':\n        case 'mariadb':\n        default:\n          {\n            var _query = this.QueryGenerator.getForeignKeysQuery(tableName, catalogName);\n\n            return this.sequelize.query(_query, queryOptions);\n          }\n      }\n    }\n    /**\n     * Remove an already existing index from a table\n     *\n     * @param {string} tableName             Table name to drop index from\n     * @param {string} indexNameOrAttributes Index name\n     * @param {Object} [options]             Query options\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"removeIndex\",\n    value: function removeIndex(tableName, indexNameOrAttributes, options) {\n      options = options || {};\n      var sql = this.QueryGenerator.removeIndexQuery(tableName, indexNameOrAttributes);\n      return this.sequelize.query(sql, options);\n    }\n    /**\n     * Add a constraint to a table\n     *\n     * Available constraints:\n     * - UNIQUE\n     * - DEFAULT (MSSQL only)\n     * - CHECK (MySQL - Ignored by the database engine )\n     * - FOREIGN KEY\n     * - PRIMARY KEY\n     *\n     * @example <caption>UNIQUE</caption>\n     * queryInterface.addConstraint('Users', ['email'], {\n     *   type: 'unique',\n     *   name: 'custom_unique_constraint_name'\n     * });\n     *\n     * @example <caption>CHECK</caption>\n     * queryInterface.addConstraint('Users', ['roles'], {\n     *   type: 'check',\n     *   where: {\n     *      roles: ['user', 'admin', 'moderator', 'guest']\n     *   }\n     * });\n     *\n     * @example <caption>Default - MSSQL only</caption>\n     * queryInterface.addConstraint('Users', ['roles'], {\n     *    type: 'default',\n     *    defaultValue: 'guest'\n     * });\n     *\n     * @example <caption>Primary Key</caption>\n     * queryInterface.addConstraint('Users', ['username'], {\n     *    type: 'primary key',\n     *    name: 'custom_primary_constraint_name'\n     * });\n     *\n     * @example <caption>Foreign Key</caption>\n     * queryInterface.addConstraint('Posts', ['username'], {\n     *   type: 'foreign key',\n     *   name: 'custom_fkey_constraint_name',\n     *   references: { //Required field\n     *     table: 'target_table_name',\n     *     field: 'target_column_name'\n     *   },\n     *   onDelete: 'cascade',\n     *   onUpdate: 'cascade'\n     * });\n     *\n     * @param {string} tableName                  Table name where you want to add a constraint\n     * @param {Array}  attributes                 Array of column names to apply the constraint over\n     * @param {Object} options                    An object to define the constraint name, type etc\n     * @param {string} options.type               Type of constraint. One of the values in available constraints(case insensitive)\n     * @param {string} [options.name]             Name of the constraint. If not specified, sequelize automatically creates a named constraint based on constraint type, table & column names\n     * @param {string} [options.defaultValue]     The value for the default constraint\n     * @param {Object} [options.where]            Where clause/expression for the CHECK constraint\n     * @param {Object} [options.references]       Object specifying target table, column name to create foreign key constraint\n     * @param {string} [options.references.table] Target table name\n     * @param {string} [options.references.field] Target column name\n     * @param {string} [rawTablename]             Table name, for backward compatibility\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"addConstraint\",\n    value: function addConstraint(tableName, attributes, options, rawTablename) {\n      if (!Array.isArray(attributes)) {\n        rawTablename = options;\n        options = attributes;\n        attributes = options.fields;\n      }\n\n      if (!options.type) {\n        throw new Error('Constraint type must be specified through options.type');\n      }\n\n      if (!rawTablename) {\n        // Map for backwards compat\n        rawTablename = tableName;\n      }\n\n      options = Utils.cloneDeep(options);\n      options.fields = attributes;\n\n      if (this.sequelize.dialect.name === 'sqlite') {\n        return SQLiteQueryInterface.addConstraint(this, tableName, options, rawTablename);\n      }\n\n      var sql = this.QueryGenerator.addConstraintQuery(tableName, options, rawTablename);\n      return this.sequelize.query(sql, options);\n    }\n  }, {\n    key: \"showConstraint\",\n    value: function showConstraint(tableName, constraintName, options) {\n      var sql = this.QueryGenerator.showConstraintsQuery(tableName, constraintName);\n      return this.sequelize.query(sql, Object.assign({}, options, {\n        type: QueryTypes.SHOWCONSTRAINTS\n      }));\n    }\n    /**\n     * Remove a constraint from a table\n     *\n     * @param {string} tableName       Table name to drop constraint from\n     * @param {string} constraintName  Constraint name\n     * @param {Object} options         Query options\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"removeConstraint\",\n    value: function removeConstraint(tableName, constraintName, options) {\n      options = options || {};\n\n      switch (this.sequelize.options.dialect) {\n        case 'mysql':\n        case 'mariadb':\n          //does not support DROP CONSTRAINT. Instead DROP PRIMARY, FOREIGN KEY, INDEX should be used\n          return MySQLQueryInterface.removeConstraint(this, tableName, constraintName, options);\n\n        case 'sqlite':\n          return SQLiteQueryInterface.removeConstraint(this, tableName, constraintName, options);\n\n        default:\n          var sql = this.QueryGenerator.removeConstraintQuery(tableName, constraintName);\n          return this.sequelize.query(sql, options);\n      }\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(instance, tableName, values, options) {\n      options = Utils.cloneDeep(options);\n      options.hasTrigger = instance && instance.constructor.options.hasTrigger;\n      var sql = this.QueryGenerator.insertQuery(tableName, values, instance && instance.constructor.rawAttributes, options);\n      options.type = QueryTypes.INSERT;\n      options.instance = instance;\n      return this.sequelize.query(sql, options).then(function (results) {\n        if (instance) results[0].isNewRecord = false;\n        return results;\n      });\n    }\n    /**\n     * Upsert\n     *\n     * @param {string} tableName    table to upsert on\n     * @param {Object} insertValues values to be inserted, mapped to field name\n     * @param {Object} updateValues values to be updated, mapped to field name\n     * @param {Object} where        various conditions\n     * @param {Model}  model        Model to upsert on\n     * @param {Object} options      query options\n     *\n     * @returns {Promise<boolean,?number>} Resolves an array with <created, primaryKey>\n     */\n\n  }, {\n    key: \"upsert\",\n    value: function upsert(tableName, insertValues, updateValues, where, model, options) {\n      var _this8 = this;\n\n      var wheres = [];\n      var attributes = Object.keys(insertValues);\n      var indexes = [];\n      var indexFields;\n      options = _.clone(options);\n\n      if (!Utils.isWhereEmpty(where)) {\n        wheres.push(where);\n      } // Lets combine unique keys and indexes into one\n\n\n      indexes = _.map(model.uniqueKeys, function (value) {\n        return value.fields;\n      });\n\n      model._indexes.forEach(function (value) {\n        if (value.unique) {\n          // fields in the index may both the strings or objects with an attribute property - lets sanitize that\n          indexFields = value.fields.map(function (field) {\n            if (_.isPlainObject(field)) {\n              return field.attribute;\n            }\n\n            return field;\n          });\n          indexes.push(indexFields);\n        }\n      });\n\n      var _iterator = _createForOfIteratorHelper(indexes),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var index = _step.value;\n\n          if (_.intersection(attributes, index).length === index.length) {\n            where = {};\n\n            var _iterator2 = _createForOfIteratorHelper(index),\n                _step2;\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var field = _step2.value;\n                where[field] = insertValues[field];\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n\n            wheres.push(where);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      where = _defineProperty({}, Op.or, wheres);\n      options.type = QueryTypes.UPSERT;\n      options.raw = true;\n      var sql = this.QueryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n      return this.sequelize.query(sql, options).then(function (result) {\n        switch (_this8.sequelize.options.dialect) {\n          case 'postgres':\n            return [result.created, result.primary_key];\n\n          case 'mssql':\n            return [result.$action === 'INSERT', result[model.primaryKeyField]];\n          // MySQL returns 1 for inserted, 2 for updated\n          // http://dev.mysql.com/doc/refman/5.0/en/insert-on-duplicate.html.\n\n          case 'mysql':\n          case 'mariadb':\n            return [result === 1, undefined];\n\n          default:\n            return [result, undefined];\n        }\n      });\n    }\n    /**\n     * Insert multiple records into a table\n     *\n     * @example\n     * queryInterface.bulkInsert('roles', [{\n     *    label: 'user',\n     *    createdAt: new Date(),\n     *    updatedAt: new Date()\n     *  }, {\n     *    label: 'admin',\n     *    createdAt: new Date(),\n     *    updatedAt: new Date()\n     *  }]);\n     *\n     * @param {string} tableName   Table name to insert record to\n     * @param {Array}  records     List of records to insert\n     * @param {Object} options     Various options, please see Model.bulkCreate options\n     * @param {Object} attributes  Various attributes mapped by field name\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"bulkInsert\",\n    value: function bulkInsert(tableName, records, options, attributes) {\n      options = _.clone(options) || {};\n      options.type = QueryTypes.INSERT;\n      return this.sequelize.query(this.QueryGenerator.bulkInsertQuery(tableName, records, options, attributes), options).then(function (results) {\n        return results[0];\n      });\n    }\n  }, {\n    key: \"update\",\n    value: function update(instance, tableName, values, identifier, options) {\n      options = _.clone(options || {});\n      options.hasTrigger = !!(instance && instance._modelOptions && instance._modelOptions.hasTrigger);\n      var sql = this.QueryGenerator.updateQuery(tableName, values, identifier, options, instance.constructor.rawAttributes);\n      options.type = QueryTypes.UPDATE;\n      options.instance = instance;\n      return this.sequelize.query(sql, options);\n    }\n    /**\n     * Update multiple records of a table\n     *\n     * @example\n     * queryInterface.bulkUpdate('roles', {\n     *     label: 'admin',\n     *   }, {\n     *     userType: 3,\n     *   },\n     * );\n     *\n     * @param {string} tableName     Table name to update\n     * @param {Object} values        Values to be inserted, mapped to field name\n     * @param {Object} identifier    A hash with conditions OR an ID as integer OR a string with conditions\n     * @param {Object} [options]     Various options, please see Model.bulkCreate options\n     * @param {Object} [attributes]  Attributes on return objects if supported by SQL dialect\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"bulkUpdate\",\n    value: function bulkUpdate(tableName, values, identifier, options, attributes) {\n      options = Utils.cloneDeep(options);\n      if (typeof identifier === 'object') identifier = Utils.cloneDeep(identifier);\n      var sql = this.QueryGenerator.updateQuery(tableName, values, identifier, options, attributes);\n      var table = _.isObject(tableName) ? tableName : {\n        tableName: tableName\n      };\n\n      var model = _.find(this.sequelize.modelManager.models, {\n        tableName: table.tableName\n      });\n\n      options.type = QueryTypes.BULKUPDATE;\n      options.model = model;\n      return this.sequelize.query(sql, options);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(instance, tableName, identifier, options) {\n      var _this9 = this;\n\n      var cascades = [];\n      var sql = this.QueryGenerator.deleteQuery(tableName, identifier, {}, instance.constructor);\n      options = _.clone(options) || {}; // Check for a restrict field\n\n      if (!!instance.constructor && !!instance.constructor.associations) {\n        var keys = Object.keys(instance.constructor.associations);\n        var length = keys.length;\n        var association;\n\n        for (var i = 0; i < length; i++) {\n          association = instance.constructor.associations[keys[i]];\n\n          if (association.options && association.options.onDelete && association.options.onDelete.toLowerCase() === 'cascade' && association.options.useHooks === true) {\n            cascades.push(association.accessors.get);\n          }\n        }\n      }\n\n      return Promise.each(cascades, function (cascade) {\n        return instance[cascade](options).then(function (instances) {\n          // Check for hasOne relationship with non-existing associate (\"has zero\")\n          if (!instances) {\n            return Promise.resolve();\n          }\n\n          if (!Array.isArray(instances)) instances = [instances];\n          return Promise.each(instances, function (instance) {\n            return instance.destroy(options);\n          });\n        });\n      }).then(function () {\n        options.instance = instance;\n        return _this9.sequelize.query(sql, options);\n      });\n    }\n    /**\n     * Delete multiple records from a table\n     *\n     * @param {string}  tableName            table name from where to delete records\n     * @param {Object}  where                where conditions to find records to delete\n     * @param {Object}  [options]            options\n     * @param {boolean} [options.truncate]   Use truncate table command   \n     * @param {boolean} [options.cascade=false]         Only used in conjunction with TRUNCATE. Truncates  all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.\n     * @param {boolean} [options.restartIdentity=false] Only used in conjunction with TRUNCATE. Automatically restart sequences owned by columns of the truncated table.\n     * @param {Model}   [model]              Model\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"bulkDelete\",\n    value: function bulkDelete(tableName, where, options, model) {\n      options = Utils.cloneDeep(options);\n      options = _.defaults(options, {\n        limit: null\n      });\n\n      if (options.truncate === true) {\n        return this.sequelize.query(this.QueryGenerator.truncateTableQuery(tableName, options), options);\n      }\n\n      if (typeof identifier === 'object') where = Utils.cloneDeep(where);\n      return this.sequelize.query(this.QueryGenerator.deleteQuery(tableName, where, options, model), options);\n    }\n  }, {\n    key: \"select\",\n    value: function select(model, tableName, optionsArg) {\n      var options = Object.assign({}, optionsArg, {\n        type: QueryTypes.SELECT,\n        model: model\n      });\n      return this.sequelize.query(this.QueryGenerator.selectQuery(tableName, options, model), options);\n    }\n  }, {\n    key: \"increment\",\n    value: function increment(model, tableName, values, identifier, options) {\n      options = Utils.cloneDeep(options);\n      var sql = this.QueryGenerator.arithmeticQuery('+', tableName, values, identifier, options, options.attributes);\n      options.type = QueryTypes.UPDATE;\n      options.model = model;\n      return this.sequelize.query(sql, options);\n    }\n  }, {\n    key: \"decrement\",\n    value: function decrement(model, tableName, values, identifier, options) {\n      options = Utils.cloneDeep(options);\n      var sql = this.QueryGenerator.arithmeticQuery('-', tableName, values, identifier, options, options.attributes);\n      options.type = QueryTypes.UPDATE;\n      options.model = model;\n      return this.sequelize.query(sql, options);\n    }\n  }, {\n    key: \"rawSelect\",\n    value: function rawSelect(tableName, options, attributeSelector, Model) {\n      options = Utils.cloneDeep(options);\n      options = _.defaults(options, {\n        raw: true,\n        plain: true,\n        type: QueryTypes.SELECT\n      });\n      var sql = this.QueryGenerator.selectQuery(tableName, options, Model);\n\n      if (attributeSelector === undefined) {\n        throw new Error('Please pass an attribute selector!');\n      }\n\n      return this.sequelize.query(sql, options).then(function (data) {\n        if (!options.plain) {\n          return data;\n        }\n\n        var result = data ? data[attributeSelector] : null;\n\n        if (!options || !options.dataType) {\n          return result;\n        }\n\n        var dataType = options.dataType;\n\n        if (dataType instanceof DataTypes.DECIMAL || dataType instanceof DataTypes.FLOAT) {\n          if (result !== null) {\n            return parseFloat(result);\n          }\n        }\n\n        if (dataType instanceof DataTypes.INTEGER || dataType instanceof DataTypes.BIGINT) {\n          return parseInt(result, 10);\n        }\n\n        if (dataType instanceof DataTypes.DATE) {\n          if (result !== null && !(result instanceof Date)) {\n            return new Date(result);\n          }\n        }\n\n        return result;\n      });\n    }\n  }, {\n    key: \"createTrigger\",\n    value: function createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray, options) {\n      var sql = this.QueryGenerator.createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray);\n      options = options || {};\n\n      if (sql) {\n        return this.sequelize.query(sql, options);\n      }\n\n      return Promise.resolve();\n    }\n  }, {\n    key: \"dropTrigger\",\n    value: function dropTrigger(tableName, triggerName, options) {\n      var sql = this.QueryGenerator.dropTrigger(tableName, triggerName);\n      options = options || {};\n\n      if (sql) {\n        return this.sequelize.query(sql, options);\n      }\n\n      return Promise.resolve();\n    }\n  }, {\n    key: \"renameTrigger\",\n    value: function renameTrigger(tableName, oldTriggerName, newTriggerName, options) {\n      var sql = this.QueryGenerator.renameTrigger(tableName, oldTriggerName, newTriggerName);\n      options = options || {};\n\n      if (sql) {\n        return this.sequelize.query(sql, options);\n      }\n\n      return Promise.resolve();\n    }\n    /**\n     * Create an SQL function\n     *\n     * @example\n     * queryInterface.createFunction(\n     *   'someFunction',\n     *   [\n     *     {type: 'integer', name: 'param', direction: 'IN'}\n     *   ],\n     *   'integer',\n     *   'plpgsql',\n     *   'RETURN param + 1;',\n     *   [\n     *     'IMMUTABLE',\n     *     'LEAKPROOF'\n     *   ],\n     *   {\n     *    variables:\n     *      [\n     *        {type: 'integer', name: 'myVar', default: 100}\n     *      ],\n     *      force: true\n     *   };\n     * );\n     *\n     * @param {string}  functionName  Name of SQL function to create\n     * @param {Array}   params        List of parameters declared for SQL function\n     * @param {string}  returnType    SQL type of function returned value\n     * @param {string}  language      The name of the language that the function is implemented in\n     * @param {string}  body          Source code of function\n     * @param {Array}   optionsArray  Extra-options for creation\n     * @param {Object}  [options]     query options\n     * @param {boolean} options.force If force is true, any existing functions with the same parameters will be replaced. For postgres, this means using `CREATE OR REPLACE FUNCTION` instead of `CREATE FUNCTION`. Default is false\n     * @param {Array<Object>}   options.variables List of declared variables. Each variable should be an object with string fields `type` and `name`, and optionally having a `default` field as well.\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"createFunction\",\n    value: function createFunction(functionName, params, returnType, language, body, optionsArray, options) {\n      var sql = this.QueryGenerator.createFunction(functionName, params, returnType, language, body, optionsArray, options);\n      options = options || {};\n\n      if (sql) {\n        return this.sequelize.query(sql, options);\n      }\n\n      return Promise.resolve();\n    }\n    /**\n     * Drop an SQL function\n     *\n     * @example\n     * queryInterface.dropFunction(\n     *   'someFunction',\n     *   [\n     *     {type: 'varchar', name: 'param1', direction: 'IN'},\n     *     {type: 'integer', name: 'param2', direction: 'INOUT'}\n     *   ]\n     * );\n     *\n     * @param {string} functionName Name of SQL function to drop\n     * @param {Array}  params       List of parameters declared for SQL function\n     * @param {Object} [options]    query options\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"dropFunction\",\n    value: function dropFunction(functionName, params, options) {\n      var sql = this.QueryGenerator.dropFunction(functionName, params);\n      options = options || {};\n\n      if (sql) {\n        return this.sequelize.query(sql, options);\n      }\n\n      return Promise.resolve();\n    }\n    /**\n     * Rename an SQL function\n     *\n     * @example\n     * queryInterface.renameFunction(\n     *   'fooFunction',\n     *   [\n     *     {type: 'varchar', name: 'param1', direction: 'IN'},\n     *     {type: 'integer', name: 'param2', direction: 'INOUT'}\n     *   ],\n     *   'barFunction'\n     * );\n     *\n     * @param {string} oldFunctionName  Current name of function\n     * @param {Array}  params           List of parameters declared for SQL function\n     * @param {string} newFunctionName  New name of function\n     * @param {Object} [options]        query options\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"renameFunction\",\n    value: function renameFunction(oldFunctionName, params, newFunctionName, options) {\n      var sql = this.QueryGenerator.renameFunction(oldFunctionName, params, newFunctionName);\n      options = options || {};\n\n      if (sql) {\n        return this.sequelize.query(sql, options);\n      }\n\n      return Promise.resolve();\n    } // Helper methods useful for querying\n\n    /**\n     * Escape an identifier (e.g. a table or attribute name)\n     *\n     * @param {string} identifier identifier to quote\n     * @param {boolean} [force]   If force is true,the identifier will be quoted even if the `quoteIdentifiers` option is false.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"quoteIdentifier\",\n    value: function quoteIdentifier(identifier, force) {\n      return this.QueryGenerator.quoteIdentifier(identifier, force);\n    }\n  }, {\n    key: \"quoteTable\",\n    value: function quoteTable(identifier) {\n      return this.QueryGenerator.quoteTable(identifier);\n    }\n    /**\n     * Quote array of identifiers at once\n     *\n     * @param {string[]} identifiers array of identifiers to quote\n     * @param {boolean} [force]   If force is true,the identifier will be quoted even if the `quoteIdentifiers` option is false.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"quoteIdentifiers\",\n    value: function quoteIdentifiers(identifiers, force) {\n      return this.QueryGenerator.quoteIdentifiers(identifiers, force);\n    }\n    /**\n     * Escape a value (e.g. a string, number or date)\n     *\n     * @param {string} value string to escape\n     *\n     * @private\n     */\n\n  }, {\n    key: \"escape\",\n    value: function escape(value) {\n      return this.QueryGenerator.escape(value);\n    }\n  }, {\n    key: \"setIsolationLevel\",\n    value: function setIsolationLevel(transaction, value, options) {\n      if (!transaction || !(transaction instanceof Transaction)) {\n        throw new Error('Unable to set isolation level for a transaction without transaction object!');\n      }\n\n      if (transaction.parent || !value) {\n        // Not possible to set a separate isolation level for savepoints\n        return Promise.resolve();\n      }\n\n      options = Object.assign({}, options, {\n        transaction: transaction.parent || transaction\n      });\n      var sql = this.QueryGenerator.setIsolationLevelQuery(value, {\n        parent: transaction.parent\n      });\n      if (!sql) return Promise.resolve();\n      return this.sequelize.query(sql, options);\n    }\n  }, {\n    key: \"startTransaction\",\n    value: function startTransaction(transaction, options) {\n      if (!transaction || !(transaction instanceof Transaction)) {\n        throw new Error('Unable to start a transaction without transaction object!');\n      }\n\n      options = Object.assign({}, options, {\n        transaction: transaction.parent || transaction\n      });\n      options.transaction.name = transaction.parent ? transaction.name : undefined;\n      var sql = this.QueryGenerator.startTransactionQuery(transaction);\n      return this.sequelize.query(sql, options);\n    }\n  }, {\n    key: \"deferConstraints\",\n    value: function deferConstraints(transaction, options) {\n      options = Object.assign({}, options, {\n        transaction: transaction.parent || transaction\n      });\n      var sql = this.QueryGenerator.deferConstraintsQuery(options);\n\n      if (sql) {\n        return this.sequelize.query(sql, options);\n      }\n\n      return Promise.resolve();\n    }\n  }, {\n    key: \"commitTransaction\",\n    value: function commitTransaction(transaction, options) {\n      if (!transaction || !(transaction instanceof Transaction)) {\n        throw new Error('Unable to commit a transaction without transaction object!');\n      }\n\n      if (transaction.parent) {\n        // Savepoints cannot be committed\n        return Promise.resolve();\n      }\n\n      options = Object.assign({}, options, {\n        transaction: transaction.parent || transaction,\n        supportsSearchPath: false,\n        completesTransaction: true\n      });\n      var sql = this.QueryGenerator.commitTransactionQuery(transaction);\n      var promise = this.sequelize.query(sql, options);\n      transaction.finished = 'commit';\n      return promise;\n    }\n  }, {\n    key: \"rollbackTransaction\",\n    value: function rollbackTransaction(transaction, options) {\n      if (!transaction || !(transaction instanceof Transaction)) {\n        throw new Error('Unable to rollback a transaction without transaction object!');\n      }\n\n      options = Object.assign({}, options, {\n        transaction: transaction.parent || transaction,\n        supportsSearchPath: false,\n        completesTransaction: true\n      });\n      options.transaction.name = transaction.parent ? transaction.name : undefined;\n      var sql = this.QueryGenerator.rollbackTransactionQuery(transaction);\n      var promise = this.sequelize.query(sql, options);\n      transaction.finished = 'rollback';\n      return promise;\n    }\n  }]);\n\n  return QueryInterface;\n}();\n\nmodule.exports = QueryInterface;\nmodule.exports.QueryInterface = QueryInterface;\nmodule.exports.default = QueryInterface;","map":null,"metadata":{},"sourceType":"script"}