{"ast":null,"code":"'use strict';\n\nvar chokidar = require('chokidar');\n\nvar debounce = require('just-debounce');\n\nvar asyncDone = require('async-done');\n\nvar defaults = require('object.defaults/immutable');\n\nvar isNegatedGlob = require('is-negated-glob');\n\nvar anymatch = require('anymatch');\n\nvar defaultOpts = {\n  delay: 200,\n  events: ['add', 'change', 'unlink'],\n  ignored: [],\n  ignoreInitial: true,\n  queue: true\n};\n\nfunction listenerCount(ee, evtName) {\n  if (typeof ee.listenerCount === 'function') {\n    return ee.listenerCount(evtName);\n  }\n\n  return ee.listeners(evtName).length;\n}\n\nfunction hasErrorListener(ee) {\n  return listenerCount(ee, 'error') !== 0;\n}\n\nfunction exists(val) {\n  return val != null;\n}\n\nfunction watch(glob, options, cb) {\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  var opt = defaults(options, defaultOpts);\n\n  if (!Array.isArray(opt.events)) {\n    opt.events = [opt.events];\n  }\n\n  if (Array.isArray(glob)) {\n    // We slice so we don't mutate the passed globs array\n    glob = glob.slice();\n  } else {\n    glob = [glob];\n  }\n\n  var queued = false;\n  var running = false; // These use sparse arrays to keep track of the index in the\n  // original globs array\n\n  var positives = new Array(glob.length);\n  var negatives = new Array(glob.length); // Reverse the glob here so we don't end up with a positive\n  // and negative glob in position 0 after a reverse\n\n  glob.reverse().forEach(sortGlobs);\n\n  function sortGlobs(globString, index) {\n    var result = isNegatedGlob(globString);\n\n    if (result.negated) {\n      negatives[index] = result.pattern;\n    } else {\n      positives[index] = result.pattern;\n    }\n  }\n\n  function shouldBeIgnored(path) {\n    var positiveMatch = anymatch(positives, path, true);\n    var negativeMatch = anymatch(negatives, path, true); // If negativeMatch is -1, that means it was never negated\n\n    if (negativeMatch === -1) {\n      return false;\n    } // If the negative is \"less than\" the positive, that means\n    // it came later in the glob array before we reversed them\n\n\n    return negativeMatch < positiveMatch;\n  }\n\n  var toWatch = positives.filter(exists); // We only do add our custom `ignored` if there are some negative globs\n  // TODO: I'm not sure how to test this\n\n  if (negatives.some(exists)) {\n    opt.ignored = [].concat(opt.ignored, shouldBeIgnored);\n  }\n\n  var watcher = chokidar.watch(toWatch, opt);\n\n  function runComplete(err) {\n    running = false;\n\n    if (err && hasErrorListener(watcher)) {\n      watcher.emit('error', err);\n    } // If we have a run queued, start onChange again\n\n\n    if (queued) {\n      queued = false;\n      onChange();\n    }\n  }\n\n  function onChange() {\n    if (running) {\n      if (opt.queue) {\n        queued = true;\n      }\n\n      return;\n    }\n\n    running = true;\n    asyncDone(cb, runComplete);\n  }\n\n  var fn;\n\n  if (typeof cb === 'function') {\n    fn = debounce(onChange, opt.delay);\n  }\n\n  function watchEvent(eventName) {\n    watcher.on(eventName, fn);\n  }\n\n  if (fn) {\n    opt.events.forEach(watchEvent);\n  }\n\n  return watcher;\n}\n\nmodule.exports = watch;","map":null,"metadata":{},"sourceType":"script"}