{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar mysql = require('../index.js');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar PoolConnection = require('./pool_connection.js');\n\nvar Queue = require('denque');\n\nvar Connection = require('./connection.js');\n\nfunction spliceConnection(queue, connection) {\n  var len = queue.length;\n\n  for (var i = 0; i < len; i++) {\n    if (queue.get(i) === connection) {\n      queue.removeOne(i);\n      break;\n    }\n  }\n}\n\nvar Pool = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Pool, _EventEmitter);\n\n  function Pool(options) {\n    var _this;\n\n    _classCallCheck(this, Pool);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Pool).call(this));\n    _this.config = options.config;\n    _this.config.connectionConfig.pool = _assertThisInitialized(_assertThisInitialized(_this));\n    _this._allConnections = new Queue();\n    _this._freeConnections = new Queue();\n    _this._connectionQueue = new Queue();\n    _this._closed = false;\n    return _this;\n  }\n\n  _createClass(Pool, [{\n    key: \"promise\",\n    value: function promise(promiseImpl) {\n      var PromisePool = require('../promise').PromisePool;\n\n      return new PromisePool(this, promiseImpl);\n    }\n  }, {\n    key: \"getConnection\",\n    value: function getConnection(cb) {\n      var _this2 = this;\n\n      if (this._closed) {\n        return process.nextTick(function () {\n          return cb(new Error('Pool is closed.'));\n        });\n      }\n\n      var connection;\n\n      if (this._freeConnections.length > 0) {\n        connection = this._freeConnections.shift();\n        this.emit('acquire', connection);\n        return process.nextTick(function () {\n          return cb(null, connection);\n        });\n      }\n\n      if (this.config.connectionLimit === 0 || this._allConnections.length < this.config.connectionLimit) {\n        connection = new PoolConnection(this, {\n          config: this.config.connectionConfig\n        });\n\n        this._allConnections.push(connection);\n\n        return connection.connect(function (err) {\n          if (_this2._closed) {\n            return cb(new Error('Pool is closed.'));\n          }\n\n          if (err) {\n            return cb(err);\n          }\n\n          _this2.emit('connection', connection);\n\n          _this2.emit('acquire', connection);\n\n          return cb(null, connection);\n        });\n      }\n\n      if (!this.config.waitForConnections) {\n        return process.nextTick(function () {\n          return cb(new Error('No connections available.'));\n        });\n      }\n\n      if (this.config.queueLimit && this._connectionQueue.length >= this.config.queueLimit) {\n        return cb(new Error('Queue limit reached.'));\n      }\n\n      this.emit('enqueue');\n      return this._connectionQueue.push(cb);\n    }\n  }, {\n    key: \"releaseConnection\",\n    value: function releaseConnection(connection) {\n      var cb;\n\n      if (!connection._pool) {\n        // The connection has been removed from the pool and is no longer good.\n        if (this._connectionQueue.length) {\n          cb = this._connectionQueue.shift();\n          process.nextTick(this.getConnection.bind(this, cb));\n        }\n      } else if (this._connectionQueue.length) {\n        cb = this._connectionQueue.shift();\n        process.nextTick(cb.bind(null, null, connection));\n      } else {\n        this._freeConnections.push(connection);\n\n        this.emit('release', connection);\n      }\n    }\n  }, {\n    key: \"end\",\n    value: function end(cb) {\n      this._closed = true;\n\n      if (typeof cb !== 'function') {\n        cb = function cb(err) {\n          if (err) {\n            throw err;\n          }\n        };\n      }\n\n      var calledBack = false;\n      var closedConnections = 0;\n      var connection;\n\n      var endCB = function (err) {\n        if (calledBack) {\n          return;\n        }\n\n        if (err || ++closedConnections >= this._allConnections.length) {\n          calledBack = true;\n          cb(err);\n          return;\n        }\n      }.bind(this);\n\n      if (this._allConnections.length === 0) {\n        endCB();\n        return;\n      }\n\n      for (var i = 0; i < this._allConnections.length; i++) {\n        connection = this._allConnections.get(i);\n\n        connection._realEnd(endCB);\n      }\n    }\n  }, {\n    key: \"query\",\n    value: function query(sql, values, cb) {\n      var cmdQuery = Connection.createQuery(sql, values, cb, this.config.connectionConfig);\n\n      if (typeof cmdQuery.namedPlaceholders === 'undefined') {\n        cmdQuery.namedPlaceholders = this.config.connectionConfig.namedPlaceholders;\n      }\n\n      this.getConnection(function (err, conn) {\n        if (err) {\n          if (typeof cmdQuery.onResult === 'function') {\n            cmdQuery.onResult(err);\n          } else {\n            cmdQuery.emit('error', err);\n          }\n\n          return;\n        }\n\n        conn.query(cmdQuery).once('end', function () {\n          conn.release();\n        });\n      });\n      return cmdQuery;\n    }\n  }, {\n    key: \"execute\",\n    value: function execute(sql, values, cb) {\n      // TODO construct execute command first here and pass it to connection.execute\n      // so that polymorphic arguments logic is there in one place\n      if (typeof values === 'function') {\n        cb = values;\n        values = [];\n      }\n\n      this.getConnection(function (err, conn) {\n        if (err) {\n          return cb(err);\n        }\n\n        var executeCmd = conn.execute(sql, values, cb);\n        executeCmd.once('end', function () {\n          conn.release();\n        });\n      });\n    }\n  }, {\n    key: \"_removeConnection\",\n    value: function _removeConnection(connection) {\n      // Remove connection from all connections\n      spliceConnection(this._allConnections, connection); // Remove connection from free connections\n\n      spliceConnection(this._freeConnections, connection);\n      this.releaseConnection(connection);\n    }\n  }, {\n    key: \"format\",\n    value: function format(sql, values) {\n      return mysql.format(sql, values, this.config.connectionConfig.stringifyObjects, this.config.connectionConfig.timezone);\n    }\n  }, {\n    key: \"escape\",\n    value: function escape(value) {\n      return mysql.escape(value, this.config.connectionConfig.stringifyObjects, this.config.connectionConfig.timezone);\n    }\n  }, {\n    key: \"escapeId\",\n    value: function escapeId(value) {\n      return mysql.escapeId(value, false);\n    }\n  }]);\n\n  return Pool;\n}(EventEmitter);\n\nmodule.exports = Pool;","map":null,"metadata":{},"sourceType":"script"}