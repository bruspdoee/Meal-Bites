{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar util = require('util');\n\nvar _ = require('lodash');\n\nvar uuidv4 = require('uuid/v4');\n\nvar semver = require('semver');\n\nvar Utils = require('../../utils');\n\nvar deprecations = require('../../utils/deprecations');\n\nvar SqlString = require('../../sql-string');\n\nvar DataTypes = require('../../data-types');\n\nvar Model = require('../../model');\n\nvar Association = require('../../associations/base');\n\nvar BelongsTo = require('../../associations/belongs-to');\n\nvar BelongsToMany = require('../../associations/belongs-to-many');\n\nvar HasMany = require('../../associations/has-many');\n\nvar Op = require('../../operators');\n\nvar sequelizeError = require('../../errors');\n\nvar IndexHints = require('../../index-hints');\n\nvar QuoteHelper = require('./query-generator/helpers/quote');\n/**\n * Abstract Query Generator\n *\n * @private\n */\n\n\nvar QueryGenerator = /*#__PURE__*/function () {\n  function QueryGenerator(options) {\n    _classCallCheck(this, QueryGenerator);\n\n    if (!options.sequelize) throw new Error('QueryGenerator initialized without options.sequelize');\n    if (!options._dialect) throw new Error('QueryGenerator initialized without options._dialect');\n    this.sequelize = options.sequelize;\n    this.options = options.sequelize.options; // dialect name\n\n    this.dialect = options._dialect.name;\n    this._dialect = options._dialect;\n  }\n\n  _createClass(QueryGenerator, [{\n    key: \"extractTableDetails\",\n    value: function extractTableDetails(tableName, options) {\n      options = options || {};\n      tableName = tableName || {};\n      return {\n        schema: tableName.schema || options.schema || 'public',\n        tableName: _.isPlainObject(tableName) ? tableName.tableName : tableName,\n        delimiter: tableName.delimiter || options.delimiter || '.'\n      };\n    }\n  }, {\n    key: \"addSchema\",\n    value: function addSchema(param) {\n      if (!param._schema) return param.tableName || param;\n      var self = this;\n      return {\n        tableName: param.tableName || param,\n        table: param.tableName || param,\n        name: param.name || param,\n        schema: param._schema,\n        delimiter: param._schemaDelimiter || '.',\n        toString: function toString() {\n          return self.quoteTable(this);\n        }\n      };\n    }\n  }, {\n    key: \"dropSchema\",\n    value: function dropSchema(tableName, options) {\n      return this.dropTableQuery(tableName, options);\n    }\n  }, {\n    key: \"describeTableQuery\",\n    value: function describeTableQuery(tableName, schema, schemaDelimiter) {\n      var table = this.quoteTable(this.addSchema({\n        tableName: tableName,\n        _schema: schema,\n        _schemaDelimiter: schemaDelimiter\n      }));\n      return \"DESCRIBE \".concat(table, \";\");\n    }\n  }, {\n    key: \"dropTableQuery\",\n    value: function dropTableQuery(tableName) {\n      return \"DROP TABLE IF EXISTS \".concat(this.quoteTable(tableName), \";\");\n    }\n  }, {\n    key: \"renameTableQuery\",\n    value: function renameTableQuery(before, after) {\n      return \"ALTER TABLE \".concat(this.quoteTable(before), \" RENAME TO \").concat(this.quoteTable(after), \";\");\n    }\n    /**\n     * Returns an insert into command\n     *\n     * @param {string} table\n     * @param {Object} valueHash       attribute value pairs\n     * @param {Object} modelAttributes\n     * @param {Object} [options]\n     *\n     * @private\n     */\n\n  }, {\n    key: \"insertQuery\",\n    value: function insertQuery(table, valueHash, modelAttributes, options) {\n      options = options || {};\n\n      _.defaults(options, this.options);\n\n      var modelAttributeMap = {};\n      var fields = [];\n      var values = [];\n      var bind = [];\n      var quotedTable = this.quoteTable(table);\n      var bindParam = options.bindParam === undefined ? this.bindParam(bind) : options.bindParam;\n      var query;\n      var valueQuery = '';\n      var emptyQuery = '';\n      var outputFragment = '';\n      var identityWrapperRequired = false;\n      var tmpTable = ''; //tmpTable declaration for trigger\n\n      if (modelAttributes) {\n        _.each(modelAttributes, function (attribute, key) {\n          modelAttributeMap[key] = attribute;\n\n          if (attribute.field) {\n            modelAttributeMap[attribute.field] = attribute;\n          }\n        });\n      }\n\n      if (this._dialect.supports['DEFAULT VALUES']) {\n        emptyQuery += ' DEFAULT VALUES';\n      } else if (this._dialect.supports['VALUES ()']) {\n        emptyQuery += ' VALUES ()';\n      }\n\n      if (this._dialect.supports.returnValues && options.returning) {\n        if (this._dialect.supports.returnValues.returning) {\n          valueQuery += ' RETURNING *';\n          emptyQuery += ' RETURNING *';\n        } else if (this._dialect.supports.returnValues.output) {\n          outputFragment = ' OUTPUT INSERTED.*'; //To capture output rows when there is a trigger on MSSQL DB\n\n          if (modelAttributes && options.hasTrigger && this._dialect.supports.tmpTableTrigger) {\n            var tmpColumns = '';\n            var outputColumns = '';\n\n            for (var modelKey in modelAttributes) {\n              var attribute = modelAttributes[modelKey];\n\n              if (!(attribute.type instanceof DataTypes.VIRTUAL)) {\n                if (tmpColumns.length > 0) {\n                  tmpColumns += ',';\n                  outputColumns += ',';\n                }\n\n                tmpColumns += \"\".concat(this.quoteIdentifier(attribute.field), \" \").concat(attribute.type.toSql());\n                outputColumns += \"INSERTED.\".concat(this.quoteIdentifier(attribute.field));\n              }\n            }\n\n            tmpTable = \"declare @tmp table (\".concat(tmpColumns, \");\");\n            outputFragment = \" OUTPUT \".concat(outputColumns, \" into @tmp\");\n            var selectFromTmp = ';select * from @tmp';\n            valueQuery += selectFromTmp;\n            emptyQuery += selectFromTmp;\n          }\n        }\n      }\n\n      if (_.get(this, ['sequelize', 'options', 'dialectOptions', 'prependSearchPath']) || options.searchPath) {\n        // Not currently supported with search path (requires output of multiple queries)\n        options.bindParam = false;\n      }\n\n      if (this._dialect.supports.EXCEPTION && options.exception) {\n        // Not currently supported with bind parameters (requires output of multiple queries)\n        options.bindParam = false;\n      }\n\n      valueHash = Utils.removeNullValuesFromHash(valueHash, this.options.omitNull);\n\n      for (var key in valueHash) {\n        if (Object.prototype.hasOwnProperty.call(valueHash, key)) {\n          var value = valueHash[key];\n          fields.push(this.quoteIdentifier(key)); // SERIALS' can't be NULL in postgresql, use DEFAULT where supported\n\n          if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true && !value) {\n            if (!this._dialect.supports.autoIncrement.defaultValue) {\n              fields.splice(-1, 1);\n            } else if (this._dialect.supports.DEFAULT) {\n              values.push('DEFAULT');\n            } else {\n              values.push(this.escape(null));\n            }\n          } else {\n            if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true) {\n              identityWrapperRequired = true;\n            }\n\n            if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n              values.push(this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, {\n                context: 'INSERT'\n              }));\n            } else {\n              values.push(this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, {\n                context: 'INSERT'\n              }, bindParam));\n            }\n          }\n        }\n      }\n\n      var replacements = {\n        ignoreDuplicates: options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : '',\n        onConflictDoNothing: options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : '',\n        attributes: fields.join(','),\n        output: outputFragment,\n        values: values.join(','),\n        tmpTable: tmpTable\n      };\n      valueQuery = \"\".concat(tmpTable, \"INSERT\").concat(replacements.ignoreDuplicates, \" INTO \").concat(quotedTable, \" (\").concat(replacements.attributes, \")\").concat(replacements.output, \" VALUES (\").concat(replacements.values, \")\").concat(replacements.onConflictDoNothing).concat(valueQuery);\n      emptyQuery = \"\".concat(tmpTable, \"INSERT\").concat(replacements.ignoreDuplicates, \" INTO \").concat(quotedTable).concat(replacements.output).concat(replacements.onConflictDoNothing).concat(emptyQuery);\n\n      if (this._dialect.supports.EXCEPTION && options.exception) {\n        // Mostly for internal use, so we expect the user to know what he's doing!\n        // pg_temp functions are private per connection, so we never risk this function interfering with another one.\n        if (semver.gte(this.sequelize.options.databaseVersion, '9.2.0')) {\n          // >= 9.2 - Use a UUID but prefix with 'func_' (numbers first not allowed)\n          var delimiter = \"$func_\".concat(uuidv4().replace(/-/g, ''), \"$\");\n          options.exception = 'WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL;';\n          valueQuery = \"\".concat(\"CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response \".concat(quotedTable, \", OUT sequelize_caught_exception text) RETURNS RECORD AS \").concat(delimiter) + ' BEGIN ').concat(valueQuery, \" INTO response; EXCEPTION \").concat(options.exception, \" END \").concat(delimiter, \" LANGUAGE plpgsql; SELECT (testfunc.response).*, testfunc.sequelize_caught_exception FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc()\");\n        } else {\n          options.exception = 'WHEN unique_violation THEN NULL;';\n          valueQuery = \"CREATE OR REPLACE FUNCTION pg_temp.testfunc() RETURNS SETOF \".concat(quotedTable, \" AS $body$ BEGIN RETURN QUERY \").concat(valueQuery, \"; EXCEPTION \").concat(options.exception, \" END; $body$ LANGUAGE plpgsql; SELECT * FROM pg_temp.testfunc(); DROP FUNCTION IF EXISTS pg_temp.testfunc();\");\n        }\n      }\n\n      if (this._dialect.supports['ON DUPLICATE KEY'] && options.onDuplicate) {\n        valueQuery += \" ON DUPLICATE KEY \".concat(options.onDuplicate);\n        emptyQuery += \" ON DUPLICATE KEY \".concat(options.onDuplicate);\n      }\n\n      query = \"\".concat(replacements.attributes.length ? valueQuery : emptyQuery, \";\");\n\n      if (identityWrapperRequired && this._dialect.supports.autoIncrement.identityInsert) {\n        query = \"SET IDENTITY_INSERT \".concat(quotedTable, \" ON; \").concat(query, \" SET IDENTITY_INSERT \").concat(quotedTable, \" OFF;\");\n      } // Used by Postgres upsertQuery and calls to here with options.exception set to true\n\n\n      var result = {\n        query: query\n      };\n\n      if (options.bindParam !== false) {\n        result.bind = bind;\n      }\n\n      return result;\n    }\n    /**\n     * Returns an insert into command for multiple values.\n     *\n     * @param {string} tableName\n     * @param {Object} fieldValueHashes\n     * @param {Object} options\n     * @param {Object} fieldMappedAttributes\n     *\n     * @private\n     */\n\n  }, {\n    key: \"bulkInsertQuery\",\n    value: function bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {\n      var _this = this;\n\n      options = options || {};\n      fieldMappedAttributes = fieldMappedAttributes || {};\n      var tuples = [];\n      var serials = {};\n      var allAttributes = [];\n      var onDuplicateKeyUpdate = '';\n\n      var _iterator = _createForOfIteratorHelper(fieldValueHashes),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var fieldValueHash = _step.value;\n\n          _.forOwn(fieldValueHash, function (value, key) {\n            if (!allAttributes.includes(key)) {\n              allAttributes.push(key);\n            }\n\n            if (fieldMappedAttributes[key] && fieldMappedAttributes[key].autoIncrement === true) {\n              serials[key] = true;\n            }\n          });\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(fieldValueHashes),\n          _step2;\n\n      try {\n        var _loop = function _loop() {\n          var fieldValueHash = _step2.value;\n          var values = allAttributes.map(function (key) {\n            if (_this._dialect.supports.bulkDefault && serials[key] === true) {\n              return fieldValueHash[key] || 'DEFAULT';\n            }\n\n            return _this.escape(fieldValueHash[key], fieldMappedAttributes[key], {\n              context: 'INSERT'\n            });\n          });\n          tuples.push(\"(\".concat(values.join(','), \")\"));\n        };\n\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      if (this._dialect.supports.inserts.updateOnDuplicate && options.updateOnDuplicate) {\n        if (this._dialect.supports.inserts.updateOnDuplicate == ' ON CONFLICT DO UPDATE SET') {\n          // postgres / sqlite\n          // If no conflict target columns were specified, use the primary key names from options.upsertKeys\n          var conflictKeys = options.upsertKeys.map(function (attr) {\n            return _this.quoteIdentifier(attr);\n          });\n          var updateKeys = options.updateOnDuplicate.map(function (attr) {\n            return \"\".concat(_this.quoteIdentifier(attr), \"=EXCLUDED.\").concat(_this.quoteIdentifier(attr));\n          });\n          onDuplicateKeyUpdate = \" ON CONFLICT (\".concat(conflictKeys.join(','), \") DO UPDATE SET \").concat(updateKeys.join(','));\n        } else {\n          // mysql / maria\n          var valueKeys = options.updateOnDuplicate.map(function (attr) {\n            return \"\".concat(_this.quoteIdentifier(attr), \"=VALUES(\").concat(_this.quoteIdentifier(attr), \")\");\n          });\n          onDuplicateKeyUpdate = \"\".concat(this._dialect.supports.inserts.updateOnDuplicate, \" \").concat(valueKeys.join(','));\n        }\n      }\n\n      var ignoreDuplicates = options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : '';\n      var attributes = allAttributes.map(function (attr) {\n        return _this.quoteIdentifier(attr);\n      }).join(',');\n      var onConflictDoNothing = options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : '';\n      var returning = '';\n\n      if (this._dialect.supports.returnValues && Array.isArray(options.returning)) {\n        var fields = options.returning.map(function (field) {\n          return _this.quoteIdentifier(field);\n        }).join(',');\n        returning += \" RETURNING \".concat(fields);\n      } else {\n        returning += this._dialect.supports.returnValues && options.returning ? ' RETURNING *' : '';\n      }\n\n      return \"INSERT\".concat(ignoreDuplicates, \" INTO \").concat(this.quoteTable(tableName), \" (\").concat(attributes, \") VALUES \").concat(tuples.join(',')).concat(onDuplicateKeyUpdate).concat(onConflictDoNothing).concat(returning, \";\");\n    }\n    /**\n     * Returns an update query\n     *\n     * @param {string} tableName\n     * @param {Object} attrValueHash\n     * @param {Object} where A hash with conditions (e.g. {name: 'foo'}) OR an ID as integer\n     * @param {Object} options\n     * @param {Object} attributes\n     *\n     * @private\n     */\n\n  }, {\n    key: \"updateQuery\",\n    value: function updateQuery(tableName, attrValueHash, where, options, attributes) {\n      options = options || {};\n\n      _.defaults(options, this.options);\n\n      attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n      var values = [];\n      var bind = [];\n      var modelAttributeMap = {};\n      var outputFragment = '';\n      var tmpTable = ''; // tmpTable declaration for trigger\n\n      var selectFromTmp = ''; // Select statement for trigger\n\n      var suffix = '';\n\n      if (_.get(this, ['sequelize', 'options', 'dialectOptions', 'prependSearchPath']) || options.searchPath) {\n        // Not currently supported with search path (requires output of multiple queries)\n        options.bindParam = false;\n      }\n\n      var bindParam = options.bindParam === undefined ? this.bindParam(bind) : options.bindParam;\n\n      if (this._dialect.supports['LIMIT ON UPDATE'] && options.limit) {\n        if (this.dialect !== 'mssql') {\n          suffix = \" LIMIT \".concat(this.escape(options.limit), \" \");\n        }\n      }\n\n      if (this._dialect.supports.returnValues) {\n        if (this._dialect.supports.returnValues.output) {\n          // we always need this for mssql\n          outputFragment = ' OUTPUT INSERTED.*'; //To capture output rows when there is a trigger on MSSQL DB\n\n          if (attributes && options.hasTrigger && this._dialect.supports.tmpTableTrigger) {\n            var tmpColumns = '';\n            var outputColumns = '';\n\n            for (var modelKey in attributes) {\n              var attribute = attributes[modelKey];\n\n              if (!(attribute.type instanceof DataTypes.VIRTUAL)) {\n                if (tmpColumns.length > 0) {\n                  tmpColumns += ',';\n                  outputColumns += ',';\n                }\n\n                tmpColumns += \"\".concat(this.quoteIdentifier(attribute.field), \" \").concat(attribute.type.toSql());\n                outputColumns += \"INSERTED.\".concat(this.quoteIdentifier(attribute.field));\n              }\n            }\n\n            tmpTable = \"declare @tmp table (\".concat(tmpColumns, \"); \");\n            outputFragment = \" OUTPUT \".concat(outputColumns, \" into @tmp\");\n            selectFromTmp = ';select * from @tmp';\n            suffix += selectFromTmp;\n          }\n        } else if (this._dialect.supports.returnValues && options.returning) {\n          // ensure that the return output is properly mapped to model fields.\n          options.mapToModel = true;\n          suffix += ' RETURNING *';\n        }\n      }\n\n      if (attributes) {\n        _.each(attributes, function (attribute, key) {\n          modelAttributeMap[key] = attribute;\n\n          if (attribute.field) {\n            modelAttributeMap[attribute.field] = attribute;\n          }\n        });\n      }\n\n      for (var key in attrValueHash) {\n        if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true && !this._dialect.supports.autoIncrement.update) {\n          // not allowed to update identity column\n          continue;\n        }\n\n        var value = attrValueHash[key];\n\n        if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n          values.push(\"\".concat(this.quoteIdentifier(key), \"=\").concat(this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, {\n            context: 'UPDATE'\n          })));\n        } else {\n          values.push(\"\".concat(this.quoteIdentifier(key), \"=\").concat(this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, {\n            context: 'UPDATE'\n          }, bindParam)));\n        }\n      }\n\n      var whereOptions = _.defaults({\n        bindParam: bindParam\n      }, options);\n\n      if (values.length === 0) {\n        return '';\n      }\n\n      var query = \"\".concat(tmpTable, \"UPDATE \").concat(this.quoteTable(tableName), \" SET \").concat(values.join(',')).concat(outputFragment, \" \").concat(this.whereQuery(where, whereOptions)).concat(suffix).trim(); // Used by Postgres upsertQuery and calls to here with options.exception set to true\n\n      var result = {\n        query: query\n      };\n\n      if (options.bindParam !== false) {\n        result.bind = bind;\n      }\n\n      return result;\n    }\n    /**\n     * Returns an update query using arithmetic operator\n     *\n     * @param {string} operator      String with the arithmetic operator (e.g. '+' or '-')\n     * @param {string} tableName     Name of the table\n     * @param {Object} attrValueHash A hash with attribute-value-pairs\n     * @param {Object} where         A hash with conditions (e.g. {name: 'foo'}) OR an ID as integer\n     * @param {Object} options\n     * @param {Object} attributes\n     */\n\n  }, {\n    key: \"arithmeticQuery\",\n    value: function arithmeticQuery(operator, tableName, attrValueHash, where, options, attributes) {\n      options = options || {};\n\n      _.defaults(options, {\n        returning: true\n      });\n\n      attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, this.options.omitNull);\n      var values = [];\n      var outputFragment = '';\n      var returningFragment = '';\n\n      if (this._dialect.supports.returnValues && options.returning) {\n        if (this._dialect.supports.returnValues.returning) {\n          options.mapToModel = true;\n          returningFragment = 'RETURNING *';\n        } else if (this._dialect.supports.returnValues.output) {\n          outputFragment = ' OUTPUT INSERTED.*';\n        }\n      }\n\n      for (var key in attrValueHash) {\n        var value = attrValueHash[key];\n        values.push(\"\".concat(this.quoteIdentifier(key), \"=\").concat(this.quoteIdentifier(key)).concat(operator, \" \").concat(this.escape(value)));\n      }\n\n      attributes = attributes || {};\n\n      for (var _key in attributes) {\n        var _value = attributes[_key];\n        values.push(\"\".concat(this.quoteIdentifier(_key), \"=\").concat(this.escape(_value)));\n      }\n\n      return \"UPDATE \".concat(this.quoteTable(tableName), \" SET \").concat(values.join(',')).concat(outputFragment, \" \").concat(this.whereQuery(where), \" \").concat(returningFragment).trim();\n    }\n    /*\n      Returns an add index query.\n      Parameters:\n        - tableName -> Name of an existing table, possibly with schema.\n        - options:\n          - type: UNIQUE|FULLTEXT|SPATIAL\n          - name: The name of the index. Default is <table>_<attr1>_<attr2>\n          - fields: An array of attributes as string or as hash.\n                    If the attribute is a hash, it must have the following content:\n                    - name: The name of the attribute/column\n                    - length: An integer. Optional\n                    - order: 'ASC' or 'DESC'. Optional\n          - parser\n          - using\n          - operator\n          - concurrently: Pass CONCURRENT so other operations run while the index is created\n        - rawTablename, the name of the table, without schema. Used to create the name of the index\n     @private\n    */\n\n  }, {\n    key: \"addIndexQuery\",\n    value: function addIndexQuery(tableName, attributes, options, rawTablename) {\n      var _this2 = this;\n\n      options = options || {};\n\n      if (!Array.isArray(attributes)) {\n        options = attributes;\n        attributes = undefined;\n      } else {\n        options.fields = attributes;\n      }\n\n      options.prefix = options.prefix || rawTablename || tableName;\n\n      if (options.prefix && typeof options.prefix === 'string') {\n        options.prefix = options.prefix.replace(/\\./g, '_');\n        options.prefix = options.prefix.replace(/(\"|')/g, '');\n      }\n\n      var fieldsSql = options.fields.map(function (field) {\n        if (typeof field === 'string') {\n          return _this2.quoteIdentifier(field);\n        }\n\n        if (field instanceof Utils.SequelizeMethod) {\n          return _this2.handleSequelizeMethod(field);\n        }\n\n        var result = '';\n\n        if (field.attribute) {\n          field.name = field.attribute;\n        }\n\n        if (!field.name) {\n          throw new Error(\"The following index field has no name: \".concat(util.inspect(field)));\n        }\n\n        result += _this2.quoteIdentifier(field.name);\n\n        if (_this2._dialect.supports.index.collate && field.collate) {\n          result += \" COLLATE \".concat(_this2.quoteIdentifier(field.collate));\n        }\n\n        if (_this2._dialect.supports.index.length && field.length) {\n          result += \"(\".concat(field.length, \")\");\n        }\n\n        if (field.order) {\n          result += \" \".concat(field.order);\n        }\n\n        return result;\n      });\n\n      if (!options.name) {\n        // Mostly for cases where addIndex is called directly by the user without an options object (for example in migrations)\n        // All calls that go through sequelize should already have a name\n        options = Utils.nameIndex(options, options.prefix);\n      }\n\n      options = Model._conformIndex(options);\n\n      if (!this._dialect.supports.index.type) {\n        delete options.type;\n      }\n\n      if (options.where) {\n        options.where = this.whereQuery(options.where);\n      }\n\n      if (typeof tableName === 'string') {\n        tableName = this.quoteIdentifiers(tableName);\n      } else {\n        tableName = this.quoteTable(tableName);\n      }\n\n      var concurrently = this._dialect.supports.index.concurrently && options.concurrently ? 'CONCURRENTLY' : undefined;\n      var ind;\n\n      if (this._dialect.supports.indexViaAlter) {\n        ind = ['ALTER TABLE', tableName, concurrently, 'ADD'];\n      } else {\n        ind = ['CREATE'];\n      }\n\n      ind = ind.concat(options.unique ? 'UNIQUE' : '', options.type, 'INDEX', !this._dialect.supports.indexViaAlter ? concurrently : undefined, this.quoteIdentifiers(options.name), this._dialect.supports.index.using === 1 && options.using ? \"USING \".concat(options.using) : '', !this._dialect.supports.indexViaAlter ? \"ON \".concat(tableName) : undefined, this._dialect.supports.index.using === 2 && options.using ? \"USING \".concat(options.using) : '', \"(\".concat(fieldsSql.join(', ')).concat(options.operator ? \" \".concat(options.operator) : '', \")\"), this._dialect.supports.index.parser && options.parser ? \"WITH PARSER \".concat(options.parser) : undefined, this._dialect.supports.index.where && options.where ? options.where : undefined);\n      return _.compact(ind).join(' ');\n    }\n  }, {\n    key: \"addConstraintQuery\",\n    value: function addConstraintQuery(tableName, options) {\n      options = options || {};\n      var constraintSnippet = this.getConstraintSnippet(tableName, options);\n\n      if (typeof tableName === 'string') {\n        tableName = this.quoteIdentifiers(tableName);\n      } else {\n        tableName = this.quoteTable(tableName);\n      }\n\n      return \"ALTER TABLE \".concat(tableName, \" ADD \").concat(constraintSnippet, \";\");\n    }\n  }, {\n    key: \"getConstraintSnippet\",\n    value: function getConstraintSnippet(tableName, options) {\n      var _this3 = this;\n\n      var constraintSnippet, constraintName;\n      var fieldsSql = options.fields.map(function (field) {\n        if (typeof field === 'string') {\n          return _this3.quoteIdentifier(field);\n        }\n\n        if (field instanceof Utils.SequelizeMethod) {\n          return _this3.handleSequelizeMethod(field);\n        }\n\n        if (field.attribute) {\n          field.name = field.attribute;\n        }\n\n        if (!field.name) {\n          throw new Error(\"The following index field has no name: \".concat(field));\n        }\n\n        return _this3.quoteIdentifier(field.name);\n      });\n      var fieldsSqlQuotedString = fieldsSql.join(', ');\n      var fieldsSqlString = fieldsSql.join('_');\n\n      switch (options.type.toUpperCase()) {\n        case 'UNIQUE':\n          constraintName = this.quoteIdentifier(options.name || \"\".concat(tableName, \"_\").concat(fieldsSqlString, \"_uk\"));\n          constraintSnippet = \"CONSTRAINT \".concat(constraintName, \" UNIQUE (\").concat(fieldsSqlQuotedString, \")\");\n          break;\n\n        case 'CHECK':\n          options.where = this.whereItemsQuery(options.where);\n          constraintName = this.quoteIdentifier(options.name || \"\".concat(tableName, \"_\").concat(fieldsSqlString, \"_ck\"));\n          constraintSnippet = \"CONSTRAINT \".concat(constraintName, \" CHECK (\").concat(options.where, \")\");\n          break;\n\n        case 'DEFAULT':\n          if (options.defaultValue === undefined) {\n            throw new Error('Default value must be specifed for DEFAULT CONSTRAINT');\n          }\n\n          if (this._dialect.name !== 'mssql') {\n            throw new Error('Default constraints are supported only for MSSQL dialect.');\n          }\n\n          constraintName = this.quoteIdentifier(options.name || \"\".concat(tableName, \"_\").concat(fieldsSqlString, \"_df\"));\n          constraintSnippet = \"CONSTRAINT \".concat(constraintName, \" DEFAULT (\").concat(this.escape(options.defaultValue), \") FOR \").concat(fieldsSql[0]);\n          break;\n\n        case 'PRIMARY KEY':\n          constraintName = this.quoteIdentifier(options.name || \"\".concat(tableName, \"_\").concat(fieldsSqlString, \"_pk\"));\n          constraintSnippet = \"CONSTRAINT \".concat(constraintName, \" PRIMARY KEY (\").concat(fieldsSqlQuotedString, \")\");\n          break;\n\n        case 'FOREIGN KEY':\n          var references = options.references;\n\n          if (!references || !references.table || !references.field) {\n            throw new Error('references object with table and field must be specified');\n          }\n\n          constraintName = this.quoteIdentifier(options.name || \"\".concat(tableName, \"_\").concat(fieldsSqlString, \"_\").concat(references.table, \"_fk\"));\n          var referencesSnippet = \"\".concat(this.quoteTable(references.table), \" (\").concat(this.quoteIdentifier(references.field), \")\");\n          constraintSnippet = \"CONSTRAINT \".concat(constraintName, \" \");\n          constraintSnippet += \"FOREIGN KEY (\".concat(fieldsSqlQuotedString, \") REFERENCES \").concat(referencesSnippet);\n\n          if (options.onUpdate) {\n            constraintSnippet += \" ON UPDATE \".concat(options.onUpdate.toUpperCase());\n          }\n\n          if (options.onDelete) {\n            constraintSnippet += \" ON DELETE \".concat(options.onDelete.toUpperCase());\n          }\n\n          break;\n\n        default:\n          throw new Error(\"\".concat(options.type, \" is invalid.\"));\n      }\n\n      return constraintSnippet;\n    }\n  }, {\n    key: \"removeConstraintQuery\",\n    value: function removeConstraintQuery(tableName, constraintName) {\n      if (typeof tableName === 'string') {\n        tableName = this.quoteIdentifiers(tableName);\n      } else {\n        tableName = this.quoteTable(tableName);\n      }\n\n      return \"ALTER TABLE \".concat(tableName, \" DROP CONSTRAINT \").concat(this.quoteIdentifiers(constraintName));\n    }\n    /*\n      Quote an object based on its type. This is a more general version of quoteIdentifiers\n      Strings: should proxy to quoteIdentifiers\n      Arrays:\n        * Expects array in the form: [<model> (optional), <model> (optional),... String, String (optional)]\n          Each <model> can be a model, or an object {model: Model, as: String}, matching include, or an\n          association object, or the name of an association.\n        * Zero or more models can be included in the array and are used to trace a path through the tree of\n          included nested associations. This produces the correct table name for the ORDER BY/GROUP BY SQL\n          and quotes it.\n        * If a single string is appended to end of array, it is quoted.\n          If two strings appended, the 1st string is quoted, the 2nd string unquoted.\n      Objects:\n        * If raw is set, that value should be returned verbatim, without quoting\n        * If fn is set, the string should start with the value of fn, starting paren, followed by\n          the values of cols (which is assumed to be an array), quoted and joined with ', ',\n          unless they are themselves objects\n        * If direction is set, should be prepended\n       Currently this function is only used for ordering / grouping columns and Sequelize.col(), but it could\n      potentially also be used for other places where we want to be able to call SQL functions (e.g. as default values)\n     @private\n    */\n\n  }, {\n    key: \"quote\",\n    value: function quote(collection, parent, connector) {\n      var _this4 = this;\n\n      // init\n      var validOrderOptions = ['ASC', 'DESC', 'ASC NULLS LAST', 'DESC NULLS LAST', 'ASC NULLS FIRST', 'DESC NULLS FIRST', 'NULLS FIRST', 'NULLS LAST']; // default\n\n      connector = connector || '.'; // just quote as identifiers if string\n\n      if (typeof collection === 'string') {\n        return this.quoteIdentifiers(collection);\n      }\n\n      if (Array.isArray(collection)) {\n        // iterate through the collection and mutate objects into associations\n        collection.forEach(function (item, index) {\n          var previous = collection[index - 1];\n          var previousAssociation;\n          var previousModel; // set the previous as the parent when previous is undefined or the target of the association\n\n          if (!previous && parent !== undefined) {\n            previousModel = parent;\n          } else if (previous && previous instanceof Association) {\n            previousAssociation = previous;\n            previousModel = previous.target;\n          } // if the previous item is a model, then attempt getting an association\n\n\n          if (previousModel && previousModel.prototype instanceof Model) {\n            var model;\n            var as;\n\n            if (typeof item === 'function' && item.prototype instanceof Model) {\n              // set\n              model = item;\n            } else if (_.isPlainObject(item) && item.model && item.model.prototype instanceof Model) {\n              // set\n              model = item.model;\n              as = item.as;\n            }\n\n            if (model) {\n              // set the as to either the through name or the model name\n              if (!as && previousAssociation && previousAssociation instanceof Association && previousAssociation.through && previousAssociation.through.model === model) {\n                // get from previous association\n                item = new Association(previousModel, model, {\n                  as: model.name\n                });\n              } else {\n                // get association from previous model\n                item = previousModel.getAssociationForAlias(model, as); // attempt to use the model name if the item is still null\n\n                if (!item) {\n                  item = previousModel.getAssociationForAlias(model, model.name);\n                }\n              } // make sure we have an association\n\n\n              if (!(item instanceof Association)) {\n                throw new Error(util.format('Unable to find a valid association for model, \\'%s\\'', model.name));\n              }\n            }\n          }\n\n          if (typeof item === 'string') {\n            // get order index\n            var orderIndex = validOrderOptions.indexOf(item.toUpperCase()); // see if this is an order\n\n            if (index > 0 && orderIndex !== -1) {\n              item = _this4.sequelize.literal(\" \".concat(validOrderOptions[orderIndex]));\n            } else if (previousModel && previousModel.prototype instanceof Model) {\n              // only go down this path if we have preivous model and check only once\n              if (previousModel.associations !== undefined && previousModel.associations[item]) {\n                // convert the item to an association\n                item = previousModel.associations[item];\n              } else if (previousModel.rawAttributes !== undefined && previousModel.rawAttributes[item] && item !== previousModel.rawAttributes[item].field) {\n                // convert the item attribute from its alias\n                item = previousModel.rawAttributes[item].field;\n              } else if (item.includes('.') && previousModel.rawAttributes !== undefined) {\n                var itemSplit = item.split('.');\n\n                if (previousModel.rawAttributes[itemSplit[0]].type instanceof DataTypes.JSON) {\n                  // just quote identifiers for now\n                  var identifier = _this4.quoteIdentifiers(\"\".concat(previousModel.name, \".\").concat(previousModel.rawAttributes[itemSplit[0]].field)); // get path\n\n\n                  var path = itemSplit.slice(1); // extract path\n\n                  item = _this4.jsonPathExtractionQuery(identifier, path); // literal because we don't want to append the model name when string\n\n                  item = _this4.sequelize.literal(item);\n                }\n              }\n            }\n          }\n\n          collection[index] = item;\n        }, this); // loop through array, adding table names of models to quoted\n\n        var collectionLength = collection.length;\n        var tableNames = [];\n        var item;\n        var i = 0;\n\n        for (i = 0; i < collectionLength - 1; i++) {\n          item = collection[i];\n\n          if (typeof item === 'string' || item._modelAttribute || item instanceof Utils.SequelizeMethod) {\n            break;\n          } else if (item instanceof Association) {\n            tableNames[i] = item.as;\n          }\n        } // start building sql\n\n\n        var sql = '';\n\n        if (i > 0) {\n          sql += \"\".concat(this.quoteIdentifier(tableNames.join(connector)), \".\");\n        } else if (typeof collection[0] === 'string' && parent) {\n          sql += \"\".concat(this.quoteIdentifier(parent.name), \".\");\n        } // loop through everything past i and append to the sql\n\n\n        collection.slice(i).forEach(function (collectionItem) {\n          sql += _this4.quote(collectionItem, parent, connector);\n        }, this);\n        return sql;\n      }\n\n      if (collection._modelAttribute) {\n        return \"\".concat(this.quoteTable(collection.Model.name), \".\").concat(this.quoteIdentifier(collection.fieldName));\n      }\n\n      if (collection instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(collection);\n      }\n\n      if (_.isPlainObject(collection) && collection.raw) {\n        // simple objects with raw is no longer supported\n        throw new Error('The `{raw: \"...\"}` syntax is no longer supported.  Use `sequelize.literal` instead.');\n      }\n\n      throw new Error(\"Unknown structure passed to order / group: \".concat(util.inspect(collection)));\n    }\n    /**\n     * Split a list of identifiers by \".\" and quote each part\n     *\n     * @param {string} identifier\n     * @param {boolean} force\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: \"quoteIdentifier\",\n    value: function quoteIdentifier(identifier, force) {\n      return QuoteHelper.quoteIdentifier(this.dialect, identifier, {\n        force: force,\n        quoteIdentifiers: this.options.quoteIdentifiers\n      });\n    }\n  }, {\n    key: \"quoteIdentifiers\",\n    value: function quoteIdentifiers(identifiers) {\n      if (identifiers.includes('.')) {\n        identifiers = identifiers.split('.');\n        var head = identifiers.slice(0, identifiers.length - 1).join('->');\n        var tail = identifiers[identifiers.length - 1];\n        return \"\".concat(this.quoteIdentifier(head), \".\").concat(this.quoteIdentifier(tail));\n      }\n\n      return this.quoteIdentifier(identifiers);\n    }\n  }, {\n    key: \"quoteAttribute\",\n    value: function quoteAttribute(attribute, model) {\n      if (model && attribute in model.rawAttributes) {\n        return this.quoteIdentifier(attribute);\n      }\n\n      return this.quoteIdentifiers(attribute);\n    }\n    /**\n     * Quote table name with optional alias and schema attribution\n     *\n     * @param {string|Object}  param table string or object\n     * @param {string|boolean} alias alias name\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: \"quoteTable\",\n    value: function quoteTable(param, alias) {\n      var table = '';\n\n      if (alias === true) {\n        alias = param.as || param.name || param;\n      }\n\n      if (_.isObject(param)) {\n        if (this._dialect.supports.schemas) {\n          if (param.schema) {\n            table += \"\".concat(this.quoteIdentifier(param.schema), \".\");\n          }\n\n          table += this.quoteIdentifier(param.tableName);\n        } else {\n          if (param.schema) {\n            table += param.schema + (param.delimiter || '.');\n          }\n\n          table += param.tableName;\n          table = this.quoteIdentifier(table);\n        }\n      } else {\n        table = this.quoteIdentifier(param);\n      }\n\n      if (alias) {\n        table += \" AS \".concat(this.quoteIdentifier(alias));\n      }\n\n      return table;\n    }\n    /*\n      Escape a value (e.g. a string, number or date)\n      @private\n    */\n\n  }, {\n    key: \"escape\",\n    value: function escape(value, field, options) {\n      var _this5 = this;\n\n      options = options || {};\n\n      if (value !== null && value !== undefined) {\n        if (value instanceof Utils.SequelizeMethod) {\n          return this.handleSequelizeMethod(value);\n        }\n\n        if (field && field.type) {\n          this.validate(value, field, options);\n\n          if (field.type.stringify) {\n            // Users shouldn't have to worry about these args - just give them a function that takes a single arg\n            var simpleEscape = function simpleEscape(escVal) {\n              return SqlString.escape(escVal, _this5.options.timezone, _this5.dialect);\n            };\n\n            value = field.type.stringify(value, {\n              escape: simpleEscape,\n              field: field,\n              timezone: this.options.timezone,\n              operation: options.operation\n            });\n\n            if (field.type.escape === false) {\n              // The data-type already did the required escaping\n              return value;\n            }\n          }\n        }\n      }\n\n      return SqlString.escape(value, this.options.timezone, this.dialect);\n    }\n  }, {\n    key: \"bindParam\",\n    value: function bindParam(bind) {\n      return function (value) {\n        bind.push(value);\n        return \"$\".concat(bind.length);\n      };\n    }\n    /*\n      Returns a bind parameter representation of a value (e.g. a string, number or date)\n      @private\n    */\n\n  }, {\n    key: \"format\",\n    value: function format(value, field, options, bindParam) {\n      options = options || {};\n\n      if (value !== null && value !== undefined) {\n        if (value instanceof Utils.SequelizeMethod) {\n          throw new Error('Cannot pass SequelizeMethod as a bind parameter - use escape instead');\n        }\n\n        if (field && field.type) {\n          this.validate(value, field, options);\n\n          if (field.type.bindParam) {\n            return field.type.bindParam(value, {\n              escape: _.identity,\n              field: field,\n              timezone: this.options.timezone,\n              operation: options.operation,\n              bindParam: bindParam\n            });\n          }\n        }\n      }\n\n      return bindParam(value);\n    }\n    /*\n      Validate a value against a field specification\n      @private\n    */\n\n  }, {\n    key: \"validate\",\n    value: function validate(value, field, options) {\n      if (this.typeValidation && field.type.validate && value) {\n        try {\n          if (options.isList && Array.isArray(value)) {\n            var _iterator3 = _createForOfIteratorHelper(value),\n                _step3;\n\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var item = _step3.value;\n                field.type.validate(item, options);\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n          } else {\n            field.type.validate(value, options);\n          }\n        } catch (error) {\n          if (error instanceof sequelizeError.ValidationError) {\n            error.errors.push(new sequelizeError.ValidationErrorItem(error.message, 'Validation error', field.fieldName, value, null, \"\".concat(field.type.key, \" validator\")));\n          }\n\n          throw error;\n        }\n      }\n    }\n  }, {\n    key: \"isIdentifierQuoted\",\n    value: function isIdentifierQuoted(identifier) {\n      return QuoteHelper.isIdentifierQuoted(identifier);\n    }\n    /**\n     * Generates an SQL query that extract JSON property of given path.\n     *\n     * @param   {string}               column  The JSON column\n     * @param   {string|Array<string>} [path]  The path to extract (optional)\n     * @returns {string}                       The generated sql query\n     * @private\n     */\n\n  }, {\n    key: \"jsonPathExtractionQuery\",\n    value: function jsonPathExtractionQuery(column, path) {\n      var paths = _.toPath(path);\n\n      var pathStr;\n      var quotedColumn = this.isIdentifierQuoted(column) ? column : this.quoteIdentifier(column);\n\n      switch (this.dialect) {\n        case 'mysql':\n        case 'mariadb':\n        case 'sqlite':\n          /**\n           * Non digit sub paths need to be quoted as ECMAScript identifiers\n           * https://bugs.mysql.com/bug.php?id=81896\n           */\n          if (this.dialect === 'mysql') {\n            paths = paths.map(function (subPath) {\n              return /\\D/.test(subPath) ? Utils.addTicks(subPath, '\"') : subPath;\n            });\n          }\n\n          pathStr = this.escape(['$'].concat(paths).join('.').replace(/\\.(\\d+)(?:(?=\\.)|$)/g, function (__, digit) {\n            return \"[\".concat(digit, \"]\");\n          }));\n\n          if (this.dialect === 'sqlite') {\n            return \"json_extract(\".concat(quotedColumn, \",\").concat(pathStr, \")\");\n          }\n\n          return \"json_unquote(json_extract(\".concat(quotedColumn, \",\").concat(pathStr, \"))\");\n\n        case 'postgres':\n          pathStr = this.escape(\"{\".concat(paths.join(','), \"}\"));\n          return \"(\".concat(quotedColumn, \"#>>\").concat(pathStr, \")\");\n\n        default:\n          throw new Error(\"Unsupported \".concat(this.dialect, \" for JSON operations\"));\n      }\n    }\n    /*\n      Returns a query for selecting elements in the table <tableName>.\n      Options:\n        - attributes -> An array of attributes (e.g. ['name', 'birthday']). Default: *\n        - where -> A hash with conditions (e.g. {name: 'foo'})\n                   OR an ID as integer\n        - order -> e.g. 'id DESC'\n        - group\n        - limit -> The maximum count you want to get.\n        - offset -> An offset value to start from. Only useable with limit!\n     @private\n    */\n\n  }, {\n    key: \"selectQuery\",\n    value: function selectQuery(tableName, options, model) {\n      var _this6 = this;\n\n      options = options || {};\n      var limit = options.limit;\n      var mainQueryItems = [];\n      var subQueryItems = [];\n      var subQuery = options.subQuery === undefined ? limit && options.hasMultiAssociation : options.subQuery;\n      var attributes = {\n        main: options.attributes && options.attributes.slice(),\n        subQuery: null\n      };\n      var mainTable = {\n        name: tableName,\n        quotedName: null,\n        as: null,\n        model: model\n      };\n      var topLevelInfo = {\n        names: mainTable,\n        options: options,\n        subQuery: subQuery\n      };\n      var mainJoinQueries = [];\n      var subJoinQueries = [];\n      var query; // Aliases can be passed through subqueries and we don't want to reset them\n\n      if (this.options.minifyAliases && !options.aliasesMapping) {\n        options.aliasesMapping = new Map();\n        options.aliasesByTable = {};\n      } // resolve table name options\n\n\n      if (options.tableAs) {\n        mainTable.as = this.quoteIdentifier(options.tableAs);\n      } else if (!Array.isArray(mainTable.name) && mainTable.model) {\n        mainTable.as = this.quoteIdentifier(mainTable.model.name);\n      }\n\n      mainTable.quotedName = !Array.isArray(mainTable.name) ? this.quoteTable(mainTable.name) : tableName.map(function (t) {\n        return Array.isArray(t) ? _this6.quoteTable(t[0], t[1]) : _this6.quoteTable(t, true);\n      }).join(', ');\n\n      if (subQuery && attributes.main) {\n        var _iterator4 = _createForOfIteratorHelper(mainTable.model.primaryKeyAttributes),\n            _step4;\n\n        try {\n          var _loop2 = function _loop2() {\n            var keyAtt = _step4.value;\n\n            // Check if mainAttributes contain the primary key of the model either as a field or an aliased field\n            if (!attributes.main.some(function (attr) {\n              return keyAtt === attr || keyAtt === attr[0] || keyAtt === attr[1];\n            })) {\n              attributes.main.push(mainTable.model.rawAttributes[keyAtt].field ? [keyAtt, mainTable.model.rawAttributes[keyAtt].field] : keyAtt);\n            }\n          };\n\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            _loop2();\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n\n      attributes.main = this.escapeAttributes(attributes.main, options, mainTable.as);\n      attributes.main = attributes.main || (options.include ? [\"\".concat(mainTable.as, \".*\")] : ['*']); // If subquery, we add the mainAttributes to the subQuery and set the mainAttributes to select * from subquery\n\n      if (subQuery || options.groupedLimit) {\n        // We need primary keys\n        attributes.subQuery = attributes.main;\n        attributes.main = [\"\".concat(mainTable.as || mainTable.quotedName, \".*\")];\n      }\n\n      if (options.include) {\n        var _iterator5 = _createForOfIteratorHelper(options.include),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var include = _step5.value;\n\n            if (include.separate) {\n              continue;\n            }\n\n            var joinQueries = this.generateInclude(include, {\n              externalAs: mainTable.as,\n              internalAs: mainTable.as\n            }, topLevelInfo);\n            subJoinQueries = subJoinQueries.concat(joinQueries.subQuery);\n            mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);\n\n            if (joinQueries.attributes.main.length > 0) {\n              attributes.main = _.uniq(attributes.main.concat(joinQueries.attributes.main));\n            }\n\n            if (joinQueries.attributes.subQuery.length > 0) {\n              attributes.subQuery = _.uniq(attributes.subQuery.concat(joinQueries.attributes.subQuery));\n            }\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n\n      if (subQuery) {\n        subQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.subQuery, mainTable.quotedName, mainTable.as));\n        subQueryItems.push(subJoinQueries.join(''));\n      } else {\n        if (options.groupedLimit) {\n          if (!mainTable.as) {\n            mainTable.as = mainTable.quotedName;\n          }\n\n          var where = Object.assign({}, options.where);\n\n          var groupedLimitOrder,\n              whereKey,\n              _include,\n              groupedTableName = mainTable.as;\n\n          if (typeof options.groupedLimit.on === 'string') {\n            whereKey = options.groupedLimit.on;\n          } else if (options.groupedLimit.on instanceof HasMany) {\n            whereKey = options.groupedLimit.on.foreignKeyField;\n          }\n\n          if (options.groupedLimit.on instanceof BelongsToMany) {\n            // BTM includes needs to join the through table on to check ID\n            groupedTableName = options.groupedLimit.on.manyFromSource.as;\n\n            var groupedLimitOptions = Model._validateIncludedElements({\n              include: [{\n                association: options.groupedLimit.on.manyFromSource,\n                duplicating: false,\n                // The UNION'ed query may contain duplicates, but each sub-query cannot\n                required: true,\n                where: Object.assign(_defineProperty({}, Op.placeholder, true), options.groupedLimit.through && options.groupedLimit.through.where)\n              }],\n              model: model\n            }); // Make sure attributes from the join table are mapped back to models\n\n\n            options.hasJoin = true;\n            options.hasMultiAssociation = true;\n            options.includeMap = Object.assign(groupedLimitOptions.includeMap, options.includeMap);\n            options.includeNames = groupedLimitOptions.includeNames.concat(options.includeNames || []);\n            _include = groupedLimitOptions.include;\n\n            if (Array.isArray(options.order)) {\n              // We need to make sure the order by attributes are available to the parent query\n              options.order.forEach(function (order, i) {\n                if (Array.isArray(order)) {\n                  order = order[0];\n                }\n\n                var alias = \"subquery_order_\".concat(i);\n                options.attributes.push([order, alias]); // We don't want to prepend model name when we alias the attributes, so quote them here\n\n                alias = _this6.sequelize.literal(_this6.quote(alias));\n\n                if (Array.isArray(options.order[i])) {\n                  options.order[i][0] = alias;\n                } else {\n                  options.order[i] = alias;\n                }\n              });\n              groupedLimitOrder = options.order;\n            }\n          } else {\n            // Ordering is handled by the subqueries, so ordering the UNION'ed result is not needed\n            groupedLimitOrder = options.order;\n            delete options.order;\n            where[Op.placeholder] = true;\n          } // Caching the base query and splicing the where part into it is consistently > twice\n          // as fast than generating from scratch each time for values.length >= 5\n\n\n          var baseQuery = \"SELECT * FROM (\".concat(this.selectQuery(tableName, {\n            attributes: options.attributes,\n            offset: options.offset,\n            limit: options.groupedLimit.limit,\n            order: groupedLimitOrder,\n            aliasesMapping: options.aliasesMapping,\n            aliasesByTable: options.aliasesByTable,\n            where: where,\n            include: _include,\n            model: model\n          }, model).replace(/;$/, ''), \") AS sub\"); // Every derived table must have its own alias\n\n          var placeHolder = this.whereItemQuery(Op.placeholder, true, {\n            model: model\n          });\n          var splicePos = baseQuery.indexOf(placeHolder);\n          mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, \"(\".concat(options.groupedLimit.values.map(function (value) {\n            var groupWhere;\n\n            if (whereKey) {\n              groupWhere = _defineProperty({}, whereKey, value);\n            }\n\n            if (_include) {\n              groupWhere = _defineProperty({}, options.groupedLimit.on.foreignIdentifierField, value);\n            }\n\n            return Utils.spliceStr(baseQuery, splicePos, placeHolder.length, _this6.getWhereConditions(groupWhere, groupedTableName));\n          }).join(this._dialect.supports['UNION ALL'] ? ' UNION ALL ' : ' UNION '), \")\"), mainTable.as));\n        } else {\n          mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, mainTable.quotedName, mainTable.as));\n        }\n\n        mainQueryItems.push(mainJoinQueries.join(''));\n      } // Add WHERE to sub or main query\n\n\n      if (Object.prototype.hasOwnProperty.call(options, 'where') && !options.groupedLimit) {\n        options.where = this.getWhereConditions(options.where, mainTable.as || tableName, model, options);\n\n        if (options.where) {\n          if (subQuery) {\n            subQueryItems.push(\" WHERE \".concat(options.where));\n          } else {\n            mainQueryItems.push(\" WHERE \".concat(options.where)); // Walk the main query to update all selects\n\n            mainQueryItems.forEach(function (value, key) {\n              if (value.startsWith('SELECT')) {\n                mainQueryItems[key] = _this6.selectFromTableFragment(options, model, attributes.main, mainTable.quotedName, mainTable.as, options.where);\n              }\n            });\n          }\n        }\n      } // Add GROUP BY to sub or main query\n\n\n      if (options.group) {\n        options.group = Array.isArray(options.group) ? options.group.map(function (t) {\n          return _this6.aliasGrouping(t, model, mainTable.as, options);\n        }).join(', ') : this.aliasGrouping(options.group, model, mainTable.as, options);\n\n        if (subQuery) {\n          subQueryItems.push(\" GROUP BY \".concat(options.group));\n        } else {\n          mainQueryItems.push(\" GROUP BY \".concat(options.group));\n        }\n      } // Add HAVING to sub or main query\n\n\n      if (Object.prototype.hasOwnProperty.call(options, 'having')) {\n        options.having = this.getWhereConditions(options.having, tableName, model, options, false);\n\n        if (options.having) {\n          if (subQuery) {\n            subQueryItems.push(\" HAVING \".concat(options.having));\n          } else {\n            mainQueryItems.push(\" HAVING \".concat(options.having));\n          }\n        }\n      } // Add ORDER to sub or main query\n\n\n      if (options.order) {\n        var orders = this.getQueryOrders(options, model, subQuery);\n\n        if (orders.mainQueryOrder.length) {\n          mainQueryItems.push(\" ORDER BY \".concat(orders.mainQueryOrder.join(', ')));\n        }\n\n        if (orders.subQueryOrder.length) {\n          subQueryItems.push(\" ORDER BY \".concat(orders.subQueryOrder.join(', ')));\n        }\n      } // Add LIMIT, OFFSET to sub or main query\n\n\n      var limitOrder = this.addLimitAndOffset(options, mainTable.model);\n\n      if (limitOrder && !options.groupedLimit) {\n        if (subQuery) {\n          subQueryItems.push(limitOrder);\n        } else {\n          mainQueryItems.push(limitOrder);\n        }\n      }\n\n      if (subQuery) {\n        query = \"SELECT \".concat(attributes.main.join(', '), \" FROM (\").concat(subQueryItems.join(''), \") AS \").concat(mainTable.as).concat(mainJoinQueries.join('')).concat(mainQueryItems.join(''));\n      } else {\n        query = mainQueryItems.join('');\n      }\n\n      if (options.lock && this._dialect.supports.lock) {\n        var lock = options.lock;\n\n        if (typeof options.lock === 'object') {\n          lock = options.lock.level;\n        }\n\n        if (this._dialect.supports.lockKey && (lock === 'KEY SHARE' || lock === 'NO KEY UPDATE')) {\n          query += \" FOR \".concat(lock);\n        } else if (lock === 'SHARE') {\n          query += \" \".concat(this._dialect.supports.forShare);\n        } else {\n          query += ' FOR UPDATE';\n        }\n\n        if (this._dialect.supports.lockOf && options.lock.of && options.lock.of.prototype instanceof Model) {\n          query += \" OF \".concat(this.quoteTable(options.lock.of.name));\n        }\n\n        if (this._dialect.supports.skipLocked && options.skipLocked) {\n          query += ' SKIP LOCKED';\n        }\n      }\n\n      return \"\".concat(query, \";\");\n    }\n  }, {\n    key: \"aliasGrouping\",\n    value: function aliasGrouping(field, model, tableName, options) {\n      var src = Array.isArray(field) ? field[0] : field;\n      return this.quote(this._getAliasForField(tableName, src, options) || src, model);\n    }\n  }, {\n    key: \"escapeAttributes\",\n    value: function escapeAttributes(attributes, options, mainTableAs) {\n      var _this7 = this;\n\n      return attributes && attributes.map(function (attr) {\n        var addTable = true;\n\n        if (attr instanceof Utils.SequelizeMethod) {\n          return _this7.handleSequelizeMethod(attr);\n        }\n\n        if (Array.isArray(attr)) {\n          if (attr.length !== 2) {\n            throw new Error(\"\".concat(JSON.stringify(attr), \" is not a valid attribute definition. Please use the following format: ['attribute definition', 'alias']\"));\n          }\n\n          attr = attr.slice();\n\n          if (attr[0] instanceof Utils.SequelizeMethod) {\n            attr[0] = _this7.handleSequelizeMethod(attr[0]);\n            addTable = false;\n          } else if (!attr[0].includes('(') && !attr[0].includes(')')) {\n            attr[0] = _this7.quoteIdentifier(attr[0]);\n          } else {\n            deprecations.noRawAttributes();\n          }\n\n          var alias = attr[1];\n\n          if (_this7.options.minifyAliases) {\n            alias = _this7._getMinifiedAlias(alias, mainTableAs, options);\n          }\n\n          attr = [attr[0], _this7.quoteIdentifier(alias)].join(' AS ');\n        } else {\n          attr = !attr.includes(Utils.TICK_CHAR) && !attr.includes('\"') ? _this7.quoteAttribute(attr, options.model) : _this7.escape(attr);\n        }\n\n        if (!_.isEmpty(options.include) && !attr.includes('.') && addTable) {\n          attr = \"\".concat(mainTableAs, \".\").concat(attr);\n        }\n\n        return attr;\n      });\n    }\n  }, {\n    key: \"generateInclude\",\n    value: function generateInclude(include, parentTableName, topLevelInfo) {\n      var _this8 = this;\n\n      var joinQueries = {\n        mainQuery: [],\n        subQuery: []\n      };\n      var mainChildIncludes = [];\n      var subChildIncludes = [];\n      var requiredMismatch = false;\n      var includeAs = {\n        internalAs: include.as,\n        externalAs: include.as\n      };\n      var attributes = {\n        main: [],\n        subQuery: []\n      };\n      var joinQuery;\n      topLevelInfo.options.keysEscaped = true;\n\n      if (topLevelInfo.names.name !== parentTableName.externalAs && topLevelInfo.names.as !== parentTableName.externalAs) {\n        includeAs.internalAs = \"\".concat(parentTableName.internalAs, \"->\").concat(include.as);\n        includeAs.externalAs = \"\".concat(parentTableName.externalAs, \".\").concat(include.as);\n      } // includeIgnoreAttributes is used by aggregate functions\n\n\n      if (topLevelInfo.options.includeIgnoreAttributes !== false) {\n        include.model._expandAttributes(include);\n\n        Utils.mapFinderOptions(include, include.model);\n        var includeAttributes = include.attributes.map(function (attr) {\n          var attrAs = attr;\n          var verbatim = false;\n\n          if (Array.isArray(attr) && attr.length === 2) {\n            if (attr[0] instanceof Utils.SequelizeMethod && (attr[0] instanceof Utils.Literal || attr[0] instanceof Utils.Cast || attr[0] instanceof Utils.Fn)) {\n              verbatim = true;\n            }\n\n            attr = attr.map(function (attr) {\n              return attr instanceof Utils.SequelizeMethod ? _this8.handleSequelizeMethod(attr) : attr;\n            });\n            attrAs = attr[1];\n            attr = attr[0];\n          }\n\n          if (attr instanceof Utils.Literal) {\n            return attr.val; // We trust the user to rename the field correctly\n          }\n\n          if (attr instanceof Utils.Cast || attr instanceof Utils.Fn) {\n            throw new Error('Tried to select attributes using Sequelize.cast or Sequelize.fn without specifying an alias for the result, during eager loading. ' + 'This means the attribute will not be added to the returned instance');\n          }\n\n          var prefix;\n\n          if (verbatim === true) {\n            prefix = attr;\n          } else if (/#>>|->>/.test(attr)) {\n            prefix = \"(\".concat(_this8.quoteIdentifier(includeAs.internalAs), \".\").concat(attr.replace(/\\(|\\)/g, ''), \")\");\n          } else if (/json_extract\\(/.test(attr)) {\n            prefix = attr.replace(/json_extract\\(/i, \"json_extract(\".concat(_this8.quoteIdentifier(includeAs.internalAs), \".\"));\n          } else {\n            prefix = \"\".concat(_this8.quoteIdentifier(includeAs.internalAs), \".\").concat(_this8.quoteIdentifier(attr));\n          }\n\n          var alias = \"\".concat(includeAs.externalAs, \".\").concat(attrAs);\n\n          if (_this8.options.minifyAliases) {\n            alias = _this8._getMinifiedAlias(alias, includeAs.internalAs, topLevelInfo.options);\n          }\n\n          return \"\".concat(prefix, \" AS \").concat(_this8.quoteIdentifier(alias, true));\n        });\n\n        if (include.subQuery && topLevelInfo.subQuery) {\n          var _iterator6 = _createForOfIteratorHelper(includeAttributes),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var attr = _step6.value;\n              attributes.subQuery.push(attr);\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n        } else {\n          var _iterator7 = _createForOfIteratorHelper(includeAttributes),\n              _step7;\n\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var _attr = _step7.value;\n              attributes.main.push(_attr);\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n        }\n      } //through\n\n\n      if (include.through) {\n        joinQuery = this.generateThroughJoin(include, includeAs, parentTableName.internalAs, topLevelInfo);\n      } else {\n        this._generateSubQueryFilter(include, includeAs, topLevelInfo);\n\n        joinQuery = this.generateJoin(include, topLevelInfo);\n      } // handle possible new attributes created in join\n\n\n      if (joinQuery.attributes.main.length > 0) {\n        attributes.main = attributes.main.concat(joinQuery.attributes.main);\n      }\n\n      if (joinQuery.attributes.subQuery.length > 0) {\n        attributes.subQuery = attributes.subQuery.concat(joinQuery.attributes.subQuery);\n      }\n\n      if (include.include) {\n        var _iterator8 = _createForOfIteratorHelper(include.include),\n            _step8;\n\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var childInclude = _step8.value;\n\n            if (childInclude.separate || childInclude._pseudo) {\n              continue;\n            }\n\n            var childJoinQueries = this.generateInclude(childInclude, includeAs, topLevelInfo);\n\n            if (include.required === false && childInclude.required === true) {\n              requiredMismatch = true;\n            } // if the child is a sub query we just give it to the\n\n\n            if (childInclude.subQuery && topLevelInfo.subQuery) {\n              subChildIncludes.push(childJoinQueries.subQuery);\n            }\n\n            if (childJoinQueries.mainQuery) {\n              mainChildIncludes.push(childJoinQueries.mainQuery);\n            }\n\n            if (childJoinQueries.attributes.main.length > 0) {\n              attributes.main = attributes.main.concat(childJoinQueries.attributes.main);\n            }\n\n            if (childJoinQueries.attributes.subQuery.length > 0) {\n              attributes.subQuery = attributes.subQuery.concat(childJoinQueries.attributes.subQuery);\n            }\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n      }\n\n      if (include.subQuery && topLevelInfo.subQuery) {\n        if (requiredMismatch && subChildIncludes.length > 0) {\n          joinQueries.subQuery.push(\" \".concat(joinQuery.join, \" ( \").concat(joinQuery.body).concat(subChildIncludes.join(''), \" ) ON \").concat(joinQuery.condition));\n        } else {\n          joinQueries.subQuery.push(\" \".concat(joinQuery.join, \" \").concat(joinQuery.body, \" ON \").concat(joinQuery.condition));\n\n          if (subChildIncludes.length > 0) {\n            joinQueries.subQuery.push(subChildIncludes.join(''));\n          }\n        }\n\n        joinQueries.mainQuery.push(mainChildIncludes.join(''));\n      } else {\n        if (requiredMismatch && mainChildIncludes.length > 0) {\n          joinQueries.mainQuery.push(\" \".concat(joinQuery.join, \" ( \").concat(joinQuery.body).concat(mainChildIncludes.join(''), \" ) ON \").concat(joinQuery.condition));\n        } else {\n          joinQueries.mainQuery.push(\" \".concat(joinQuery.join, \" \").concat(joinQuery.body, \" ON \").concat(joinQuery.condition));\n\n          if (mainChildIncludes.length > 0) {\n            joinQueries.mainQuery.push(mainChildIncludes.join(''));\n          }\n        }\n\n        joinQueries.subQuery.push(subChildIncludes.join(''));\n      }\n\n      return {\n        mainQuery: joinQueries.mainQuery.join(''),\n        subQuery: joinQueries.subQuery.join(''),\n        attributes: attributes\n      };\n    }\n  }, {\n    key: \"_getMinifiedAlias\",\n    value: function _getMinifiedAlias(alias, tableName, options) {\n      // We do not want to re-alias in case of a subquery\n      if (options.aliasesByTable[\"\".concat(tableName).concat(alias)]) {\n        return options.aliasesByTable[\"\".concat(tableName).concat(alias)];\n      } // Do not alias custom suquery_orders\n\n\n      if (alias.match(/subquery_order_[0-9]/)) {\n        return alias;\n      }\n\n      var minifiedAlias = \"_\".concat(options.aliasesMapping.size);\n      options.aliasesMapping.set(minifiedAlias, alias);\n      options.aliasesByTable[\"\".concat(tableName).concat(alias)] = minifiedAlias;\n      return minifiedAlias;\n    }\n  }, {\n    key: \"_getAliasForField\",\n    value: function _getAliasForField(tableName, field, options) {\n      if (this.options.minifyAliases) {\n        if (options.aliasesByTable[\"\".concat(tableName).concat(field)]) {\n          return options.aliasesByTable[\"\".concat(tableName).concat(field)];\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"generateJoin\",\n    value: function generateJoin(include, topLevelInfo) {\n      var association = include.association;\n      var parent = include.parent;\n      var parentIsTop = !!parent && !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;\n      var $parent;\n      var joinWhere;\n      /* Attributes for the left side */\n\n      var left = association.source;\n      var attrLeft = association instanceof BelongsTo ? association.identifier : association.sourceKeyAttribute || left.primaryKeyAttribute;\n      var fieldLeft = association instanceof BelongsTo ? association.identifierField : left.rawAttributes[association.sourceKeyAttribute || left.primaryKeyAttribute].field;\n      var asLeft;\n      /* Attributes for the right side */\n\n      var right = include.model;\n      var tableRight = right.getTableName();\n      var fieldRight = association instanceof BelongsTo ? right.rawAttributes[association.targetIdentifier || right.primaryKeyAttribute].field : association.identifierField;\n      var asRight = include.as;\n\n      while (($parent = $parent && $parent.parent || include.parent) && $parent.association) {\n        if (asLeft) {\n          asLeft = \"\".concat($parent.as, \"->\").concat(asLeft);\n        } else {\n          asLeft = $parent.as;\n        }\n      }\n\n      if (!asLeft) asLeft = parent.as || parent.model.name;else asRight = \"\".concat(asLeft, \"->\").concat(asRight);\n      var joinOn = \"\".concat(this.quoteTable(asLeft), \".\").concat(this.quoteIdentifier(fieldLeft));\n      var subqueryAttributes = [];\n\n      if (topLevelInfo.options.groupedLimit && parentIsTop || topLevelInfo.subQuery && include.parent.subQuery && !include.subQuery) {\n        if (parentIsTop) {\n          // The main model attributes is not aliased to a prefix\n          var tableName = this.quoteTable(parent.as || parent.model.name); // Check for potential aliased JOIN condition\n\n          joinOn = this._getAliasForField(tableName, attrLeft, topLevelInfo.options) || \"\".concat(tableName, \".\").concat(this.quoteIdentifier(attrLeft));\n\n          if (topLevelInfo.subQuery) {\n            subqueryAttributes.push(\"\".concat(tableName, \".\").concat(this.quoteIdentifier(fieldLeft)));\n          }\n        } else {\n          var joinSource = \"\".concat(asLeft.replace(/->/g, '.'), \".\").concat(attrLeft); // Check for potential aliased JOIN condition\n\n          joinOn = this._getAliasForField(asLeft, joinSource, topLevelInfo.options) || this.quoteIdentifier(joinSource);\n        }\n      }\n\n      joinOn += \" = \".concat(this.quoteIdentifier(asRight), \".\").concat(this.quoteIdentifier(fieldRight));\n\n      if (include.on) {\n        joinOn = this.whereItemsQuery(include.on, {\n          prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),\n          model: include.model\n        });\n      }\n\n      if (include.where) {\n        joinWhere = this.whereItemsQuery(include.where, {\n          prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),\n          model: include.model\n        });\n\n        if (joinWhere) {\n          if (include.or) {\n            joinOn += \" OR \".concat(joinWhere);\n          } else {\n            joinOn += \" AND \".concat(joinWhere);\n          }\n        }\n      }\n\n      return {\n        join: include.required ? 'INNER JOIN' : include.right && this._dialect.supports['RIGHT JOIN'] ? 'RIGHT OUTER JOIN' : 'LEFT OUTER JOIN',\n        body: this.quoteTable(tableRight, asRight),\n        condition: joinOn,\n        attributes: {\n          main: [],\n          subQuery: subqueryAttributes\n        }\n      };\n    }\n  }, {\n    key: \"generateThroughJoin\",\n    value: function generateThroughJoin(include, includeAs, parentTableName, topLevelInfo) {\n      var _this9 = this;\n\n      var through = include.through;\n      var throughTable = through.model.getTableName();\n      var throughAs = \"\".concat(includeAs.internalAs, \"->\").concat(through.as);\n      var externalThroughAs = \"\".concat(includeAs.externalAs, \".\").concat(through.as);\n      var throughAttributes = through.attributes.map(function (attr) {\n        var alias = \"\".concat(externalThroughAs, \".\").concat(Array.isArray(attr) ? attr[1] : attr);\n\n        if (_this9.options.minifyAliases) {\n          alias = _this9._getMinifiedAlias(alias, throughAs, topLevelInfo.options);\n        }\n\n        return \"\".concat(_this9.quoteIdentifier(throughAs), \".\").concat(_this9.quoteIdentifier(Array.isArray(attr) ? attr[0] : attr), \" AS \").concat(_this9.quoteIdentifier(alias));\n      });\n      var association = include.association;\n      var parentIsTop = !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;\n      var tableSource = parentTableName;\n      var identSource = association.identifierField;\n      var tableTarget = includeAs.internalAs;\n      var identTarget = association.foreignIdentifierField;\n      var attrTarget = association.targetKeyField;\n      var joinType = include.required ? 'INNER JOIN' : include.right && this._dialect.supports['RIGHT JOIN'] ? 'RIGHT OUTER JOIN' : 'LEFT OUTER JOIN';\n      var joinBody;\n      var joinCondition;\n      var attributes = {\n        main: [],\n        subQuery: []\n      };\n      var attrSource = association.sourceKey;\n      var sourceJoinOn;\n      var targetJoinOn;\n      var throughWhere;\n      var targetWhere;\n\n      if (topLevelInfo.options.includeIgnoreAttributes !== false) {\n        // Through includes are always hasMany, so we need to add the attributes to the mainAttributes no matter what (Real join will never be executed in subquery)\n        var _iterator9 = _createForOfIteratorHelper(throughAttributes),\n            _step9;\n\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var attr = _step9.value;\n            attributes.main.push(attr);\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n      } // Figure out if we need to use field or attribute\n\n\n      if (!topLevelInfo.subQuery) {\n        attrSource = association.sourceKeyField;\n      }\n\n      if (topLevelInfo.subQuery && !include.subQuery && !include.parent.subQuery && include.parent.model !== topLevelInfo.options.mainModel) {\n        attrSource = association.sourceKeyField;\n      } // Filter statement for left side of through\n      // Used by both join and subquery where\n      // If parent include was in a subquery need to join on the aliased attribute\n\n\n      if (topLevelInfo.subQuery && !include.subQuery && include.parent.subQuery && !parentIsTop) {\n        // If we are minifying aliases and our JOIN target has been minified, we need to use the alias instead of the original column name\n        var joinSource = this._getAliasForField(tableSource, \"\".concat(tableSource, \".\").concat(attrSource), topLevelInfo.options) || \"\".concat(tableSource, \".\").concat(attrSource);\n        sourceJoinOn = \"\".concat(this.quoteIdentifier(joinSource), \" = \");\n      } else {\n        // If we are minifying aliases and our JOIN target has been minified, we need to use the alias instead of the original column name\n        var aliasedSource = this._getAliasForField(tableSource, attrSource, topLevelInfo.options) || attrSource;\n        sourceJoinOn = \"\".concat(this.quoteTable(tableSource), \".\").concat(this.quoteIdentifier(aliasedSource), \" = \");\n      }\n\n      sourceJoinOn += \"\".concat(this.quoteIdentifier(throughAs), \".\").concat(this.quoteIdentifier(identSource)); // Filter statement for right side of through\n      // Used by both join and subquery where\n\n      targetJoinOn = \"\".concat(this.quoteIdentifier(tableTarget), \".\").concat(this.quoteIdentifier(attrTarget), \" = \");\n      targetJoinOn += \"\".concat(this.quoteIdentifier(throughAs), \".\").concat(this.quoteIdentifier(identTarget));\n\n      if (through.where) {\n        throughWhere = this.getWhereConditions(through.where, this.sequelize.literal(this.quoteIdentifier(throughAs)), through.model);\n      }\n\n      if (this._dialect.supports.joinTableDependent) {\n        // Generate a wrapped join so that the through table join can be dependent on the target join\n        joinBody = \"( \".concat(this.quoteTable(throughTable, throughAs), \" INNER JOIN \").concat(this.quoteTable(include.model.getTableName(), includeAs.internalAs), \" ON \").concat(targetJoinOn);\n\n        if (throughWhere) {\n          joinBody += \" AND \".concat(throughWhere);\n        }\n\n        joinBody += ')';\n        joinCondition = sourceJoinOn;\n      } else {\n        // Generate join SQL for left side of through\n        joinBody = \"\".concat(this.quoteTable(throughTable, throughAs), \" ON \").concat(sourceJoinOn, \" \").concat(joinType, \" \").concat(this.quoteTable(include.model.getTableName(), includeAs.internalAs));\n        joinCondition = targetJoinOn;\n\n        if (throughWhere) {\n          joinCondition += \" AND \".concat(throughWhere);\n        }\n      }\n\n      if (include.where || include.through.where) {\n        if (include.where) {\n          targetWhere = this.getWhereConditions(include.where, this.sequelize.literal(this.quoteIdentifier(includeAs.internalAs)), include.model, topLevelInfo.options);\n\n          if (targetWhere) {\n            joinCondition += \" AND \".concat(targetWhere);\n          }\n        }\n      }\n\n      this._generateSubQueryFilter(include, includeAs, topLevelInfo);\n\n      return {\n        join: joinType,\n        body: joinBody,\n        condition: joinCondition,\n        attributes: attributes\n      };\n    }\n    /*\n     * Generates subQueryFilter - a select nested in the where clause of the subQuery.\n     * For a given include a query is generated that contains all the way from the subQuery\n     * table to the include table plus everything that's in required transitive closure of the\n     * given include.\n     */\n\n  }, {\n    key: \"_generateSubQueryFilter\",\n    value: function _generateSubQueryFilter(include, includeAs, topLevelInfo) {\n      if (!topLevelInfo.subQuery || !include.subQueryFilter) {\n        return;\n      }\n\n      if (!topLevelInfo.options.where) {\n        topLevelInfo.options.where = {};\n      }\n\n      var parent = include;\n      var child = include;\n\n      var nestedIncludes = this._getRequiredClosure(include).include;\n\n      var query;\n\n      while (parent = parent.parent) {\n        // eslint-disable-line\n        if (parent.parent && !parent.required) {\n          return; // only generate subQueryFilter if all the parents of this include are required\n        }\n\n        if (parent.subQueryFilter) {\n          // the include is already handled as this parent has the include on its required closure\n          // skip to prevent duplicate subQueryFilter\n          return;\n        }\n\n        nestedIncludes = [Object.assign({}, child, {\n          include: nestedIncludes,\n          attributes: []\n        })];\n        child = parent;\n      }\n\n      var topInclude = nestedIncludes[0];\n      var topParent = topInclude.parent;\n      var topAssociation = topInclude.association;\n      topInclude.association = undefined;\n\n      if (topInclude.through && Object(topInclude.through.model) === topInclude.through.model) {\n        query = this.selectQuery(topInclude.through.model.getTableName(), {\n          attributes: [topInclude.through.model.primaryKeyField],\n          include: Model._validateIncludedElements({\n            model: topInclude.through.model,\n            include: [{\n              association: topAssociation.toTarget,\n              required: true,\n              where: topInclude.where,\n              include: topInclude.include\n            }]\n          }).include,\n          model: topInclude.through.model,\n          where: _defineProperty({}, Op.and, [this.sequelize.literal([\"\".concat(this.quoteTable(topParent.model.name), \".\").concat(this.quoteIdentifier(topParent.model.primaryKeyField)), \"\".concat(this.quoteIdentifier(topInclude.through.model.name), \".\").concat(this.quoteIdentifier(topAssociation.identifierField))].join(' = ')), topInclude.through.where]),\n          limit: 1,\n          includeIgnoreAttributes: false\n        }, topInclude.through.model);\n      } else {\n        var isBelongsTo = topAssociation.associationType === 'BelongsTo';\n        var sourceField = isBelongsTo ? topAssociation.identifierField : topAssociation.sourceKeyField || topParent.model.primaryKeyField;\n        var targetField = isBelongsTo ? topAssociation.sourceKeyField || topInclude.model.primaryKeyField : topAssociation.identifierField;\n        var join = [\"\".concat(this.quoteIdentifier(topInclude.as), \".\").concat(this.quoteIdentifier(targetField)), \"\".concat(this.quoteTable(topParent.as || topParent.model.name), \".\").concat(this.quoteIdentifier(sourceField))].join(' = ');\n        query = this.selectQuery(topInclude.model.getTableName(), {\n          attributes: [targetField],\n          include: Model._validateIncludedElements(topInclude).include,\n          model: topInclude.model,\n          where: _defineProperty({}, Op.and, [topInclude.where, _defineProperty({}, Op.join, this.sequelize.literal(join))]),\n          limit: 1,\n          tableAs: topInclude.as,\n          includeIgnoreAttributes: false\n        }, topInclude.model);\n      }\n\n      if (!topLevelInfo.options.where[Op.and]) {\n        topLevelInfo.options.where[Op.and] = [];\n      }\n\n      topLevelInfo.options.where[\"__\".concat(includeAs.internalAs)] = this.sequelize.literal(['(', query.replace(/;$/, ''), ')', 'IS NOT NULL'].join(' '));\n    }\n    /*\n     * For a given include hierarchy creates a copy of it where only the required includes\n     * are preserved.\n     */\n\n  }, {\n    key: \"_getRequiredClosure\",\n    value: function _getRequiredClosure(include) {\n      var _this10 = this;\n\n      var copy = Object.assign({}, include, {\n        attributes: [],\n        include: []\n      });\n\n      if (Array.isArray(include.include)) {\n        copy.include = include.include.filter(function (i) {\n          return i.required;\n        }).map(function (inc) {\n          return _this10._getRequiredClosure(inc);\n        });\n      }\n\n      return copy;\n    }\n  }, {\n    key: \"getQueryOrders\",\n    value: function getQueryOrders(options, model, subQuery) {\n      var _this11 = this;\n\n      var mainQueryOrder = [];\n      var subQueryOrder = [];\n\n      if (Array.isArray(options.order)) {\n        var _iterator10 = _createForOfIteratorHelper(options.order),\n            _step10;\n\n        try {\n          var _loop3 = function _loop3() {\n            var order = _step10.value;\n\n            // wrap if not array\n            if (!Array.isArray(order)) {\n              order = [order];\n            }\n\n            if (subQuery && Array.isArray(order) && order[0] && !(order[0] instanceof Association) && !(typeof order[0] === 'function' && order[0].prototype instanceof Model) && !(typeof order[0].model === 'function' && order[0].model.prototype instanceof Model) && !(typeof order[0] === 'string' && model && model.associations !== undefined && model.associations[order[0]])) {\n              subQueryOrder.push(_this11.quote(order, model, '->'));\n            }\n\n            if (subQuery) {\n              // Handle case where sub-query renames attribute we want to order by,\n              // see https://github.com/sequelize/sequelize/issues/8739\n              var subQueryAttribute = options.attributes.find(function (a) {\n                return Array.isArray(a) && a[0] === order[0] && a[1];\n              });\n\n              if (subQueryAttribute) {\n                var modelName = _this11.quoteIdentifier(model.name);\n\n                order[0] = new Utils.Col(_this11._getAliasForField(modelName, subQueryAttribute[1], options) || subQueryAttribute[1]);\n              }\n            }\n\n            mainQueryOrder.push(_this11.quote(order, model, '->'));\n          };\n\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            _loop3();\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n      } else if (options.order instanceof Utils.SequelizeMethod) {\n        var sql = this.quote(options.order, model, '->');\n\n        if (subQuery) {\n          subQueryOrder.push(sql);\n        }\n\n        mainQueryOrder.push(sql);\n      } else {\n        throw new Error('Order must be type of array or instance of a valid sequelize method.');\n      }\n\n      return {\n        mainQueryOrder: mainQueryOrder,\n        subQueryOrder: subQueryOrder\n      };\n    }\n  }, {\n    key: \"selectFromTableFragment\",\n    value: function selectFromTableFragment(options, model, attributes, tables, mainTableAs) {\n      var _this12 = this;\n\n      var fragment = \"SELECT \".concat(attributes.join(', '), \" FROM \").concat(tables);\n\n      if (mainTableAs) {\n        fragment += \" AS \".concat(mainTableAs);\n      }\n\n      if (options.indexHints && this._dialect.supports.indexHints) {\n        var _iterator11 = _createForOfIteratorHelper(options.indexHints),\n            _step11;\n\n        try {\n          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n            var hint = _step11.value;\n\n            if (IndexHints[hint.type]) {\n              fragment += \" \".concat(IndexHints[hint.type], \" INDEX (\").concat(hint.values.map(function (indexName) {\n                return _this12.quoteIdentifiers(indexName);\n              }).join(','), \")\");\n            }\n          }\n        } catch (err) {\n          _iterator11.e(err);\n        } finally {\n          _iterator11.f();\n        }\n      }\n\n      return fragment;\n    }\n    /**\n     * Returns an SQL fragment for adding result constraints.\n     *\n     * @param  {Object} options An object with selectQuery options.\n     * @returns {string}         The generated sql query.\n     * @private\n     */\n\n  }, {\n    key: \"addLimitAndOffset\",\n    value: function addLimitAndOffset(options) {\n      var fragment = '';\n      /* eslint-disable */\n\n      if (options.offset != null && options.limit == null) {\n        fragment += ' LIMIT ' + this.escape(options.offset) + ', ' + 10000000000000;\n      } else if (options.limit != null) {\n        if (options.offset != null) {\n          fragment += ' LIMIT ' + this.escape(options.offset) + ', ' + this.escape(options.limit);\n        } else {\n          fragment += ' LIMIT ' + this.escape(options.limit);\n        }\n      }\n      /* eslint-enable */\n\n\n      return fragment;\n    }\n  }, {\n    key: \"handleSequelizeMethod\",\n    value: function handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n      var _this13 = this;\n\n      var result;\n\n      if (Object.prototype.hasOwnProperty.call(this.OperatorMap, smth.comparator)) {\n        smth.comparator = this.OperatorMap[smth.comparator];\n      }\n\n      if (smth instanceof Utils.Where) {\n        var value = smth.logic;\n        var key;\n\n        if (smth.attribute instanceof Utils.SequelizeMethod) {\n          key = this.getWhereConditions(smth.attribute, tableName, factory, options, prepend);\n        } else {\n          key = \"\".concat(this.quoteTable(smth.attribute.Model.name), \".\").concat(this.quoteIdentifier(smth.attribute.field || smth.attribute.fieldName));\n        }\n\n        if (value && value instanceof Utils.SequelizeMethod) {\n          value = this.getWhereConditions(value, tableName, factory, options, prepend);\n\n          if (value === 'NULL') {\n            if (smth.comparator === '=') {\n              smth.comparator = 'IS';\n            }\n\n            if (smth.comparator === '!=') {\n              smth.comparator = 'IS NOT';\n            }\n          }\n\n          return [key, value].join(\" \".concat(smth.comparator, \" \"));\n        }\n\n        if (_.isPlainObject(value)) {\n          return this.whereItemQuery(smth.attribute, value, {\n            model: factory\n          });\n        }\n\n        if (typeof value === 'boolean') {\n          value = this.booleanValue(value);\n        } else {\n          value = this.escape(value);\n        }\n\n        if (value === 'NULL') {\n          if (smth.comparator === '=') {\n            smth.comparator = 'IS';\n          }\n\n          if (smth.comparator === '!=') {\n            smth.comparator = 'IS NOT';\n          }\n        }\n\n        return [key, value].join(\" \".concat(smth.comparator, \" \"));\n      }\n\n      if (smth instanceof Utils.Literal) {\n        return smth.val;\n      }\n\n      if (smth instanceof Utils.Cast) {\n        if (smth.val instanceof Utils.SequelizeMethod) {\n          result = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);\n        } else if (_.isPlainObject(smth.val)) {\n          result = this.whereItemsQuery(smth.val);\n        } else {\n          result = this.escape(smth.val);\n        }\n\n        return \"CAST(\".concat(result, \" AS \").concat(smth.type.toUpperCase(), \")\");\n      }\n\n      if (smth instanceof Utils.Fn) {\n        return \"\".concat(smth.fn, \"(\").concat(smth.args.map(function (arg) {\n          if (arg instanceof Utils.SequelizeMethod) {\n            return _this13.handleSequelizeMethod(arg, tableName, factory, options, prepend);\n          }\n\n          if (_.isPlainObject(arg)) {\n            return _this13.whereItemsQuery(arg);\n          }\n\n          return _this13.escape(arg);\n        }).join(', '), \")\");\n      }\n\n      if (smth instanceof Utils.Col) {\n        if (Array.isArray(smth.col) && !factory) {\n          throw new Error('Cannot call Sequelize.col() with array outside of order / group clause');\n        }\n\n        if (smth.col.startsWith('*')) {\n          return '*';\n        }\n\n        return this.quote(smth.col, factory);\n      }\n\n      return smth.toString(this, factory);\n    }\n  }, {\n    key: \"whereQuery\",\n    value: function whereQuery(where, options) {\n      var query = this.whereItemsQuery(where, options);\n\n      if (query && query.length) {\n        return \"WHERE \".concat(query);\n      }\n\n      return '';\n    }\n  }, {\n    key: \"whereItemsQuery\",\n    value: function whereItemsQuery(where, options, binding) {\n      var _this14 = this;\n\n      if (where === null || where === undefined || Utils.getComplexSize(where) === 0) {\n        // NO OP\n        return '';\n      }\n\n      if (typeof where === 'string') {\n        throw new Error('Support for `{where: \\'raw query\\'}` has been removed.');\n      }\n\n      var items = [];\n      binding = binding || 'AND';\n      if (binding[0] !== ' ') binding = \" \".concat(binding, \" \");\n\n      if (_.isPlainObject(where)) {\n        Utils.getComplexKeys(where).forEach(function (prop) {\n          var item = where[prop];\n          items.push(_this14.whereItemQuery(prop, item, options));\n        });\n      } else {\n        items.push(this.whereItemQuery(undefined, where, options));\n      }\n\n      return items.length && items.filter(function (item) {\n        return item && item.length;\n      }).join(binding) || '';\n    }\n  }, {\n    key: \"whereItemQuery\",\n    value: function whereItemQuery(key, value) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (value === undefined) {\n        throw new Error(\"WHERE parameter \\\"\".concat(key, \"\\\" has invalid \\\"undefined\\\" value\"));\n      }\n\n      if (typeof key === 'string' && key.includes('.') && options.model) {\n        var keyParts = key.split('.');\n\n        if (options.model.rawAttributes[keyParts[0]] && options.model.rawAttributes[keyParts[0]].type instanceof DataTypes.JSON) {\n          var tmp = {};\n          var _field = options.model.rawAttributes[keyParts[0]];\n\n          _.set(tmp, keyParts.slice(1), value);\n\n          return this.whereItemQuery(_field.field || keyParts[0], tmp, Object.assign({\n            field: _field\n          }, options));\n        }\n      }\n\n      var field = this._findField(key, options);\n\n      var fieldType = field && field.type || options.type;\n\n      var isPlainObject = _.isPlainObject(value);\n\n      var isArray = !isPlainObject && Array.isArray(value);\n      key = this.OperatorsAliasMap && this.OperatorsAliasMap[key] || key;\n\n      if (isPlainObject) {\n        value = this._replaceAliases(value);\n      }\n\n      var valueKeys = isPlainObject && Utils.getComplexKeys(value);\n\n      if (key === undefined) {\n        if (typeof value === 'string') {\n          return value;\n        }\n\n        if (isPlainObject && valueKeys.length === 1) {\n          return this.whereItemQuery(valueKeys[0], value[valueKeys[0]], options);\n        }\n      }\n\n      if (value === null) {\n        var _opValue = options.bindParam ? 'NULL' : this.escape(value, field);\n\n        return this._joinKeyValue(key, _opValue, this.OperatorMap[Op.is], options.prefix);\n      }\n\n      if (!value) {\n        var _opValue2 = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n\n        return this._joinKeyValue(key, _opValue2, this.OperatorMap[Op.eq], options.prefix);\n      }\n\n      if (value instanceof Utils.SequelizeMethod && !(key !== undefined && value instanceof Utils.Fn)) {\n        return this.handleSequelizeMethod(value);\n      } // Convert where: [] to Op.and if possible, else treat as literal/replacements\n\n\n      if (key === undefined && isArray) {\n        if (Utils.canTreatArrayAsAnd(value)) {\n          key = Op.and;\n        } else {\n          throw new Error('Support for literal replacements in the `where` object has been removed.');\n        }\n      }\n\n      if (key === Op.or || key === Op.and || key === Op.not) {\n        return this._whereGroupBind(key, value, options);\n      }\n\n      if (value[Op.or]) {\n        return this._whereBind(this.OperatorMap[Op.or], key, value[Op.or], options);\n      }\n\n      if (value[Op.and]) {\n        return this._whereBind(this.OperatorMap[Op.and], key, value[Op.and], options);\n      }\n\n      if (isArray && fieldType instanceof DataTypes.ARRAY) {\n        var _opValue3 = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n\n        return this._joinKeyValue(key, _opValue3, this.OperatorMap[Op.eq], options.prefix);\n      }\n\n      if (isPlainObject && fieldType instanceof DataTypes.JSON && options.json !== false) {\n        return this._whereJSON(key, value, options);\n      } // If multiple keys we combine the different logic conditions\n\n\n      if (isPlainObject && valueKeys.length > 1) {\n        return this._whereBind(this.OperatorMap[Op.and], key, value, options);\n      }\n\n      if (isArray) {\n        return this._whereParseSingleValueObject(key, field, Op.in, value, options);\n      }\n\n      if (isPlainObject) {\n        if (this.OperatorMap[valueKeys[0]]) {\n          return this._whereParseSingleValueObject(key, field, valueKeys[0], value[valueKeys[0]], options);\n        }\n\n        return this._whereParseSingleValueObject(key, field, this.OperatorMap[Op.eq], value, options);\n      }\n\n      if (key === Op.placeholder) {\n        var _opValue4 = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n\n        return this._joinKeyValue(this.OperatorMap[key], _opValue4, this.OperatorMap[Op.eq], options.prefix);\n      }\n\n      var opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);\n    }\n  }, {\n    key: \"_findField\",\n    value: function _findField(key, options) {\n      if (options.field) {\n        return options.field;\n      }\n\n      if (options.model && options.model.rawAttributes && options.model.rawAttributes[key]) {\n        return options.model.rawAttributes[key];\n      }\n\n      if (options.model && options.model.fieldRawAttributesMap && options.model.fieldRawAttributesMap[key]) {\n        return options.model.fieldRawAttributesMap[key];\n      }\n    } // OR/AND/NOT grouping logic\n\n  }, {\n    key: \"_whereGroupBind\",\n    value: function _whereGroupBind(key, value, options) {\n      var _this15 = this;\n\n      var binding = key === Op.or ? this.OperatorMap[Op.or] : this.OperatorMap[Op.and];\n      var outerBinding = key === Op.not ? 'NOT ' : '';\n\n      if (Array.isArray(value)) {\n        value = value.map(function (item) {\n          var itemQuery = _this15.whereItemsQuery(item, options, _this15.OperatorMap[Op.and]);\n\n          if (itemQuery && itemQuery.length && (Array.isArray(item) || _.isPlainObject(item)) && Utils.getComplexSize(item) > 1) {\n            itemQuery = \"(\".concat(itemQuery, \")\");\n          }\n\n          return itemQuery;\n        }).filter(function (item) {\n          return item && item.length;\n        });\n        value = value.length && value.join(binding);\n      } else {\n        value = this.whereItemsQuery(value, options, binding);\n      } // Op.or: [] should return no data.\n      // Op.not of no restriction should also return no data\n\n\n      if ((key === Op.or || key === Op.not) && !value) {\n        return '0 = 1';\n      }\n\n      return value ? \"\".concat(outerBinding, \"(\").concat(value, \")\") : undefined;\n    }\n  }, {\n    key: \"_whereBind\",\n    value: function _whereBind(binding, key, value, options) {\n      var _this16 = this;\n\n      if (_.isPlainObject(value)) {\n        value = Utils.getComplexKeys(value).map(function (prop) {\n          var item = value[prop];\n          return _this16.whereItemQuery(key, _defineProperty({}, prop, item), options);\n        });\n      } else {\n        value = value.map(function (item) {\n          return _this16.whereItemQuery(key, item, options);\n        });\n      }\n\n      value = value.filter(function (item) {\n        return item && item.length;\n      });\n      return value.length ? \"(\".concat(value.join(binding), \")\") : undefined;\n    }\n  }, {\n    key: \"_whereJSON\",\n    value: function _whereJSON(key, value, options) {\n      var _this17 = this;\n\n      var items = [];\n      var baseKey = this.quoteIdentifier(key);\n\n      if (options.prefix) {\n        if (options.prefix instanceof Utils.Literal) {\n          baseKey = \"\".concat(this.handleSequelizeMethod(options.prefix), \".\").concat(baseKey);\n        } else {\n          baseKey = \"\".concat(this.quoteTable(options.prefix), \".\").concat(baseKey);\n        }\n      }\n\n      Utils.getOperators(value).forEach(function (op) {\n        var where = _defineProperty({}, op, value[op]);\n\n        items.push(_this17.whereItemQuery(key, where, Object.assign({}, options, {\n          json: false\n        })));\n      });\n\n      _.forOwn(value, function (item, prop) {\n        _this17._traverseJSON(items, baseKey, prop, item, [prop]);\n      });\n\n      var result = items.join(this.OperatorMap[Op.and]);\n      return items.length > 1 ? \"(\".concat(result, \")\") : result;\n    }\n  }, {\n    key: \"_traverseJSON\",\n    value: function _traverseJSON(items, baseKey, prop, item, path) {\n      var _this18 = this;\n\n      var cast;\n\n      if (path[path.length - 1].includes('::')) {\n        var tmp = path[path.length - 1].split('::');\n        cast = tmp[1];\n        path[path.length - 1] = tmp[0];\n      }\n\n      var pathKey = this.jsonPathExtractionQuery(baseKey, path);\n\n      if (_.isPlainObject(item)) {\n        Utils.getOperators(item).forEach(function (op) {\n          var value = _this18._toJSONValue(item[op]);\n\n          items.push(_this18.whereItemQuery(_this18._castKey(pathKey, value, cast), _defineProperty({}, op, value)));\n        });\n\n        _.forOwn(item, function (value, itemProp) {\n          _this18._traverseJSON(items, baseKey, itemProp, value, path.concat([itemProp]));\n        });\n\n        return;\n      }\n\n      item = this._toJSONValue(item);\n      items.push(this.whereItemQuery(this._castKey(pathKey, item, cast), _defineProperty({}, Op.eq, item)));\n    }\n  }, {\n    key: \"_toJSONValue\",\n    value: function _toJSONValue(value) {\n      return value;\n    }\n  }, {\n    key: \"_castKey\",\n    value: function _castKey(key, value, cast, json) {\n      cast = cast || this._getJsonCast(Array.isArray(value) ? value[0] : value);\n\n      if (cast) {\n        return new Utils.Literal(this.handleSequelizeMethod(new Utils.Cast(new Utils.Literal(key), cast, json)));\n      }\n\n      return new Utils.Literal(key);\n    }\n  }, {\n    key: \"_getJsonCast\",\n    value: function _getJsonCast(value) {\n      if (typeof value === 'number') {\n        return 'double precision';\n      }\n\n      if (value instanceof Date) {\n        return 'timestamptz';\n      }\n\n      if (typeof value === 'boolean') {\n        return 'boolean';\n      }\n\n      return;\n    }\n  }, {\n    key: \"_joinKeyValue\",\n    value: function _joinKeyValue(key, value, comparator, prefix) {\n      if (!key) {\n        return value;\n      }\n\n      if (comparator === undefined) {\n        throw new Error(\"\".concat(key, \" and \").concat(value, \" has no comparator\"));\n      }\n\n      key = this._getSafeKey(key, prefix);\n      return [key, value].join(\" \".concat(comparator, \" \"));\n    }\n  }, {\n    key: \"_getSafeKey\",\n    value: function _getSafeKey(key, prefix) {\n      var _this19 = this;\n\n      if (key instanceof Utils.SequelizeMethod) {\n        key = this.handleSequelizeMethod(key);\n        return this._prefixKey(this.handleSequelizeMethod(key), prefix);\n      }\n\n      if (Utils.isColString(key)) {\n        key = key.substr(1, key.length - 2).split('.');\n\n        if (key.length > 2) {\n          key = [// join the tables by -> to match out internal namings\n          key.slice(0, -1).join('->'), key[key.length - 1]];\n        }\n\n        return key.map(function (identifier) {\n          return _this19.quoteIdentifier(identifier);\n        }).join('.');\n      }\n\n      return this._prefixKey(this.quoteIdentifier(key), prefix);\n    }\n  }, {\n    key: \"_prefixKey\",\n    value: function _prefixKey(key, prefix) {\n      if (prefix) {\n        if (prefix instanceof Utils.Literal) {\n          return [this.handleSequelizeMethod(prefix), key].join('.');\n        }\n\n        return [this.quoteTable(prefix), key].join('.');\n      }\n\n      return key;\n    }\n  }, {\n    key: \"_whereParseSingleValueObject\",\n    value: function _whereParseSingleValueObject(key, field, prop, value, options) {\n      var _this20 = this;\n\n      if (prop === Op.not) {\n        if (Array.isArray(value)) {\n          prop = Op.notIn;\n        } else if (value !== null && value !== true && value !== false) {\n          prop = Op.ne;\n        }\n      }\n\n      var comparator = this.OperatorMap[prop] || this.OperatorMap[Op.eq];\n\n      switch (prop) {\n        case Op.in:\n        case Op.notIn:\n          if (value instanceof Utils.Literal) {\n            return this._joinKeyValue(key, value.val, comparator, options.prefix);\n          }\n\n          if (value.length) {\n            return this._joinKeyValue(key, \"(\".concat(value.map(function (item) {\n              return _this20.escape(item, field);\n            }).join(', '), \")\"), comparator, options.prefix);\n          }\n\n          if (comparator === this.OperatorMap[Op.in]) {\n            return this._joinKeyValue(key, '(NULL)', comparator, options.prefix);\n          }\n\n          return '';\n\n        case Op.any:\n        case Op.all:\n          comparator = \"\".concat(this.OperatorMap[Op.eq], \" \").concat(comparator);\n\n          if (value[Op.values]) {\n            return this._joinKeyValue(key, \"(VALUES \".concat(value[Op.values].map(function (item) {\n              return \"(\".concat(_this20.escape(item), \")\");\n            }).join(', '), \")\"), comparator, options.prefix);\n          }\n\n          return this._joinKeyValue(key, \"(\".concat(this.escape(value, field), \")\"), comparator, options.prefix);\n\n        case Op.between:\n        case Op.notBetween:\n          return this._joinKeyValue(key, \"\".concat(this.escape(value[0], field), \" AND \").concat(this.escape(value[1], field)), comparator, options.prefix);\n\n        case Op.raw:\n          throw new Error('The `$raw` where property is no longer supported.  Use `sequelize.literal` instead.');\n\n        case Op.col:\n          comparator = this.OperatorMap[Op.eq];\n          value = value.split('.');\n\n          if (value.length > 2) {\n            value = [// join the tables by -> to match out internal namings\n            value.slice(0, -1).join('->'), value[value.length - 1]];\n          }\n\n          return this._joinKeyValue(key, value.map(function (identifier) {\n            return _this20.quoteIdentifier(identifier);\n          }).join('.'), comparator, options.prefix);\n\n        case Op.startsWith:\n          comparator = this.OperatorMap[Op.like];\n          return this._joinKeyValue(key, this.escape(\"\".concat(value, \"%\")), comparator, options.prefix);\n\n        case Op.endsWith:\n          comparator = this.OperatorMap[Op.like];\n          return this._joinKeyValue(key, this.escape(\"%\".concat(value)), comparator, options.prefix);\n\n        case Op.substring:\n          comparator = this.OperatorMap[Op.like];\n          return this._joinKeyValue(key, this.escape(\"%\".concat(value, \"%\")), comparator, options.prefix);\n      }\n\n      var escapeOptions = {\n        acceptStrings: comparator.includes(this.OperatorMap[Op.like])\n      };\n\n      if (_.isPlainObject(value)) {\n        if (value[Op.col]) {\n          return this._joinKeyValue(key, this.whereItemQuery(null, value), comparator, options.prefix);\n        }\n\n        if (value[Op.any]) {\n          escapeOptions.isList = true;\n          return this._joinKeyValue(key, \"(\".concat(this.escape(value[Op.any], field, escapeOptions), \")\"), \"\".concat(comparator, \" \").concat(this.OperatorMap[Op.any]), options.prefix);\n        }\n\n        if (value[Op.all]) {\n          escapeOptions.isList = true;\n          return this._joinKeyValue(key, \"(\".concat(this.escape(value[Op.all], field, escapeOptions), \")\"), \"\".concat(comparator, \" \").concat(this.OperatorMap[Op.all]), options.prefix);\n        }\n      }\n\n      if (value === null && comparator === this.OperatorMap[Op.eq]) {\n        return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.is], options.prefix);\n      }\n\n      if (value === null && comparator === this.OperatorMap[Op.ne]) {\n        return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.not], options.prefix);\n      }\n\n      return this._joinKeyValue(key, this.escape(value, field, escapeOptions), comparator, options.prefix);\n    }\n    /*\n      Takes something and transforms it into values of a where condition.\n     @private\n    */\n\n  }, {\n    key: \"getWhereConditions\",\n    value: function getWhereConditions(smth, tableName, factory, options, prepend) {\n      var where = {};\n\n      if (Array.isArray(tableName)) {\n        tableName = tableName[0];\n\n        if (Array.isArray(tableName)) {\n          tableName = tableName[1];\n        }\n      }\n\n      options = options || {};\n\n      if (prepend === undefined) {\n        prepend = true;\n      }\n\n      if (smth && smth instanceof Utils.SequelizeMethod) {\n        // Checking a property is cheaper than a lot of instanceof calls\n        return this.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n      }\n\n      if (_.isPlainObject(smth)) {\n        return this.whereItemsQuery(smth, {\n          model: factory,\n          prefix: prepend && tableName,\n          type: options.type\n        });\n      }\n\n      if (typeof smth === 'number') {\n        var primaryKeys = factory ? Object.keys(factory.primaryKeys) : [];\n\n        if (primaryKeys.length > 0) {\n          // Since we're just a number, assume only the first key\n          primaryKeys = primaryKeys[0];\n        } else {\n          primaryKeys = 'id';\n        }\n\n        where[primaryKeys] = smth;\n        return this.whereItemsQuery(where, {\n          model: factory,\n          prefix: prepend && tableName\n        });\n      }\n\n      if (typeof smth === 'string') {\n        return this.whereItemsQuery(smth, {\n          model: factory,\n          prefix: prepend && tableName\n        });\n      }\n\n      if (Buffer.isBuffer(smth)) {\n        return this.escape(smth);\n      }\n\n      if (Array.isArray(smth)) {\n        if (smth.length === 0 || smth.length > 0 && smth[0].length === 0) return '1=1';\n\n        if (Utils.canTreatArrayAsAnd(smth)) {\n          var _smth = _defineProperty({}, Op.and, smth);\n\n          return this.getWhereConditions(_smth, tableName, factory, options, prepend);\n        }\n\n        throw new Error('Support for literal replacements in the `where` object has been removed.');\n      }\n\n      if (smth === null) {\n        return this.whereItemsQuery(smth, {\n          model: factory,\n          prefix: prepend && tableName\n        });\n      }\n\n      return '1=1';\n    } // A recursive parser for nested where conditions\n\n  }, {\n    key: \"parseConditionObject\",\n    value: function parseConditionObject(conditions, path) {\n      var _this21 = this;\n\n      path = path || [];\n      return _.reduce(conditions, function (result, value, key) {\n        if (_.isObject(value)) {\n          return result.concat(_this21.parseConditionObject(value, path.concat(key))); // Recursively parse objects\n        }\n\n        result.push({\n          path: path.concat(key),\n          value: value\n        });\n        return result;\n      }, []);\n    }\n  }, {\n    key: \"booleanValue\",\n    value: function booleanValue(value) {\n      return value;\n    }\n  }]);\n\n  return QueryGenerator;\n}();\n\nObject.assign(QueryGenerator.prototype, require('./query-generator/operators'));\nObject.assign(QueryGenerator.prototype, require('./query-generator/transaction'));\nmodule.exports = QueryGenerator;","map":null,"metadata":{},"sourceType":"script"}