{"ast":null,"code":"'use strict';\n\nvar _possibleConstructorReturn = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar core = require('./index.js');\n\nvar EventEmitter = require('events').EventEmitter;\n\nfunction makeDoneCb(resolve, reject, localErr) {\n  return function (err, rows, fields) {\n    if (err) {\n      localErr.message = err.message;\n      localErr.code = err.code;\n      localErr.errno = err.errno;\n      localErr.sqlState = err.sqlState;\n      localErr.sqlMessage = err.sqlMessage;\n      reject(localErr);\n    } else {\n      resolve([rows, fields]);\n    }\n  };\n}\n\nfunction inheritEvents(source, target, events) {\n  var listeners = {};\n  target.on('newListener', function (eventName) {\n    if (events.indexOf(eventName) >= 0 && !target.listenerCount(eventName)) {\n      source.on(eventName, listeners[eventName] = function () {\n        var args = [].slice.call(arguments);\n        args.unshift(eventName);\n        target.emit.apply(target, args);\n      });\n    }\n  }).on('removeListener', function (eventName) {\n    if (events.indexOf(eventName) >= 0 && !target.listenerCount(eventName)) {\n      source.removeListener(eventName, listeners[eventName]);\n      delete listeners[eventName];\n    }\n  });\n}\n\nvar PromisePreparedStatementInfo = /*#__PURE__*/function () {\n  function PromisePreparedStatementInfo(statement, promiseImpl) {\n    _classCallCheck(this, PromisePreparedStatementInfo);\n\n    this.statement = statement;\n    this.Promise = promiseImpl;\n  }\n\n  _createClass(PromisePreparedStatementInfo, [{\n    key: \"execute\",\n    value: function execute(parameters) {\n      var s = this.statement;\n      var localErr = new Error();\n      return new this.Promise(function (resolve, reject) {\n        var done = makeDoneCb(resolve, reject, localErr);\n\n        if (parameters) {\n          s.execute(parameters, done);\n        } else {\n          s.execute(done);\n        }\n      });\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      var _this = this;\n\n      return new this.Promise(function (resolve) {\n        _this.statement.close();\n\n        resolve();\n      });\n    }\n  }]);\n\n  return PromisePreparedStatementInfo;\n}();\n\nvar PromiseConnection = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(PromiseConnection, _EventEmitter);\n\n  function PromiseConnection(connection, promiseImpl) {\n    var _this2;\n\n    _classCallCheck(this, PromiseConnection);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(PromiseConnection).call(this));\n    _this2.connection = connection;\n    _this2.Promise = promiseImpl || global.Promise;\n    inheritEvents(connection, _assertThisInitialized(_assertThisInitialized(_this2)), ['error', 'drain', 'connect', 'end', 'enqueue']);\n    return _this2;\n  }\n\n  _createClass(PromiseConnection, [{\n    key: \"release\",\n    value: function release() {\n      this.connection.release();\n    }\n  }, {\n    key: \"query\",\n    value: function query(_query, params) {\n      var c = this.connection;\n      var localErr = new Error();\n      return new this.Promise(function (resolve, reject) {\n        var done = makeDoneCb(resolve, reject, localErr);\n\n        if (params) {\n          c.query(_query, params, done);\n        } else {\n          c.query(_query, done);\n        }\n      });\n    }\n  }, {\n    key: \"execute\",\n    value: function execute(query, params) {\n      var c = this.connection;\n      var localErr = new Error();\n      return new this.Promise(function (resolve, reject) {\n        var done = makeDoneCb(resolve, reject, localErr);\n\n        if (params) {\n          c.execute(query, params, done);\n        } else {\n          c.execute(query, done);\n        }\n      });\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      var _this3 = this;\n\n      return new this.Promise(function (resolve) {\n        _this3.connection.end(resolve);\n      });\n    }\n  }, {\n    key: \"beginTransaction\",\n    value: function beginTransaction() {\n      var c = this.connection;\n      var localErr = new Error();\n      return new this.Promise(function (resolve, reject) {\n        var done = makeDoneCb(resolve, reject, localErr);\n        c.beginTransaction(done);\n      });\n    }\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      var c = this.connection;\n      var localErr = new Error();\n      return new this.Promise(function (resolve, reject) {\n        var done = makeDoneCb(resolve, reject, localErr);\n        c.commit(done);\n      });\n    }\n  }, {\n    key: \"rollback\",\n    value: function rollback() {\n      var c = this.connection;\n      var localErr = new Error();\n      return new this.Promise(function (resolve, reject) {\n        var done = makeDoneCb(resolve, reject, localErr);\n        c.rollback(done);\n      });\n    }\n  }, {\n    key: \"ping\",\n    value: function ping() {\n      var c = this.connection;\n      var localErr = new Error();\n      return new this.Promise(function (resolve, reject) {\n        var done = makeDoneCb(resolve, reject, localErr);\n        c.ping(done);\n      });\n    }\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      var c = this.connection;\n      var localErr = new Error();\n      return new this.Promise(function (resolve, reject) {\n        c.connect(function (err, param) {\n          if (err) {\n            localErr.message = err.message;\n            localErr.code = err.code;\n            localErr.errno = err.errno;\n            localErr.sqlState = err.sqlState;\n            localErr.sqlMessage = err.sqlMessage;\n            reject(localErr);\n          } else {\n            resolve(param);\n          }\n        });\n      });\n    }\n  }, {\n    key: \"prepare\",\n    value: function prepare(options) {\n      var c = this.connection;\n      var promiseImpl = this.Promise;\n      var localErr = new Error();\n      return new this.Promise(function (resolve, reject) {\n        c.prepare(options, function (err, statement) {\n          if (err) {\n            localErr.message = err.message;\n            localErr.code = err.code;\n            localErr.errno = err.errno;\n            localErr.sqlState = err.sqlState;\n            localErr.sqlMessage = err.sqlMessage;\n            reject(localErr);\n          } else {\n            var wrappedStatement = new PromisePreparedStatementInfo(statement, promiseImpl);\n            resolve(wrappedStatement);\n          }\n        });\n      });\n    }\n  }, {\n    key: \"changeUser\",\n    value: function changeUser(options) {\n      var c = this.connection;\n      var localErr = new Error();\n      return new this.Promise(function (resolve, reject) {\n        c.changeUser(options, function (err) {\n          if (err) {\n            localErr.message = err.message;\n            localErr.code = err.code;\n            localErr.errno = err.errno;\n            localErr.sqlState = err.sqlState;\n            localErr.sqlMessage = err.sqlMessage;\n            reject(localErr);\n          } else {\n            resolve();\n          }\n        });\n      });\n    }\n  }, {\n    key: \"config\",\n    get: function get() {\n      return this.connection.config;\n    }\n  }, {\n    key: \"threadId\",\n    get: function get() {\n      return this.connection.threadId;\n    }\n  }]);\n\n  return PromiseConnection;\n}(EventEmitter);\n\nfunction createConnection(opts) {\n  var coreConnection = core.createConnection(opts);\n  var createConnectionErr = new Error();\n  var Promise = opts.Promise || global.Promise;\n\n  if (!Promise) {\n    throw new Error('no Promise implementation available.' + 'Use promise-enabled node version or pass userland Promise' + \" implementation as parameter, for example: { Promise: require('bluebird') }\");\n  }\n\n  return new Promise(function (resolve, reject) {\n    coreConnection.once('connect', function () {\n      resolve(new PromiseConnection(coreConnection, Promise));\n    });\n    coreConnection.once('error', function (err) {\n      createConnectionErr.message = err.message;\n      createConnectionErr.code = err.code;\n      createConnectionErr.errno = err.errno;\n      createConnectionErr.sqlState = err.sqlState;\n      reject(createConnectionErr);\n    });\n  });\n} // note: the callback of \"changeUser\" is not called on success\n// hence there is no possibility to call \"resolve\"\n// patching PromiseConnection\n// create facade functions for prototype functions on \"Connection\" that are not yet\n// implemented with PromiseConnection\n// proxy synchronous functions only\n\n\n(function (functionsToWrap) {\n  for (var i = 0; functionsToWrap && i < functionsToWrap.length; i++) {\n    var func = functionsToWrap[i];\n\n    if (typeof core.Connection.prototype[func] === 'function' && PromiseConnection.prototype[func] === undefined) {\n      PromiseConnection.prototype[func] = function factory(funcName) {\n        return function () {\n          return core.Connection.prototype[funcName].apply(this.connection, arguments);\n        };\n      }(func);\n    }\n  }\n})([// synchronous functions\n'close', 'createBinlogStream', 'destroy', 'escape', 'escapeId', 'format', 'pause', 'pipe', 'resume', 'unprepare']);\n\nvar PromisePoolConnection = /*#__PURE__*/function (_PromiseConnection) {\n  _inherits(PromisePoolConnection, _PromiseConnection);\n\n  function PromisePoolConnection(connection, promiseImpl) {\n    _classCallCheck(this, PromisePoolConnection);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PromisePoolConnection).call(this, connection, promiseImpl));\n  }\n\n  _createClass(PromisePoolConnection, [{\n    key: \"destroy\",\n    value: function destroy() {\n      return core.PoolConnection.prototype.destroy.apply(this.connection, arguments);\n    }\n  }]);\n\n  return PromisePoolConnection;\n}(PromiseConnection);\n\nvar PromisePool = /*#__PURE__*/function (_EventEmitter2) {\n  _inherits(PromisePool, _EventEmitter2);\n\n  function PromisePool(pool, Promise) {\n    var _this4;\n\n    _classCallCheck(this, PromisePool);\n\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(PromisePool).call(this));\n    _this4.pool = pool;\n    _this4.Promise = Promise || global.Promise;\n    inheritEvents(pool, _assertThisInitialized(_assertThisInitialized(_this4)), ['acquire', 'connection', 'enqueue', 'release']);\n    return _this4;\n  }\n\n  _createClass(PromisePool, [{\n    key: \"getConnection\",\n    value: function getConnection() {\n      var _this5 = this;\n\n      var corePool = this.pool;\n      return new this.Promise(function (resolve, reject) {\n        corePool.getConnection(function (err, coreConnection) {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(new PromisePoolConnection(coreConnection, _this5.Promise));\n          }\n        });\n      });\n    }\n  }, {\n    key: \"query\",\n    value: function query(sql, args) {\n      var corePool = this.pool;\n      var localErr = new Error();\n      return new this.Promise(function (resolve, reject) {\n        var done = makeDoneCb(resolve, reject, localErr);\n\n        if (args) {\n          corePool.query(sql, args, done);\n        } else {\n          corePool.query(sql, done);\n        }\n      });\n    }\n  }, {\n    key: \"execute\",\n    value: function execute(sql, values) {\n      var corePool = this.pool;\n      var localErr = new Error();\n      return new this.Promise(function (resolve, reject) {\n        corePool.execute(sql, values, makeDoneCb(resolve, reject, localErr));\n      });\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      var corePool = this.pool;\n      var localErr = new Error();\n      return new this.Promise(function (resolve, reject) {\n        corePool.end(function (err) {\n          if (err) {\n            localErr.message = err.message;\n            localErr.code = err.code;\n            localErr.errno = err.errno;\n            localErr.sqlState = err.sqlState;\n            localErr.sqlMessage = err.sqlMessage;\n            reject(localErr);\n          } else {\n            resolve();\n          }\n        });\n      });\n    }\n  }]);\n\n  return PromisePool;\n}(EventEmitter);\n\nfunction createPool(opts) {\n  var corePool = core.createPool(opts);\n  var Promise = opts.Promise || global.Promise;\n\n  if (!Promise) {\n    throw new Error('no Promise implementation available.' + 'Use promise-enabled node version or pass userland Promise' + \" implementation as parameter, for example: { Promise: require('bluebird') }\");\n  }\n\n  return new PromisePool(corePool, Promise);\n}\n\n(function (functionsToWrap) {\n  for (var i = 0; functionsToWrap && i < functionsToWrap.length; i++) {\n    var func = functionsToWrap[i];\n\n    if (typeof core.Pool.prototype[func] === 'function' && PromisePool.prototype[func] === undefined) {\n      PromisePool.prototype[func] = function factory(funcName) {\n        return function () {\n          return core.Pool.prototype[funcName].apply(this.pool, arguments);\n        };\n      }(func);\n    }\n  }\n})([// synchronous functions\n'escape', 'escapeId', 'format']);\n\nexports.createConnection = createConnection;\nexports.createPool = createPool;\nexports.escape = core.escape;\nexports.escapeId = core.escapeId;\nexports.format = core.format;\nexports.raw = core.raw;\nexports.PromisePool = PromisePool;\nexports.PromiseConnection = PromiseConnection;\nexports.PromisePoolConnection = PromisePoolConnection;","map":null,"metadata":{},"sourceType":"script"}