{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _asyncToGenerator = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar AbstractQuery = require('../abstract/query');\n\nvar sequelizeErrors = require('../../errors');\n\nvar parserStore = require('../parserStore')('mssql');\n\nvar _ = require('lodash');\n\nvar _require = require('../../utils/logger'),\n    logger = _require.logger;\n\nvar debug = logger.debugContext('sql:mssql');\n\nfunction getScale(aNum) {\n  if (!Number.isFinite(aNum)) return 0;\n  var e = 1;\n\n  while (Math.round(aNum * e) / e !== aNum) {\n    e *= 10;\n  }\n\n  return Math.log10(e);\n}\n\nvar Query = /*#__PURE__*/function (_AbstractQuery) {\n  _inherits(Query, _AbstractQuery);\n\n  function Query() {\n    _classCallCheck(this, Query);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Query).apply(this, arguments));\n  }\n\n  _createClass(Query, [{\n    key: \"getInsertIdField\",\n    value: function getInsertIdField() {\n      return 'id';\n    }\n  }, {\n    key: \"getSQLTypeFromJsType\",\n    value: function getSQLTypeFromJsType(value, TYPES) {\n      var paramType = {\n        type: TYPES.VarChar,\n        typeOptions: {}\n      };\n      paramType.type = TYPES.NVarChar;\n\n      if (typeof value === 'number') {\n        if (Number.isInteger(value)) {\n          if (value >= -2147483648 && value <= 2147483647) {\n            paramType.type = TYPES.Int;\n          } else {\n            paramType.type = TYPES.BigInt;\n          }\n        } else {\n          paramType.type = TYPES.Numeric; //Default to a reasonable numeric precision/scale pending more sophisticated logic\n\n          paramType.typeOptions = {\n            precision: 30,\n            scale: getScale(value)\n          };\n        }\n      } else if (typeof value === 'boolean') {\n        paramType.type = TYPES.Bit;\n      }\n\n      if (Buffer.isBuffer(value)) {\n        paramType.type = TYPES.VarBinary;\n      }\n\n      return paramType;\n    }\n  }, {\n    key: \"_run\",\n    value: function () {\n      var _run2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(connection, sql, parameters) {\n        var _this = this;\n\n        var options, complete, query, rows, rowCount, _yield$query, _yield$query2;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.sql = sql;\n                options = this.options;\n                complete = this._logQuery(sql, debug, parameters);\n                query = new Promise(function (resolve, reject) {\n                  // TRANSACTION SUPPORT\n                  if (sql.startsWith('BEGIN TRANSACTION')) {\n                    return connection.beginTransaction(function (error) {\n                      return error ? reject(error) : resolve([]);\n                    }, options.transaction.name, connection.lib.ISOLATION_LEVEL[options.isolationLevel]);\n                  }\n\n                  if (sql.startsWith('COMMIT TRANSACTION')) {\n                    return connection.commitTransaction(function (error) {\n                      return error ? reject(error) : resolve([]);\n                    });\n                  }\n\n                  if (sql.startsWith('ROLLBACK TRANSACTION')) {\n                    return connection.rollbackTransaction(function (error) {\n                      return error ? reject(error) : resolve([]);\n                    }, options.transaction.name);\n                  }\n\n                  if (sql.startsWith('SAVE TRANSACTION')) {\n                    return connection.saveTransaction(function (error) {\n                      return error ? reject(error) : resolve([]);\n                    }, options.transaction.name);\n                  }\n\n                  var rows = [];\n                  var request = new connection.lib.Request(sql, function (err, rowCount) {\n                    return err ? reject(err) : resolve([rows, rowCount]);\n                  });\n\n                  if (parameters) {\n                    _.forOwn(parameters, function (value, key) {\n                      var paramType = _this.getSQLTypeFromJsType(value, connection.lib.TYPES);\n\n                      request.addParameter(key, paramType.type, value, paramType.typeOptions);\n                    });\n                  }\n\n                  request.on('row', function (columns) {\n                    rows.push(columns);\n                  });\n                  connection.execSql(request);\n                });\n                _context.prev = 4;\n                _context.next = 7;\n                return query;\n\n              case 7:\n                _yield$query = _context.sent;\n                _yield$query2 = _slicedToArray(_yield$query, 2);\n                rows = _yield$query2[0];\n                rowCount = _yield$query2[1];\n                _context.next = 18;\n                break;\n\n              case 13:\n                _context.prev = 13;\n                _context.t0 = _context[\"catch\"](4);\n                _context.t0.sql = sql;\n                _context.t0.parameters = parameters;\n                throw this.formatError(_context.t0);\n\n              case 18:\n                complete();\n\n                if (Array.isArray(rows)) {\n                  rows = rows.map(function (columns) {\n                    var row = {};\n\n                    var _iterator = _createForOfIteratorHelper(columns),\n                        _step;\n\n                    try {\n                      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                        var column = _step.value;\n                        var typeid = column.metadata.type.id;\n                        var parse = parserStore.get(typeid);\n                        var value = column.value;\n\n                        if (value !== null & !!parse) {\n                          value = parse(value);\n                        }\n\n                        row[column.metadata.colName] = value;\n                      }\n                    } catch (err) {\n                      _iterator.e(err);\n                    } finally {\n                      _iterator.f();\n                    }\n\n                    return row;\n                  });\n                }\n\n                return _context.abrupt(\"return\", this.formatResults(rows, rowCount));\n\n              case 21:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[4, 13]]);\n      }));\n\n      function _run(_x, _x2, _x3) {\n        return _run2.apply(this, arguments);\n      }\n\n      return _run;\n    }()\n  }, {\n    key: \"run\",\n    value: function run(sql, parameters) {\n      var _this2 = this;\n\n      return this.connection.queue.enqueue(function () {\n        return _this2._run(_this2.connection, sql, parameters);\n      });\n    }\n  }, {\n    key: \"formatResults\",\n\n    /**\n     * High level function that handles the results of a query execution.\n     *\n     * @param {Array} data - The result of the query execution.\n     * @param {number} rowCount\n     * @private\n     * @example\n     * Example:\n     *  query.formatResults([\n     *    {\n     *      id: 1,              // this is from the main table\n     *      attr2: 'snafu',     // this is from the main table\n     *      Tasks.id: 1,        // this is from the associated table\n     *      Tasks.title: 'task' // this is from the associated table\n     *    }\n     *  ])\n     */\n    value: function formatResults(data, rowCount) {\n      if (this.isInsertQuery(data)) {\n        this.handleInsertQuery(data);\n        return [this.instance || data, rowCount];\n      }\n\n      if (this.isShowTablesQuery()) {\n        return this.handleShowTablesQuery(data);\n      }\n\n      if (this.isDescribeQuery()) {\n        var result = {};\n\n        var _iterator2 = _createForOfIteratorHelper(data),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _result = _step2.value;\n\n            if (_result.Default) {\n              _result.Default = _result.Default.replace(\"('\", '').replace(\"')\", '').replace(/'/g, '');\n            }\n\n            result[_result.Name] = {\n              type: _result.Type.toUpperCase(),\n              allowNull: _result.IsNull === 'YES' ? true : false,\n              defaultValue: _result.Default,\n              primaryKey: _result.Constraint === 'PRIMARY KEY',\n              autoIncrement: _result.IsIdentity === 1,\n              comment: _result.Comment\n            };\n\n            if (result[_result.Name].type.includes('CHAR') && _result.Length) {\n              if (_result.Length === -1) {\n                result[_result.Name].type += '(MAX)';\n              } else {\n                result[_result.Name].type += \"(\".concat(_result.Length, \")\");\n              }\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        return result;\n      }\n\n      if (this.isSelectQuery()) {\n        return this.handleSelectQuery(data);\n      }\n\n      if (this.isShowIndexesQuery()) {\n        return this.handleShowIndexesQuery(data);\n      }\n\n      if (this.isCallQuery()) {\n        return data[0];\n      }\n\n      if (this.isBulkUpdateQuery()) {\n        if (this.options.returning) {\n          return this.handleSelectQuery(data);\n        }\n\n        return rowCount;\n      }\n\n      if (this.isBulkDeleteQuery()) {\n        return data[0] ? data[0].AFFECTEDROWS : 0;\n      }\n\n      if (this.isVersionQuery()) {\n        return data[0].version;\n      }\n\n      if (this.isForeignKeysQuery()) {\n        return data;\n      }\n\n      if (this.isUpsertQuery()) {\n        this.handleInsertQuery(data);\n        return [this.instance || data, data[0].$action === 'INSERT'];\n      }\n\n      if (this.isUpdateQuery()) {\n        return [this.instance || data, rowCount];\n      }\n\n      if (this.isShowConstraintsQuery()) {\n        return this.handleShowConstraintsQuery(data);\n      }\n\n      if (this.isRawQuery()) {\n        return [data, rowCount];\n      }\n\n      return data;\n    }\n  }, {\n    key: \"handleShowTablesQuery\",\n    value: function handleShowTablesQuery(results) {\n      return results.map(function (resultSet) {\n        return {\n          tableName: resultSet.TABLE_NAME,\n          schema: resultSet.TABLE_SCHEMA\n        };\n      });\n    }\n  }, {\n    key: \"handleShowConstraintsQuery\",\n    value: function handleShowConstraintsQuery(data) {\n      //Convert snake_case keys to camelCase as it's generated by stored procedure\n      return data.slice(1).map(function (result) {\n        var constraint = {};\n\n        for (var key in result) {\n          constraint[_.camelCase(key)] = result[key];\n        }\n\n        return constraint;\n      });\n    }\n  }, {\n    key: \"formatError\",\n    value: function formatError(err) {\n      var _this3 = this;\n\n      var match;\n      match = err.message.match(/Violation of (?:UNIQUE|PRIMARY) KEY constraint '([^']*)'. Cannot insert duplicate key in object '.*'.(:? The duplicate key value is \\((.*)\\).)?/);\n      match = match || err.message.match(/Cannot insert duplicate key row in object .* with unique index '(.*)'/);\n\n      if (match && match.length > 1) {\n        var fields = {};\n        var uniqueKey = this.model && this.model.uniqueKeys[match[1]];\n        var message = 'Validation error';\n\n        if (uniqueKey && !!uniqueKey.msg) {\n          message = uniqueKey.msg;\n        }\n\n        if (match[3]) {\n          var values = match[3].split(',').map(function (part) {\n            return part.trim();\n          });\n\n          if (uniqueKey) {\n            fields = _.zipObject(uniqueKey.fields, values);\n          } else {\n            fields[match[1]] = match[3];\n          }\n        }\n\n        var errors = [];\n\n        _.forOwn(fields, function (value, field) {\n          errors.push(new sequelizeErrors.ValidationErrorItem(_this3.getUniqueConstraintErrorMessage(field), 'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,\n          field, value, _this3.instance, 'not_unique'));\n        });\n\n        return new sequelizeErrors.UniqueConstraintError({\n          message: message,\n          errors: errors,\n          parent: err,\n          fields: fields\n        });\n      }\n\n      match = err.message.match(/Failed on step '(.*)'.Could not create constraint. See previous errors./) || err.message.match(/The DELETE statement conflicted with the REFERENCE constraint \"(.*)\". The conflict occurred in database \"(.*)\", table \"(.*)\", column '(.*)'./) || err.message.match(/The (?:INSERT|MERGE|UPDATE) statement conflicted with the FOREIGN KEY constraint \"(.*)\". The conflict occurred in database \"(.*)\", table \"(.*)\", column '(.*)'./);\n\n      if (match && match.length > 0) {\n        return new sequelizeErrors.ForeignKeyConstraintError({\n          fields: null,\n          index: match[1],\n          parent: err\n        });\n      }\n\n      match = err.message.match(/Could not drop constraint. See previous errors./);\n\n      if (match && match.length > 0) {\n        var constraint = err.sql.match(/(?:constraint|index) \\[(.+?)\\]/i);\n        constraint = constraint ? constraint[1] : undefined;\n        var table = err.sql.match(/table \\[(.+?)\\]/i);\n        table = table ? table[1] : undefined;\n        return new sequelizeErrors.UnknownConstraintError({\n          message: match[1],\n          constraint: constraint,\n          table: table,\n          parent: err\n        });\n      }\n\n      return new sequelizeErrors.DatabaseError(err);\n    }\n  }, {\n    key: \"isShowOrDescribeQuery\",\n    value: function isShowOrDescribeQuery() {\n      var result = false;\n      result = result || this.sql.toLowerCase().startsWith(\"select c.column_name as 'name', c.data_type as 'type', c.is_nullable as 'isnull'\");\n      result = result || this.sql.toLowerCase().startsWith('select tablename = t.name, name = ind.name,');\n      result = result || this.sql.toLowerCase().startsWith('exec sys.sp_helpindex @objname');\n      return result;\n    }\n  }, {\n    key: \"isShowIndexesQuery\",\n    value: function isShowIndexesQuery() {\n      return this.sql.toLowerCase().startsWith('exec sys.sp_helpindex @objname');\n    }\n  }, {\n    key: \"handleShowIndexesQuery\",\n    value: function handleShowIndexesQuery(data) {\n      // Group by index name, and collect all fields\n      data = data.reduce(function (acc, item) {\n        if (!(item.index_name in acc)) {\n          acc[item.index_name] = item;\n          item.fields = [];\n        }\n\n        item.index_keys.split(',').forEach(function (column) {\n          var columnName = column.trim();\n\n          if (columnName.includes('(-)')) {\n            columnName = columnName.replace('(-)', '');\n          }\n\n          acc[item.index_name].fields.push({\n            attribute: columnName,\n            length: undefined,\n            order: column.includes('(-)') ? 'DESC' : 'ASC',\n            collate: undefined\n          });\n        });\n        delete item.index_keys;\n        return acc;\n      }, {});\n      return _.map(data, function (item) {\n        return {\n          primary: item.index_name.toLowerCase().startsWith('pk'),\n          fields: item.fields,\n          name: item.index_name,\n          tableName: undefined,\n          unique: item.index_description.toLowerCase().includes('unique'),\n          type: undefined\n        };\n      });\n    }\n  }, {\n    key: \"handleInsertQuery\",\n    value: function handleInsertQuery(results, metaData) {\n      var _this4 = this;\n\n      if (this.instance) {\n        // add the inserted row id to the instance\n        var autoIncrementAttribute = this.model.autoIncrementAttribute;\n        var id = null;\n        var autoIncrementAttributeAlias = null;\n        if (Object.prototype.hasOwnProperty.call(this.model.rawAttributes, autoIncrementAttribute) && this.model.rawAttributes[autoIncrementAttribute].field !== undefined) autoIncrementAttributeAlias = this.model.rawAttributes[autoIncrementAttribute].field;\n        id = id || results && results[0][this.getInsertIdField()];\n        id = id || metaData && metaData[this.getInsertIdField()];\n        id = id || results && results[0][autoIncrementAttribute];\n        id = id || autoIncrementAttributeAlias && results && results[0][autoIncrementAttributeAlias];\n        this.instance[autoIncrementAttribute] = id;\n\n        if (this.instance.dataValues) {\n          var _loop = function _loop(key) {\n            if (Object.prototype.hasOwnProperty.call(results[0], key)) {\n              var record = results[0][key];\n\n              var attr = _.find(_this4.model.rawAttributes, function (attribute) {\n                return attribute.fieldName === key || attribute.field === key;\n              });\n\n              _this4.instance.dataValues[attr && attr.fieldName || key] = record;\n            }\n          };\n\n          for (var key in results[0]) {\n            _loop(key);\n          }\n        }\n      }\n    }\n  }], [{\n    key: \"formatBindParameters\",\n    value: function formatBindParameters(sql, values, dialect) {\n      var bindParam = {};\n\n      var replacementFunc = function replacementFunc(match, key, values) {\n        if (values[key] !== undefined) {\n          bindParam[key] = values[key];\n          return \"@\".concat(key);\n        }\n\n        return undefined;\n      };\n\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n      return [sql, bindParam];\n    }\n  }]);\n\n  return Query;\n}(AbstractQuery);\n\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;","map":null,"metadata":{},"sourceType":"script"}