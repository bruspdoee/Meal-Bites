{"ast":null,"code":";\n\n(function () {\n  'use strict';\n  /* global define */\n\n  var esprima;\n  var exportFn;\n  var toString = Object.prototype.toString;\n\n  if (typeof module === 'object' && typeof module.exports === 'object' && typeof require === 'function') {\n    // server side\n    esprima = require('esprima');\n\n    exportFn = function exportFn(redeyed) {\n      module.exports = redeyed;\n    };\n\n    bootstrap(esprima, exportFn);\n  } else if (typeof define === 'function' && define.amd) {\n    // client side\n    // amd\n    define(['esprima'], function (esprima) {\n      return bootstrap(esprima);\n    });\n  } else if (typeof window === 'object') {\n    // no amd -> attach to window if it exists\n    // Note that this requires 'esprima' to be defined on the window, so that script has to be loaded first\n    window.redeyed = bootstrap(window.esprima);\n  }\n\n  function bootstrap(esprima, exportFn) {\n    function isFunction(obj) {\n      return toString.call(obj) === '[object Function]';\n    }\n\n    function isString(obj) {\n      return toString.call(obj) === '[object String]';\n    }\n\n    function isObject(obj) {\n      return toString.call(obj) === '[object Object]';\n    }\n\n    function surroundWith(before, after) {\n      return function (s) {\n        return before + s + after;\n      };\n    }\n\n    function isNonCircular(key) {\n      return key !== '_parent';\n    }\n\n    function objectizeString(value) {\n      var vals = value.split(':');\n\n      if (vals.length === 0 || vals.length > 2) {\n        throw new Error('illegal string config: ' + value + '\\nShould be of format \"before:after\"');\n      }\n\n      if (vals.length === 1 || vals[1].length === 0) {\n        return vals.indexOf(':') < 0 ? {\n          _before: vals[0]\n        } : {\n          _after: vals[0]\n        };\n      } else {\n        return {\n          _before: vals[0],\n          _after: vals[1]\n        };\n      }\n    }\n\n    function objectize(node) {\n      // Converts 'bef:aft' to { _before: bef, _after: aft }\n      // and resolves undefined before/after from parent or root\n      function resolve(value, key) {\n        // resolve before/after from root or parent if it isn't present on the current node\n        if (!value._parent) return undefined; // Immediate parent\n\n        if (value._parent._default && value._parent._default[key]) return value._parent._default[key]; // Root\n\n        var root = value._parent._parent;\n        if (!root) return undefined;\n        return root._default ? root._default[key] : undefined;\n      }\n\n      function process(key) {\n        var value = node[key];\n        if (!value) return;\n        if (isFunction(value)) return; // normalize all strings to objects\n\n        if (isString(value)) {\n          node[key] = value = objectizeString(value);\n        }\n\n        value._parent = node;\n\n        if (isObject(value)) {\n          if (!value._before && !value._after) return objectize(value); // resolve missing _before or _after from parent(s)\n          // in case we only have either one on this node\n\n          value._before = value._before || resolve(value, '_before');\n          value._after = value._after || resolve(value, '_after');\n          return;\n        }\n\n        throw new Error('nodes need to be either {String}, {Object} or {Function}.' + value + ' is neither.');\n      } // Process _default ones first so children can resolve missing before/after from them\n\n\n      if (node._default) process('_default');\n      Object.keys(node).filter(function (key) {\n        return isNonCircular(key) && node.hasOwnProperty(key) && key !== '_before' && key !== '_after' && key !== '_default';\n      }).forEach(process);\n    }\n\n    function functionize(node) {\n      Object.keys(node).filter(function (key) {\n        return isNonCircular(key) && node.hasOwnProperty(key);\n      }).forEach(function (key) {\n        var value = node[key];\n        if (isFunction(value)) return;\n\n        if (isObject(value)) {\n          if (!value._before && !value._after) return functionize(value); // at this point before/after were \"inherited\" from the parent or root\n          // (see objectize)\n\n          var before = value._before || '';\n          var after = value._after || '';\n          node[key] = surroundWith(before, after);\n          return node[key];\n        }\n      });\n    }\n\n    function normalize(root) {\n      objectize(root);\n      functionize(root);\n    }\n\n    function mergeTokensAndComments(tokens, comments) {\n      var all = {};\n\n      function addToAllByRangeStart(t) {\n        all[t.range[0]] = t;\n      }\n\n      tokens.forEach(addToAllByRangeStart);\n      comments.forEach(addToAllByRangeStart); // keys are sorted automatically\n\n      return Object.keys(all).map(function (k) {\n        return all[k];\n      });\n    }\n\n    function redeyed(code, config, opts) {\n      opts = opts || {};\n      var parser = opts.parser || esprima;\n      var jsx = !!opts.jsx; // tokenizer doesn't support JSX at this point (esprima@4.0.0)\n      // therefore we need to generate the AST via the parser not only to\n      // avoid the tokenizer from erroring but also to get JSXIdentifier tokens\n\n      var buildAst = jsx || !!opts.buildAst;\n      var hashbang = '';\n      var ast;\n      var tokens;\n      var comments;\n      var lastSplitEnd = 0;\n      var splits = [];\n      var transformedCode;\n      var all;\n      var info; // Replace hashbang line with empty whitespaces to preserve token locations\n\n      if (code[0] === '#' && code[1] === '!') {\n        hashbang = code.substr(0, code.indexOf('\\n') + 1);\n        code = Array.apply(0, Array(hashbang.length)).join(' ') + '\\n' + code.substr(hashbang.length);\n      }\n\n      if (buildAst) {\n        ast = parser.parse(code, {\n          tokens: true,\n          comment: true,\n          range: true,\n          loc: true,\n          tolerant: true,\n          jsx: true\n        });\n        tokens = ast.tokens;\n        comments = ast.comments;\n      } else {\n        tokens = [];\n        comments = [];\n        parser.tokenize(code, {\n          range: true,\n          loc: true,\n          comment: true\n        }, function (token) {\n          if (token.type === 'LineComment') {\n            token.type = 'Line';\n            comments.push(token);\n          } else if (token.type === 'BlockComment') {\n            token.type = 'Block';\n            comments.push(token);\n          } else {\n            // Optimistically upgrade 'static' to a keyword\n            if (token.type === 'Identifier' && token.value === 'static') token.type = 'Keyword';\n            tokens.push(token);\n          }\n        });\n      }\n\n      normalize(config);\n\n      function tokenIndex(tokens, tkn, start) {\n        var current;\n        var rangeStart = tkn.range[0];\n\n        for (current = start; current < tokens.length; current++) {\n          if (tokens[current].range[0] === rangeStart) return current;\n        }\n\n        throw new Error('Token %s not found at or after index: %d', tkn, start);\n      }\n\n      function process(surround) {\n        var result;\n        var currentIndex;\n        var nextIndex;\n        var skip = 0;\n        var splitEnd;\n        result = surround(code.slice(start, end), info);\n\n        if (isObject(result)) {\n          splits.push(result.replacement);\n          currentIndex = info.tokenIndex;\n          nextIndex = tokenIndex(info.tokens, result.skipPastToken, currentIndex);\n          skip = nextIndex - currentIndex;\n          splitEnd = skip > 0 ? tokens[nextIndex - 1].range[1] : end;\n        } else {\n          splits.push(result);\n          splitEnd = end;\n        }\n\n        return {\n          skip: skip,\n          splitEnd: splitEnd\n        };\n      }\n\n      function addSplit(start, end, surround, info) {\n        var result;\n        var skip = 0;\n        if (start >= end) return;\n\n        if (surround) {\n          result = process(surround);\n          skip = result.skip;\n          lastSplitEnd = result.splitEnd;\n        } else {\n          splits.push(code.slice(start, end));\n          lastSplitEnd = end;\n        }\n\n        return skip;\n      }\n\n      all = mergeTokensAndComments(tokens, comments);\n\n      for (var tokenIdx = 0; tokenIdx < all.length; tokenIdx++) {\n        var token = all[tokenIdx];\n        var surroundForType = config[token.type];\n        var surround;\n        var start;\n        var end; // At least the type (e.g., 'Keyword') needs to be specified for the token to be surrounded\n\n        if (surroundForType) {\n          // root defaults are only taken into account while resolving before/after otherwise\n          // a root default would apply to everything, even if no type default was specified\n          surround = surroundForType && surroundForType.hasOwnProperty(token.value) && surroundForType[token.value] && isFunction(surroundForType[token.value]) ? surroundForType[token.value] : surroundForType._default;\n          start = token.range[0];\n          end = token.range[1];\n          addSplit(lastSplitEnd, start);\n          info = {\n            tokenIndex: tokenIdx,\n            tokens: all,\n            ast: ast,\n            code: code\n          };\n          tokenIdx += addSplit(start, end, surround, info);\n        }\n      }\n\n      if (lastSplitEnd < code.length) {\n        addSplit(lastSplitEnd, code.length);\n      }\n\n      if (!opts.nojoin) {\n        transformedCode = splits.join('');\n\n        if (hashbang.length > 0) {\n          transformedCode = hashbang + transformedCode.substr(hashbang.length);\n        }\n      }\n\n      return {\n        ast: ast,\n        tokens: tokens,\n        comments: comments,\n        splits: splits,\n        code: transformedCode\n      };\n    }\n\n    return exportFn ? exportFn(redeyed) : redeyed;\n  }\n})();","map":null,"metadata":{},"sourceType":"script"}