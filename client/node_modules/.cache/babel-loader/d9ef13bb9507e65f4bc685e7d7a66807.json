{"ast":null,"code":"'use strict';\n\nvar normalize = require('value-or-function');\n\nvar slice = Array.prototype.slice;\n\nfunction createResolver(config, options) {\n  // TODO: should the config object be validated?\n  config = config || {};\n  options = options || {};\n  var resolver = {\n    resolve: resolve\n  }; // Keep constants separately\n\n  var constants = {};\n\n  function resolveConstant(key) {\n    if (constants.hasOwnProperty(key)) {\n      return constants[key];\n    }\n\n    var definition = config[key]; // Ignore options that are not defined\n\n    if (!definition) {\n      return;\n    }\n\n    var option = options[key];\n\n    if (option != null) {\n      if (typeof option === 'function') {\n        return;\n      }\n\n      option = normalize.call(resolver, definition.type, option);\n\n      if (option != null) {\n        constants[key] = option;\n        return option;\n      }\n    }\n\n    var fallback = definition.default;\n\n    if (option == null && typeof fallback !== 'function') {\n      constants[key] = fallback;\n      return fallback;\n    }\n  } // Keep requested keys to detect (and disallow) recursive resolution\n\n\n  var stack = [];\n\n  function resolve(key) {\n    var option = resolveConstant(key);\n\n    if (option != null) {\n      return option;\n    }\n\n    var definition = config[key]; // Ignore options that are not defined\n\n    if (!definition) {\n      return;\n    }\n\n    if (stack.indexOf(key) >= 0) {\n      throw new Error('Recursive resolution denied.');\n    }\n\n    option = options[key];\n    var fallback = definition.default;\n    var appliedArgs = slice.call(arguments, 1);\n    var args = [definition.type, option].concat(appliedArgs);\n\n    function toResolve() {\n      stack.push(key);\n      var option = normalize.apply(resolver, args);\n\n      if (option == null) {\n        option = fallback;\n\n        if (typeof option === 'function') {\n          option = option.apply(resolver, appliedArgs);\n        }\n      }\n\n      return option;\n    }\n\n    function onResolve() {\n      stack.pop();\n    }\n\n    return tryResolve(toResolve, onResolve);\n  }\n\n  return resolver;\n}\n\nfunction tryResolve(toResolve, onResolve) {\n  try {\n    return toResolve();\n  } finally {\n    onResolve();\n  }\n}\n\nmodule.exports = createResolver;","map":null,"metadata":{},"sourceType":"script"}