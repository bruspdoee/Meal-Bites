{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _get = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _ = require('lodash');\n\nvar Utils = require('../../utils');\n\nvar AbstractQueryGenerator = require('../abstract/query-generator');\n\nvar util = require('util');\n\nvar Op = require('../../operators');\n\nvar jsonFunctionRegex = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nvar jsonOperatorRegex = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nvar tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nvar foreignKeyFields = 'CONSTRAINT_NAME as constraint_name,' + 'CONSTRAINT_NAME as constraintName,' + 'CONSTRAINT_SCHEMA as constraintSchema,' + 'CONSTRAINT_SCHEMA as constraintCatalog,' + 'TABLE_NAME as tableName,' + 'TABLE_SCHEMA as tableSchema,' + 'TABLE_SCHEMA as tableCatalog,' + 'COLUMN_NAME as columnName,' + 'REFERENCED_TABLE_SCHEMA as referencedTableSchema,' + 'REFERENCED_TABLE_SCHEMA as referencedTableCatalog,' + 'REFERENCED_TABLE_NAME as referencedTableName,' + 'REFERENCED_COLUMN_NAME as referencedColumnName';\nvar typeWithoutDefault = new Set(['BLOB', 'TEXT', 'GEOMETRY', 'JSON']);\n\nvar MySQLQueryGenerator = /*#__PURE__*/function (_AbstractQueryGenerat) {\n  _inherits(MySQLQueryGenerator, _AbstractQueryGenerat);\n\n  function MySQLQueryGenerator(options) {\n    var _Object$assign;\n\n    var _this;\n\n    _classCallCheck(this, MySQLQueryGenerator);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MySQLQueryGenerator).call(this, options));\n    _this.OperatorMap = Object.assign({}, _this.OperatorMap, (_Object$assign = {}, _defineProperty(_Object$assign, Op.regexp, 'REGEXP'), _defineProperty(_Object$assign, Op.notRegexp, 'NOT REGEXP'), _Object$assign));\n    return _this;\n  }\n\n  _createClass(MySQLQueryGenerator, [{\n    key: \"createDatabaseQuery\",\n    value: function createDatabaseQuery(databaseName, options) {\n      options = Object.assign({\n        charset: null,\n        collate: null\n      }, options || {});\n      var database = this.quoteIdentifier(databaseName);\n      var charset = options.charset ? \" DEFAULT CHARACTER SET \".concat(this.escape(options.charset)) : '';\n      var collate = options.collate ? \" DEFAULT COLLATE \".concat(this.escape(options.collate)) : '';\n      return \"\".concat(\"CREATE DATABASE IF NOT EXISTS \".concat(database).concat(charset).concat(collate).trim(), \";\");\n    }\n  }, {\n    key: \"dropDatabaseQuery\",\n    value: function dropDatabaseQuery(databaseName) {\n      return \"DROP DATABASE IF EXISTS \".concat(this.quoteIdentifier(databaseName).trim(), \";\");\n    }\n  }, {\n    key: \"createSchema\",\n    value: function createSchema() {\n      return 'SHOW TABLES';\n    }\n  }, {\n    key: \"showSchemasQuery\",\n    value: function showSchemasQuery() {\n      return 'SHOW TABLES';\n    }\n  }, {\n    key: \"versionQuery\",\n    value: function versionQuery() {\n      return 'SELECT VERSION() as `version`';\n    }\n  }, {\n    key: \"createTableQuery\",\n    value: function createTableQuery(tableName, attributes, options) {\n      var _this2 = this;\n\n      options = Object.assign({\n        engine: 'InnoDB',\n        charset: null,\n        rowFormat: null\n      }, options || {});\n      var primaryKeys = [];\n      var foreignKeys = {};\n      var attrStr = [];\n\n      for (var attr in attributes) {\n        if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n        var dataType = attributes[attr];\n        var match = void 0;\n\n        if (dataType.includes('PRIMARY KEY')) {\n          primaryKeys.push(attr);\n\n          if (dataType.includes('REFERENCES')) {\n            // MySQL doesn't support inline REFERENCES declarations: move to the end\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attrStr.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(match[1].replace('PRIMARY KEY', '')));\n            foreignKeys[attr] = match[2];\n          } else {\n            attrStr.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(dataType.replace('PRIMARY KEY', '')));\n          }\n        } else if (dataType.includes('REFERENCES')) {\n          // MySQL doesn't support inline REFERENCES declarations: move to the end\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(match[1]));\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(dataType));\n        }\n      }\n\n      var table = this.quoteTable(tableName);\n      var attributesClause = attrStr.join(', ');\n      var comment = options.comment && typeof options.comment === 'string' ? \" COMMENT \".concat(this.escape(options.comment)) : '';\n      var engine = options.engine;\n      var charset = options.charset ? \" DEFAULT CHARSET=\".concat(options.charset) : '';\n      var collation = options.collate ? \" COLLATE \".concat(options.collate) : '';\n      var rowFormat = options.rowFormat ? \" ROW_FORMAT=\".concat(options.rowFormat) : '';\n      var initialAutoIncrement = options.initialAutoIncrement ? \" AUTO_INCREMENT=\".concat(options.initialAutoIncrement) : '';\n      var pkString = primaryKeys.map(function (pk) {\n        return _this2.quoteIdentifier(pk);\n      }).join(', ');\n\n      if (options.uniqueKeys) {\n        _.each(options.uniqueKeys, function (columns, indexName) {\n          if (columns.customIndex) {\n            if (typeof indexName !== 'string') {\n              indexName = \"uniq_\".concat(tableName, \"_\").concat(columns.fields.join('_'));\n            }\n\n            attributesClause += \", UNIQUE \".concat(_this2.quoteIdentifier(indexName), \" (\").concat(columns.fields.map(function (field) {\n              return _this2.quoteIdentifier(field);\n            }).join(', '), \")\");\n          }\n        });\n      }\n\n      if (pkString.length > 0) {\n        attributesClause += \", PRIMARY KEY (\".concat(pkString, \")\");\n      }\n\n      for (var fkey in foreignKeys) {\n        if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n          attributesClause += \", FOREIGN KEY (\".concat(this.quoteIdentifier(fkey), \") \").concat(foreignKeys[fkey]);\n        }\n      }\n\n      return \"CREATE TABLE IF NOT EXISTS \".concat(table, \" (\").concat(attributesClause, \") ENGINE=\").concat(engine).concat(comment).concat(charset).concat(collation).concat(initialAutoIncrement).concat(rowFormat, \";\");\n    }\n  }, {\n    key: \"describeTableQuery\",\n    value: function describeTableQuery(tableName, schema, schemaDelimiter) {\n      var table = this.quoteTable(this.addSchema({\n        tableName: tableName,\n        _schema: schema,\n        _schemaDelimiter: schemaDelimiter\n      }));\n      return \"SHOW FULL COLUMNS FROM \".concat(table, \";\");\n    }\n  }, {\n    key: \"showTablesQuery\",\n    value: function showTablesQuery(database) {\n      var query = 'SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = \\'BASE TABLE\\'';\n\n      if (database) {\n        query += \" AND TABLE_SCHEMA = \".concat(this.escape(database));\n      } else {\n        query += ' AND TABLE_SCHEMA NOT IN (\\'MYSQL\\', \\'INFORMATION_SCHEMA\\', \\'PERFORMANCE_SCHEMA\\', \\'SYS\\')';\n      }\n\n      return \"\".concat(query, \";\");\n    }\n  }, {\n    key: \"addColumnQuery\",\n    value: function addColumnQuery(table, key, dataType) {\n      var definition = this.attributeToSQL(dataType, {\n        context: 'addColumn',\n        tableName: table,\n        foreignKey: key\n      });\n      return \"ALTER TABLE \".concat(this.quoteTable(table), \" ADD \").concat(this.quoteIdentifier(key), \" \").concat(definition, \";\");\n    }\n  }, {\n    key: \"removeColumnQuery\",\n    value: function removeColumnQuery(tableName, attributeName) {\n      return \"ALTER TABLE \".concat(this.quoteTable(tableName), \" DROP \").concat(this.quoteIdentifier(attributeName), \";\");\n    }\n  }, {\n    key: \"changeColumnQuery\",\n    value: function changeColumnQuery(tableName, attributes) {\n      var attrString = [];\n      var constraintString = [];\n\n      for (var attributeName in attributes) {\n        var definition = attributes[attributeName];\n\n        if (definition.includes('REFERENCES')) {\n          var attrName = this.quoteIdentifier(attributeName);\n          definition = definition.replace(/.+?(?=REFERENCES)/, '');\n          constraintString.push(\"FOREIGN KEY (\".concat(attrName, \") \").concat(definition));\n        } else {\n          attrString.push(\"`\".concat(attributeName, \"` `\").concat(attributeName, \"` \").concat(definition));\n        }\n      }\n\n      var finalQuery = '';\n\n      if (attrString.length) {\n        finalQuery += \"CHANGE \".concat(attrString.join(', '));\n        finalQuery += constraintString.length ? ' ' : '';\n      }\n\n      if (constraintString.length) {\n        finalQuery += \"ADD \".concat(constraintString.join(', '));\n      }\n\n      return \"ALTER TABLE \".concat(this.quoteTable(tableName), \" \").concat(finalQuery, \";\");\n    }\n  }, {\n    key: \"renameColumnQuery\",\n    value: function renameColumnQuery(tableName, attrBefore, attributes) {\n      var attrString = [];\n\n      for (var attrName in attributes) {\n        var definition = attributes[attrName];\n        attrString.push(\"`\".concat(attrBefore, \"` `\").concat(attrName, \"` \").concat(definition));\n      }\n\n      return \"ALTER TABLE \".concat(this.quoteTable(tableName), \" CHANGE \").concat(attrString.join(', '), \";\");\n    }\n  }, {\n    key: \"handleSequelizeMethod\",\n    value: function handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n      var _this3 = this;\n\n      if (smth instanceof Utils.Json) {\n        // Parse nested object\n        if (smth.conditions) {\n          var conditions = this.parseConditionObject(smth.conditions).map(function (condition) {\n            return \"\".concat(_this3.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path)), \" = '\").concat(condition.value, \"'\");\n          });\n          return conditions.join(' AND ');\n        }\n\n        if (smth.path) {\n          var str; // Allow specifying conditions using the sqlite json functions\n\n          if (this._checkValidJsonStatement(smth.path)) {\n            str = smth.path;\n          } else {\n            // Also support json property accessors\n            var paths = _.toPath(smth.path);\n\n            var column = paths.shift();\n            str = this.jsonPathExtractionQuery(column, paths);\n          }\n\n          if (smth.value) {\n            str += util.format(' = %s', this.escape(smth.value));\n          }\n\n          return str;\n        }\n      } else if (smth instanceof Utils.Cast) {\n        if (/timestamp/i.test(smth.type)) {\n          smth.type = 'datetime';\n        } else if (smth.json && /boolean/i.test(smth.type)) {\n          // true or false cannot be casted as booleans within a JSON structure\n          smth.type = 'char';\n        } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {\n          smth.type = 'decimal';\n        } else if (/text/i.test(smth.type)) {\n          smth.type = 'char';\n        }\n      }\n\n      return _get(_getPrototypeOf(MySQLQueryGenerator.prototype), \"handleSequelizeMethod\", this).call(this, smth, tableName, factory, options, prepend);\n    }\n  }, {\n    key: \"_toJSONValue\",\n    value: function _toJSONValue(value) {\n      // true/false are stored as strings in mysql\n      if (typeof value === 'boolean') {\n        return value.toString();\n      } // null is stored as a string in mysql\n\n\n      if (value === null) {\n        return 'null';\n      }\n\n      return value;\n    }\n  }, {\n    key: \"upsertQuery\",\n    value: function upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n      var _this4 = this;\n\n      options.onDuplicate = 'UPDATE ';\n      options.onDuplicate += Object.keys(updateValues).map(function (key) {\n        key = _this4.quoteIdentifier(key);\n        return \"\".concat(key, \"=VALUES(\").concat(key, \")\");\n      }).join(', ');\n      return this.insertQuery(tableName, insertValues, model.rawAttributes, options);\n    }\n  }, {\n    key: \"truncateTableQuery\",\n    value: function truncateTableQuery(tableName) {\n      return \"TRUNCATE \".concat(this.quoteTable(tableName));\n    }\n  }, {\n    key: \"deleteQuery\",\n    value: function deleteQuery(tableName, where) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var model = arguments.length > 3 ? arguments[3] : undefined;\n      var limit = '';\n      var query = \"DELETE FROM \".concat(this.quoteTable(tableName));\n\n      if (options.limit) {\n        limit = \" LIMIT \".concat(this.escape(options.limit));\n      }\n\n      where = this.getWhereConditions(where, null, model, options);\n\n      if (where) {\n        query += \" WHERE \".concat(where);\n      }\n\n      return query + limit;\n    }\n  }, {\n    key: \"showIndexesQuery\",\n    value: function showIndexesQuery(tableName, options) {\n      return \"SHOW INDEX FROM \".concat(this.quoteTable(tableName)).concat((options || {}).database ? \" FROM `\".concat(options.database, \"`\") : '');\n    }\n  }, {\n    key: \"showConstraintsQuery\",\n    value: function showConstraintsQuery(table, constraintName) {\n      var tableName = table.tableName || table;\n      var schemaName = table.schema;\n      var sql = ['SELECT CONSTRAINT_CATALOG AS constraintCatalog,', 'CONSTRAINT_NAME AS constraintName,', 'CONSTRAINT_SCHEMA AS constraintSchema,', 'CONSTRAINT_TYPE AS constraintType,', 'TABLE_NAME AS tableName,', 'TABLE_SCHEMA AS tableSchema', 'from INFORMATION_SCHEMA.TABLE_CONSTRAINTS', \"WHERE table_name='\".concat(tableName, \"'\")].join(' ');\n\n      if (constraintName) {\n        sql += \" AND constraint_name = '\".concat(constraintName, \"'\");\n      }\n\n      if (schemaName) {\n        sql += \" AND TABLE_SCHEMA = '\".concat(schemaName, \"'\");\n      }\n\n      return \"\".concat(sql, \";\");\n    }\n  }, {\n    key: \"removeIndexQuery\",\n    value: function removeIndexQuery(tableName, indexNameOrAttributes) {\n      var indexName = indexNameOrAttributes;\n\n      if (typeof indexName !== 'string') {\n        indexName = Utils.underscore(\"\".concat(tableName, \"_\").concat(indexNameOrAttributes.join('_')));\n      }\n\n      return \"DROP INDEX \".concat(this.quoteIdentifier(indexName), \" ON \").concat(this.quoteTable(tableName));\n    }\n  }, {\n    key: \"attributeToSQL\",\n    value: function attributeToSQL(attribute, options) {\n      if (!_.isPlainObject(attribute)) {\n        attribute = {\n          type: attribute\n        };\n      }\n\n      var attributeString = attribute.type.toString({\n        escape: this.escape.bind(this)\n      });\n      var template = attributeString;\n\n      if (attribute.allowNull === false) {\n        template += ' NOT NULL';\n      }\n\n      if (attribute.autoIncrement) {\n        template += ' auto_increment';\n      } // BLOB/TEXT/GEOMETRY/JSON cannot have a default value\n\n\n      if (!typeWithoutDefault.has(attributeString) && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n        template += \" DEFAULT \".concat(this.escape(attribute.defaultValue));\n      }\n\n      if (attribute.unique === true) {\n        template += ' UNIQUE';\n      }\n\n      if (attribute.primaryKey) {\n        template += ' PRIMARY KEY';\n      }\n\n      if (attribute.comment) {\n        template += \" COMMENT \".concat(this.escape(attribute.comment));\n      }\n\n      if (attribute.first) {\n        template += ' FIRST';\n      }\n\n      if (attribute.after) {\n        template += \" AFTER \".concat(this.quoteIdentifier(attribute.after));\n      }\n\n      if (attribute.references) {\n        if (options && options.context === 'addColumn' && options.foreignKey) {\n          var attrName = this.quoteIdentifier(options.foreignKey);\n          var fkName = this.quoteIdentifier(\"\".concat(options.tableName, \"_\").concat(attrName, \"_foreign_idx\"));\n          template += \", ADD CONSTRAINT \".concat(fkName, \" FOREIGN KEY (\").concat(attrName, \")\");\n        }\n\n        template += \" REFERENCES \".concat(this.quoteTable(attribute.references.model));\n\n        if (attribute.references.key) {\n          template += \" (\".concat(this.quoteIdentifier(attribute.references.key), \")\");\n        } else {\n          template += \" (\".concat(this.quoteIdentifier('id'), \")\");\n        }\n\n        if (attribute.onDelete) {\n          template += \" ON DELETE \".concat(attribute.onDelete.toUpperCase());\n        }\n\n        if (attribute.onUpdate) {\n          template += \" ON UPDATE \".concat(attribute.onUpdate.toUpperCase());\n        }\n      }\n\n      return template;\n    }\n  }, {\n    key: \"attributesToSQL\",\n    value: function attributesToSQL(attributes, options) {\n      var result = {};\n\n      for (var key in attributes) {\n        var attribute = attributes[key];\n        result[attribute.field || key] = this.attributeToSQL(attribute, options);\n      }\n\n      return result;\n    }\n    /**\n     * Check whether the statmement is json function or simple path\n     *\n     * @param   {string}  stmt  The statement to validate\n     * @returns {boolean}       true if the given statement is json function\n     * @throws  {Error}         throw if the statement looks like json function but has invalid token\n     * @private\n     */\n\n  }, {\n    key: \"_checkValidJsonStatement\",\n    value: function _checkValidJsonStatement(stmt) {\n      if (typeof stmt !== 'string') {\n        return false;\n      }\n\n      var currentIndex = 0;\n      var openingBrackets = 0;\n      var closingBrackets = 0;\n      var hasJsonFunction = false;\n      var hasInvalidToken = false;\n\n      while (currentIndex < stmt.length) {\n        var string = stmt.substr(currentIndex);\n        var functionMatches = jsonFunctionRegex.exec(string);\n\n        if (functionMatches) {\n          currentIndex += functionMatches[0].indexOf('(');\n          hasJsonFunction = true;\n          continue;\n        }\n\n        var operatorMatches = jsonOperatorRegex.exec(string);\n\n        if (operatorMatches) {\n          currentIndex += operatorMatches[0].length;\n          hasJsonFunction = true;\n          continue;\n        }\n\n        var tokenMatches = tokenCaptureRegex.exec(string);\n\n        if (tokenMatches) {\n          var capturedToken = tokenMatches[1];\n\n          if (capturedToken === '(') {\n            openingBrackets++;\n          } else if (capturedToken === ')') {\n            closingBrackets++;\n          } else if (capturedToken === ';') {\n            hasInvalidToken = true;\n            break;\n          }\n\n          currentIndex += tokenMatches[0].length;\n          continue;\n        }\n\n        break;\n      } // Check invalid json statement\n\n\n      if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n        throw new Error(\"Invalid json statement: \".concat(stmt));\n      } // return true if the statement has valid json function\n\n\n      return hasJsonFunction;\n    }\n    /**\n     * Generates an SQL query that returns all foreign keys of a table.\n     *\n     * @param  {Object} table  The table.\n     * @param  {string} schemaName The name of the schema.\n     * @returns {string}            The generated sql query.\n     * @private\n     */\n\n  }, {\n    key: \"getForeignKeysQuery\",\n    value: function getForeignKeysQuery(table, schemaName) {\n      var tableName = table.tableName || table;\n      return \"SELECT \".concat(foreignKeyFields, \" FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '\").concat(tableName, \"' AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='\").concat(schemaName, \"' AND REFERENCED_TABLE_NAME IS NOT NULL;\");\n    }\n    /**\n     * Generates an SQL query that returns the foreign key constraint of a given column.\n     *\n     * @param  {Object} table  The table.\n     * @param  {string} columnName The name of the column.\n     * @returns {string}            The generated sql query.\n     * @private\n     */\n\n  }, {\n    key: \"getForeignKeyQuery\",\n    value: function getForeignKeyQuery(table, columnName) {\n      var quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : '';\n      var quotedTableName = wrapSingleQuote(table.tableName || table);\n      var quotedColumnName = wrapSingleQuote(columnName);\n      return \"SELECT \".concat(foreignKeyFields, \" FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE\") + \" WHERE (REFERENCED_TABLE_NAME = \".concat(quotedTableName).concat(table.schema ? \" AND REFERENCED_TABLE_SCHEMA = \".concat(quotedSchemaName) : '', \" AND REFERENCED_COLUMN_NAME = \").concat(quotedColumnName, \")\") + \" OR (TABLE_NAME = \".concat(quotedTableName).concat(table.schema ? \" AND TABLE_SCHEMA = \".concat(quotedSchemaName) : '', \" AND COLUMN_NAME = \").concat(quotedColumnName, \" AND REFERENCED_TABLE_NAME IS NOT NULL)\");\n    }\n    /**\n     * Generates an SQL query that removes a foreign key from a table.\n     *\n     * @param  {string} tableName  The name of the table.\n     * @param  {string} foreignKey The name of the foreign key constraint.\n     * @returns {string}            The generated sql query.\n     * @private\n     */\n\n  }, {\n    key: \"dropForeignKeyQuery\",\n    value: function dropForeignKeyQuery(tableName, foreignKey) {\n      return \"ALTER TABLE \".concat(this.quoteTable(tableName), \"\\n      DROP FOREIGN KEY \").concat(this.quoteIdentifier(foreignKey), \";\");\n    }\n  }]);\n\n  return MySQLQueryGenerator;\n}(AbstractQueryGenerator); // private methods\n\n\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, '\\'');\n}\n\nmodule.exports = MySQLQueryGenerator;","map":null,"metadata":{},"sourceType":"script"}