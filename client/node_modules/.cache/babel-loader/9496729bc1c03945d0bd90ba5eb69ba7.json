{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _defineProperty = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar Utils = require('./../utils');\n\nvar Helpers = require('./helpers');\n\nvar _ = require('lodash');\n\nvar Association = require('./base');\n\nvar BelongsTo = require('./belongs-to');\n\nvar HasMany = require('./has-many');\n\nvar HasOne = require('./has-one');\n\nvar AssociationError = require('../errors').AssociationError;\n\nvar EmptyResultError = require('../errors').EmptyResultError;\n\nvar Op = require('../operators');\n/**\n * Many-to-many association with a join table.\n *\n * When the join table has additional attributes, these can be passed in the options object:\n *\n * ```js\n * UserProject = sequelize.define('user_project', {\n *   role: Sequelize.STRING\n * });\n * User.belongsToMany(Project, { through: UserProject });\n * Project.belongsToMany(User, { through: UserProject });\n * // through is required!\n *\n * user.addProject(project, { through: { role: 'manager' }});\n * ```\n *\n * All methods allow you to pass either a persisted instance, its primary key, or a mixture:\n *\n * ```js\n * Project.create({ id: 11 }).then(project => {\n *   user.addProjects([project, 12]);\n * });\n * ```\n *\n * If you want to set several target instances, but with different attributes you have to set the attributes on the instance, using a property with the name of the through model:\n *\n * ```js\n * p1.UserProjects = {\n *   started: true\n * }\n * user.setProjects([p1, p2], { through: { started: false }}) // The default value is false, but p1 overrides that.\n * ```\n *\n * Similarly, when fetching through a join table with custom attributes, these attributes will be available as an object with the name of the through model.\n * ```js\n * user.getProjects().then(projects => {\n   *   let p1 = projects[0]\n   *   p1.UserProjects.started // Is this project started yet?\n   * })\n * ```\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.belongsToMany(Project)` the getter will be `user.getProjects()`.\n *\n * @see {@link Model.belongsToMany}\n */\n\n\nvar BelongsToMany = /*#__PURE__*/function (_Association) {\n  _inherits(BelongsToMany, _Association);\n\n  function BelongsToMany(source, target, options) {\n    var _this;\n\n    _classCallCheck(this, BelongsToMany);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(BelongsToMany).call(this, source, target, options));\n\n    if (_this.options.through === undefined || _this.options.through === true || _this.options.through === null) {\n      throw new AssociationError(\"\".concat(source.name, \".belongsToMany(\").concat(target.name, \") requires through option, pass either a string or a model\"));\n    }\n\n    if (!_this.options.through.model) {\n      _this.options.through = {\n        model: options.through\n      };\n    }\n\n    _this.associationType = 'BelongsToMany';\n    _this.targetAssociation = null;\n    _this.sequelize = source.sequelize;\n    _this.through = Object.assign({}, _this.options.through);\n    _this.isMultiAssociation = true;\n    _this.doubleLinked = false;\n\n    if (!_this.as && _this.isSelfAssociation) {\n      throw new AssociationError('\\'as\\' must be defined for many-to-many self-associations');\n    }\n\n    if (_this.as) {\n      _this.isAliased = true;\n\n      if (_.isPlainObject(_this.as)) {\n        _this.options.name = _this.as;\n        _this.as = _this.as.plural;\n      } else {\n        _this.options.name = {\n          plural: _this.as,\n          singular: Utils.singularize(_this.as)\n        };\n      }\n    } else {\n      _this.as = _this.target.options.name.plural;\n      _this.options.name = _this.target.options.name;\n    }\n\n    _this.combinedTableName = Utils.combineTableNames(_this.source.tableName, _this.isSelfAssociation ? _this.as || _this.target.tableName : _this.target.tableName);\n    /*\n    * If self association, this is the target association - Unless we find a pairing association\n    */\n\n    if (_this.isSelfAssociation) {\n      _this.targetAssociation = _assertThisInitialized(_assertThisInitialized(_this));\n    }\n    /*\n    * Find paired association (if exists)\n    */\n\n\n    _.each(_this.target.associations, function (association) {\n      if (association.associationType !== 'BelongsToMany') return;\n      if (association.target !== _this.source) return;\n\n      if (_this.options.through.model === association.options.through.model) {\n        _this.paired = association;\n        association.paired = _assertThisInitialized(_assertThisInitialized(_this));\n      }\n    });\n    /*\n    * Default/generated source/target keys\n    */\n\n\n    _this.sourceKey = _this.options.sourceKey || _this.source.primaryKeyAttribute;\n    _this.sourceKeyField = _this.source.rawAttributes[_this.sourceKey].field || _this.sourceKey;\n\n    if (_this.options.targetKey) {\n      _this.targetKey = _this.options.targetKey;\n      _this.targetKeyField = _this.target.rawAttributes[_this.targetKey].field || _this.targetKey;\n    } else {\n      _this.targetKeyDefault = true;\n      _this.targetKey = _this.target.primaryKeyAttribute;\n      _this.targetKeyField = _this.target.rawAttributes[_this.targetKey].field || _this.targetKey;\n    }\n\n    _this._createForeignAndOtherKeys();\n\n    if (typeof _this.through.model === 'string') {\n      if (!_this.sequelize.isDefined(_this.through.model)) {\n        _this.through.model = _this.sequelize.define(_this.through.model, {}, Object.assign(_this.options, {\n          tableName: _this.through.model,\n          indexes: [],\n          //we don't want indexes here (as referenced in #2416)\n          paranoid: false,\n          // A paranoid join table does not make sense\n          validate: {} // Don't propagate model-level validations\n\n        }));\n      } else {\n        _this.through.model = _this.sequelize.model(_this.through.model);\n      }\n    }\n\n    _this.options = Object.assign(_this.options, _.pick(_this.through.model.options, ['timestamps', 'createdAt', 'updatedAt', 'deletedAt', 'paranoid']));\n\n    if (_this.paired) {\n      var needInjectPaired = false;\n\n      if (_this.targetKeyDefault) {\n        _this.targetKey = _this.paired.sourceKey;\n        _this.targetKeyField = _this.paired.sourceKeyField;\n\n        _this._createForeignAndOtherKeys();\n      }\n\n      if (_this.paired.targetKeyDefault) {\n        // in this case paired.otherKey depends on paired.targetKey,\n        // so cleanup previously wrong generated otherKey\n        if (_this.paired.targetKey !== _this.sourceKey) {\n          delete _this.through.model.rawAttributes[_this.paired.otherKey];\n          _this.paired.targetKey = _this.sourceKey;\n          _this.paired.targetKeyField = _this.sourceKeyField;\n\n          _this.paired._createForeignAndOtherKeys();\n\n          needInjectPaired = true;\n        }\n      }\n\n      if (_this.otherKeyDefault) {\n        _this.otherKey = _this.paired.foreignKey;\n      }\n\n      if (_this.paired.otherKeyDefault) {\n        // If paired otherKey was inferred we should make sure to clean it up\n        // before adding a new one that matches the foreignKey\n        if (_this.paired.otherKey !== _this.foreignKey) {\n          delete _this.through.model.rawAttributes[_this.paired.otherKey];\n          _this.paired.otherKey = _this.foreignKey;\n          needInjectPaired = true;\n        }\n      }\n\n      if (needInjectPaired) {\n        _this.paired._injectAttributes();\n      }\n    }\n\n    if (_this.through) {\n      _this.throughModel = _this.through.model;\n    }\n\n    _this.options.tableName = _this.combinedName = _this.through.model === Object(_this.through.model) ? _this.through.model.tableName : _this.through.model;\n    _this.associationAccessor = _this.as; // Get singular and plural names, trying to uppercase the first letter, unless the model forbids it\n\n    var plural = _.upperFirst(_this.options.name.plural);\n\n    var singular = _.upperFirst(_this.options.name.singular);\n\n    _this.accessors = {\n      get: \"get\".concat(plural),\n      set: \"set\".concat(plural),\n      addMultiple: \"add\".concat(plural),\n      add: \"add\".concat(singular),\n      create: \"create\".concat(singular),\n      remove: \"remove\".concat(singular),\n      removeMultiple: \"remove\".concat(plural),\n      hasSingle: \"has\".concat(singular),\n      hasAll: \"has\".concat(plural),\n      count: \"count\".concat(plural)\n    };\n    return _this;\n  }\n\n  _createClass(BelongsToMany, [{\n    key: \"_createForeignAndOtherKeys\",\n    value: function _createForeignAndOtherKeys() {\n      /*\n      * Default/generated foreign/other keys\n      */\n      if (_.isObject(this.options.foreignKey)) {\n        this.foreignKeyAttribute = this.options.foreignKey;\n        this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n      } else {\n        this.foreignKeyAttribute = {};\n        this.foreignKey = this.options.foreignKey || Utils.camelize([this.source.options.name.singular, this.sourceKey].join('_'));\n      }\n\n      if (_.isObject(this.options.otherKey)) {\n        this.otherKeyAttribute = this.options.otherKey;\n        this.otherKey = this.otherKeyAttribute.name || this.otherKeyAttribute.fieldName;\n      } else {\n        if (!this.options.otherKey) {\n          this.otherKeyDefault = true;\n        }\n\n        this.otherKeyAttribute = {};\n        this.otherKey = this.options.otherKey || Utils.camelize([this.isSelfAssociation ? Utils.singularize(this.as) : this.target.options.name.singular, this.targetKey].join('_'));\n      }\n    } // the id is in the target table\n    // or in an extra table which connects two tables\n\n  }, {\n    key: \"_injectAttributes\",\n    value: function _injectAttributes() {\n      var _this2 = this;\n\n      this.identifier = this.foreignKey;\n      this.foreignIdentifier = this.otherKey; // remove any PKs previously defined by sequelize\n      // but ignore any keys that are part of this association (#5865)\n\n      _.each(this.through.model.rawAttributes, function (attribute, attributeName) {\n        if (attribute.primaryKey === true && attribute._autoGenerated === true) {\n          if (attributeName === _this2.foreignKey || attributeName === _this2.otherKey) {\n            // this key is still needed as it's part of the association\n            // so just set primaryKey to false\n            attribute.primaryKey = false;\n          } else {\n            delete _this2.through.model.rawAttributes[attributeName];\n          }\n\n          _this2.primaryKeyDeleted = true;\n        }\n      });\n\n      var sourceKey = this.source.rawAttributes[this.sourceKey];\n      var sourceKeyType = sourceKey.type;\n      var sourceKeyField = this.sourceKeyField;\n      var targetKey = this.target.rawAttributes[this.targetKey];\n      var targetKeyType = targetKey.type;\n      var targetKeyField = this.targetKeyField;\n\n      var sourceAttribute = _.defaults({}, this.foreignKeyAttribute, {\n        type: sourceKeyType\n      });\n\n      var targetAttribute = _.defaults({}, this.otherKeyAttribute, {\n        type: targetKeyType\n      });\n\n      if (this.primaryKeyDeleted === true) {\n        targetAttribute.primaryKey = sourceAttribute.primaryKey = true;\n      } else if (this.through.unique !== false) {\n        var uniqueKey;\n\n        if (typeof this.options.uniqueKey === 'string' && this.options.uniqueKey !== '') {\n          uniqueKey = this.options.uniqueKey;\n        } else {\n          uniqueKey = [this.through.model.tableName, this.foreignKey, this.otherKey, 'unique'].join('_');\n        }\n\n        targetAttribute.unique = sourceAttribute.unique = uniqueKey;\n      }\n\n      if (!this.through.model.rawAttributes[this.foreignKey]) {\n        this.through.model.rawAttributes[this.foreignKey] = {\n          _autoGenerated: true\n        };\n      }\n\n      if (!this.through.model.rawAttributes[this.otherKey]) {\n        this.through.model.rawAttributes[this.otherKey] = {\n          _autoGenerated: true\n        };\n      }\n\n      if (this.options.constraints !== false) {\n        sourceAttribute.references = {\n          model: this.source.getTableName(),\n          key: sourceKeyField\n        }; // For the source attribute the passed option is the priority\n\n        sourceAttribute.onDelete = this.options.onDelete || this.through.model.rawAttributes[this.foreignKey].onDelete;\n        sourceAttribute.onUpdate = this.options.onUpdate || this.through.model.rawAttributes[this.foreignKey].onUpdate;\n        if (!sourceAttribute.onDelete) sourceAttribute.onDelete = 'CASCADE';\n        if (!sourceAttribute.onUpdate) sourceAttribute.onUpdate = 'CASCADE';\n        targetAttribute.references = {\n          model: this.target.getTableName(),\n          key: targetKeyField\n        }; // But the for target attribute the previously defined option is the priority (since it could've been set by another belongsToMany call)\n\n        targetAttribute.onDelete = this.through.model.rawAttributes[this.otherKey].onDelete || this.options.onDelete;\n        targetAttribute.onUpdate = this.through.model.rawAttributes[this.otherKey].onUpdate || this.options.onUpdate;\n        if (!targetAttribute.onDelete) targetAttribute.onDelete = 'CASCADE';\n        if (!targetAttribute.onUpdate) targetAttribute.onUpdate = 'CASCADE';\n      }\n\n      this.through.model.rawAttributes[this.foreignKey] = Object.assign(this.through.model.rawAttributes[this.foreignKey], sourceAttribute);\n      this.through.model.rawAttributes[this.otherKey] = Object.assign(this.through.model.rawAttributes[this.otherKey], targetAttribute);\n      this.through.model.refreshAttributes();\n      this.identifierField = this.through.model.rawAttributes[this.foreignKey].field || this.foreignKey;\n      this.foreignIdentifierField = this.through.model.rawAttributes[this.otherKey].field || this.otherKey;\n\n      if (this.paired && !this.paired.foreignIdentifierField) {\n        this.paired.foreignIdentifierField = this.through.model.rawAttributes[this.paired.otherKey].field || this.paired.otherKey;\n      }\n\n      this.toSource = new BelongsTo(this.through.model, this.source, {\n        foreignKey: this.foreignKey\n      });\n      this.manyFromSource = new HasMany(this.source, this.through.model, {\n        foreignKey: this.foreignKey\n      });\n      this.oneFromSource = new HasOne(this.source, this.through.model, {\n        foreignKey: this.foreignKey,\n        as: this.through.model.name\n      });\n      this.toTarget = new BelongsTo(this.through.model, this.target, {\n        foreignKey: this.otherKey\n      });\n      this.manyFromTarget = new HasMany(this.target, this.through.model, {\n        foreignKey: this.otherKey\n      });\n      this.oneFromTarget = new HasOne(this.target, this.through.model, {\n        foreignKey: this.otherKey,\n        as: this.through.model.name\n      });\n\n      if (this.paired && this.paired.otherKeyDefault) {\n        this.paired.toTarget = new BelongsTo(this.paired.through.model, this.paired.target, {\n          foreignKey: this.paired.otherKey\n        });\n        this.paired.oneFromTarget = new HasOne(this.paired.target, this.paired.through.model, {\n          foreignKey: this.paired.otherKey,\n          as: this.paired.through.model.name\n        });\n      }\n\n      Helpers.checkNamingCollision(this);\n      return this;\n    }\n  }, {\n    key: \"mixin\",\n    value: function mixin(obj) {\n      var methods = ['get', 'count', 'hasSingle', 'hasAll', 'set', 'add', 'addMultiple', 'remove', 'removeMultiple', 'create'];\n      var aliases = {\n        hasSingle: 'has',\n        hasAll: 'has',\n        addMultiple: 'add',\n        removeMultiple: 'remove'\n      };\n      Helpers.mixinMethods(this, obj, methods, aliases);\n    }\n    /**\n     * Get everything currently associated with this, using an optional where clause.\n     *\n     * @see\n     * {@link Model} for a full explanation of options\n     *\n     * @param {Model} instance instance\n     * @param {Object} [options] find options\n     * @param {Object} [options.where] An optional where clause to limit the associated models\n     * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n     * @param {string} [options.schema] Apply a schema on the related model\n     *\n     * @returns {Promise<Array<Model>>}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(instance, options) {\n      options = Utils.cloneDeep(options) || {};\n      var through = this.through;\n      var scopeWhere;\n      var throughWhere;\n\n      if (this.scope) {\n        scopeWhere = _.clone(this.scope);\n      }\n\n      options.where = _defineProperty({}, Op.and, [scopeWhere, options.where]);\n\n      if (Object(through.model) === through.model) {\n        throughWhere = {};\n        throughWhere[this.foreignKey] = instance.get(this.sourceKey);\n\n        if (through.scope) {\n          Object.assign(throughWhere, through.scope);\n        } //If a user pass a where on the options through options, make an \"and\" with the current throughWhere\n\n\n        if (options.through && options.through.where) {\n          throughWhere = _defineProperty({}, Op.and, [throughWhere, options.through.where]);\n        }\n\n        options.include = options.include || [];\n        options.include.push({\n          association: this.oneFromTarget,\n          attributes: options.joinTableAttributes,\n          required: true,\n          where: throughWhere\n        });\n      }\n\n      var model = this.target;\n\n      if (Object.prototype.hasOwnProperty.call(options, 'scope')) {\n        if (!options.scope) {\n          model = model.unscoped();\n        } else {\n          model = model.scope(options.scope);\n        }\n      }\n\n      if (Object.prototype.hasOwnProperty.call(options, 'schema')) {\n        model = model.schema(options.schema, options.schemaDelimiter);\n      }\n\n      return model.findAll(options);\n    }\n    /**\n     * Count everything currently associated with this, using an optional where clause.\n     *\n     * @param {Model} instance instance\n     * @param {Object} [options] find options\n     * @param {Object} [options.where] An optional where clause to limit the associated models\n     * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n     *\n     * @returns {Promise<number>}\n     */\n\n  }, {\n    key: \"count\",\n    value: function count(instance, options) {\n      var sequelize = this.target.sequelize;\n      options = Utils.cloneDeep(options);\n      options.attributes = [[sequelize.fn('COUNT', sequelize.col([this.target.name, this.targetKeyField].join('.'))), 'count']];\n      options.joinTableAttributes = [];\n      options.raw = true;\n      options.plain = true;\n      return this.get(instance, options).then(function (result) {\n        return parseInt(result.count, 10);\n      });\n    }\n    /**\n     * Check if one or more instance(s) are associated with this. If a list of instances is passed, the function returns true if _all_ instances are associated\n     *\n     * @param {Model} sourceInstance source instance to check for an association with\n     * @param {Model|Model[]|string[]|string|number[]|number} [instances] Can be an array of instances or their primary keys\n     * @param {Object} [options] Options passed to getAssociations\n     *\n     * @returns {Promise<boolean>}\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(sourceInstance, instances, options) {\n      var _this3 = this;\n\n      if (!Array.isArray(instances)) {\n        instances = [instances];\n      }\n\n      options = Object.assign({\n        raw: true\n      }, options, {\n        scope: false,\n        attributes: [this.targetKey],\n        joinTableAttributes: []\n      });\n      var instancePrimaryKeys = instances.map(function (instance) {\n        if (instance instanceof _this3.target) {\n          return instance.where();\n        }\n\n        return _defineProperty({}, _this3.targetKey, instance);\n      });\n      options.where = _defineProperty({}, Op.and, [_defineProperty({}, Op.or, instancePrimaryKeys), options.where]);\n      return this.get(sourceInstance, options).then(function (associatedObjects) {\n        return _.differenceWith(instancePrimaryKeys, associatedObjects, function (a, b) {\n          return _.isEqual(a[_this3.targetKey], b[_this3.targetKey]);\n        }).length === 0;\n      });\n    }\n    /**\n     * Set the associated models by passing an array of instances or their primary keys.\n     * Everything that it not in the passed array will be un-associated.\n     *\n     * @param {Model} sourceInstance source instance to associate new instances with\n     * @param {Model|Model[]|string[]|string|number[]|number} [newAssociatedObjects] A single instance or primary key, or a mixed array of persisted instances or primary keys\n     * @param {Object} [options] Options passed to `through.findAll`, `bulkCreate`, `update` and `destroy`\n     * @param {Object} [options.validate] Run validation for the join model\n     * @param {Object} [options.through] Additional attributes for the join table.\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(sourceInstance, newAssociatedObjects, options) {\n      var _this4 = this;\n\n      options = options || {};\n      var sourceKey = this.sourceKey;\n      var targetKey = this.targetKey;\n      var identifier = this.identifier;\n      var foreignIdentifier = this.foreignIdentifier;\n      var where = {};\n\n      if (newAssociatedObjects === null) {\n        newAssociatedObjects = [];\n      } else {\n        newAssociatedObjects = this.toInstanceArray(newAssociatedObjects);\n      }\n\n      where[identifier] = sourceInstance.get(sourceKey);\n      where = Object.assign(where, this.through.scope);\n\n      var updateAssociations = function updateAssociations(currentRows) {\n        var obsoleteAssociations = [];\n        var promises = [];\n        var defaultAttributes = options.through || {};\n        var unassociatedObjects = newAssociatedObjects.filter(function (obj) {\n          return !currentRows.some(function (currentRow) {\n            return currentRow[foreignIdentifier] === obj.get(targetKey);\n          });\n        });\n\n        var _iterator = _createForOfIteratorHelper(currentRows),\n            _step;\n\n        try {\n          var _loop = function _loop() {\n            var currentRow = _step.value;\n            var newObj = newAssociatedObjects.find(function (obj) {\n              return currentRow[foreignIdentifier] === obj.get(targetKey);\n            });\n\n            if (!newObj) {\n              obsoleteAssociations.push(currentRow);\n            } else {\n              var throughAttributes = newObj[_this4.through.model.name]; // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)\n\n              if (throughAttributes instanceof _this4.through.model) {\n                throughAttributes = {};\n              }\n\n              var attributes = _.defaults({}, throughAttributes, defaultAttributes);\n\n              if (Object.keys(attributes).length) {\n                var _where2;\n\n                promises.push(_this4.through.model.update(attributes, Object.assign(options, {\n                  where: (_where2 = {}, _defineProperty(_where2, identifier, sourceInstance.get(sourceKey)), _defineProperty(_where2, foreignIdentifier, newObj.get(targetKey)), _where2)\n                })));\n              }\n            }\n          };\n\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            _loop();\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        if (obsoleteAssociations.length > 0) {\n          var _Object$assign;\n\n          var _where = Object.assign((_Object$assign = {}, _defineProperty(_Object$assign, identifier, sourceInstance.get(sourceKey)), _defineProperty(_Object$assign, foreignIdentifier, obsoleteAssociations.map(function (obsoleteAssociation) {\n            return obsoleteAssociation[foreignIdentifier];\n          })), _Object$assign), _this4.through.scope);\n\n          promises.push(_this4.through.model.destroy(_.defaults({\n            where: _where\n          }, options)));\n        }\n\n        if (unassociatedObjects.length > 0) {\n          var bulk = unassociatedObjects.map(function (unassociatedObject) {\n            var attributes = {};\n            attributes[identifier] = sourceInstance.get(sourceKey);\n            attributes[foreignIdentifier] = unassociatedObject.get(targetKey);\n            attributes = _.defaults(attributes, unassociatedObject[_this4.through.model.name], defaultAttributes);\n            Object.assign(attributes, _this4.through.scope);\n            attributes = Object.assign(attributes, _this4.through.scope);\n            return attributes;\n          });\n          promises.push(_this4.through.model.bulkCreate(bulk, Object.assign({\n            validate: true\n          }, options)));\n        }\n\n        return Utils.Promise.all(promises);\n      };\n\n      return this.through.model.findAll(_.defaults({\n        where: where,\n        raw: true\n      }, options)).then(function (currentRows) {\n        return updateAssociations(currentRows);\n      }).catch(function (error) {\n        if (error instanceof EmptyResultError) return updateAssociations([]);\n        throw error;\n      });\n    }\n    /**\n     * Associate one or several rows with source instance. It will not un-associate any already associated instance\n     * that may be missing from `newInstances`.\n     *\n     * @param {Model} sourceInstance source instance to associate new instances with\n     * @param {Model|Model[]|string[]|string|number[]|number} [newInstances] A single instance or primary key, or a mixed array of persisted instances or primary keys\n     * @param {Object} [options] Options passed to `through.findAll`, `bulkCreate` and `update`\n     * @param {Object} [options.validate] Run validation for the join model.\n     * @param {Object} [options.through] Additional attributes for the join table.\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(sourceInstance, newInstances, options) {\n      var _where3;\n\n      // If newInstances is null or undefined, no-op\n      if (!newInstances) return Utils.Promise.resolve();\n      options = _.clone(options) || {};\n      var association = this;\n      var sourceKey = association.sourceKey;\n      var targetKey = association.targetKey;\n      var identifier = association.identifier;\n      var foreignIdentifier = association.foreignIdentifier;\n      var defaultAttributes = options.through || {};\n      newInstances = association.toInstanceArray(newInstances);\n      var where = (_where3 = {}, _defineProperty(_where3, identifier, sourceInstance.get(sourceKey)), _defineProperty(_where3, foreignIdentifier, newInstances.map(function (newInstance) {\n        return newInstance.get(targetKey);\n      })), _where3);\n      Object.assign(where, association.through.scope);\n\n      var updateAssociations = function updateAssociations(currentRows) {\n        var promises = [];\n        var unassociatedObjects = [];\n        var changedAssociations = [];\n\n        var _iterator2 = _createForOfIteratorHelper(newInstances),\n            _step2;\n\n        try {\n          var _loop2 = function _loop2() {\n            var obj = _step2.value;\n            var existingAssociation = currentRows && currentRows.find(function (current) {\n              return current[foreignIdentifier] === obj.get(targetKey);\n            });\n\n            if (!existingAssociation) {\n              unassociatedObjects.push(obj);\n            } else {\n              var _throughAttributes = obj[association.through.model.name];\n\n              var _attributes = _.defaults({}, _throughAttributes, defaultAttributes);\n\n              if (Object.keys(_attributes).some(function (attribute) {\n                return _attributes[attribute] !== existingAssociation[attribute];\n              })) {\n                changedAssociations.push(obj);\n              }\n            }\n          };\n\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            _loop2();\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        if (unassociatedObjects.length > 0) {\n          var bulk = unassociatedObjects.map(function (unassociatedObject) {\n            var throughAttributes = unassociatedObject[association.through.model.name];\n\n            var attributes = _.defaults({}, throughAttributes, defaultAttributes);\n\n            attributes[identifier] = sourceInstance.get(sourceKey);\n            attributes[foreignIdentifier] = unassociatedObject.get(targetKey);\n            Object.assign(attributes, association.through.scope);\n            return attributes;\n          });\n          promises.push(association.through.model.bulkCreate(bulk, Object.assign({\n            validate: true\n          }, options)));\n        }\n\n        for (var _i = 0, _changedAssociations = changedAssociations; _i < _changedAssociations.length; _i++) {\n          var _where5;\n\n          var assoc = _changedAssociations[_i];\n          var throughAttributes = assoc[association.through.model.name];\n\n          var attributes = _.defaults({}, throughAttributes, defaultAttributes); // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)\n\n\n          if (throughAttributes instanceof association.through.model) {\n            throughAttributes = {};\n          }\n\n          var _where4 = (_where5 = {}, _defineProperty(_where5, identifier, sourceInstance.get(sourceKey)), _defineProperty(_where5, foreignIdentifier, assoc.get(targetKey)), _where5);\n\n          promises.push(association.through.model.update(attributes, Object.assign(options, {\n            where: _where4\n          })));\n        }\n\n        return Utils.Promise.all(promises);\n      };\n\n      return association.through.model.findAll(_.defaults({\n        where: where,\n        raw: true\n      }, options)).then(function (currentRows) {\n        return updateAssociations(currentRows);\n      }).then(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 1),\n            associations = _ref4[0];\n\n        return associations;\n      }).catch(function (error) {\n        if (error instanceof EmptyResultError) return updateAssociations();\n        throw error;\n      });\n    }\n    /**\n     * Un-associate one or more instance(s).\n     *\n     * @param {Model} sourceInstance instance to un associate instances with\n     * @param {Model|Model[]|string|string[]|number|number[]} [oldAssociatedObjects] Can be an Instance or its primary key, or a mixed array of instances and primary keys\n     * @param {Object} [options] Options passed to `through.destroy`\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(sourceInstance, oldAssociatedObjects, options) {\n      var _where6;\n\n      var association = this;\n      options = options || {};\n      oldAssociatedObjects = association.toInstanceArray(oldAssociatedObjects);\n      var where = (_where6 = {}, _defineProperty(_where6, association.identifier, sourceInstance.get(association.sourceKey)), _defineProperty(_where6, association.foreignIdentifier, oldAssociatedObjects.map(function (newInstance) {\n        return newInstance.get(association.targetKey);\n      })), _where6);\n      return association.through.model.destroy(_.defaults({\n        where: where\n      }, options));\n    }\n    /**\n     * Create a new instance of the associated model and associate it with this.\n     *\n     * @param {Model} sourceInstance source instance\n     * @param {Object} [values] values for target model\n     * @param {Object} [options] Options passed to create and add\n     * @param {Object} [options.through] Additional attributes for the join table\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"create\",\n    value: function create(sourceInstance, values, options) {\n      var association = this;\n      options = options || {};\n      values = values || {};\n\n      if (Array.isArray(options)) {\n        options = {\n          fields: options\n        };\n      }\n\n      if (association.scope) {\n        Object.assign(values, association.scope);\n\n        if (options.fields) {\n          options.fields = options.fields.concat(Object.keys(association.scope));\n        }\n      } // Create the related model instance\n\n\n      return association.target.create(values, options).then(function (newAssociatedObject) {\n        return sourceInstance[association.accessors.add](newAssociatedObject, _.omit(options, ['fields'])).return(newAssociatedObject);\n      });\n    }\n  }, {\n    key: \"verifyAssociationAlias\",\n    value: function verifyAssociationAlias(alias) {\n      if (typeof alias === 'string') {\n        return this.as === alias;\n      }\n\n      if (alias && alias.plural) {\n        return this.as === alias.plural;\n      }\n\n      return !this.isAliased;\n    }\n  }]);\n\n  return BelongsToMany;\n}(Association);\n\nmodule.exports = BelongsToMany;\nmodule.exports.BelongsToMany = BelongsToMany;\nmodule.exports.default = BelongsToMany;","map":null,"metadata":{},"sourceType":"script"}