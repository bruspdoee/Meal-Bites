{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Pool = void 0;\n\nvar Deferred_1 = require(\"./Deferred\");\n\nvar AggregateError_1 = require(\"./AggregateError\");\n\nvar Pool = /*#__PURE__*/function () {\n  function Pool(factory) {\n    _classCallCheck(this, Pool);\n\n    this.log = false;\n\n    if (!factory.create) {\n      throw new Error('create function is required');\n    }\n\n    if (!factory.destroy) {\n      throw new Error('destroy function is required');\n    }\n\n    if (!factory.validate) {\n      throw new Error('validate function is required');\n    }\n\n    if (typeof factory.min !== 'number' || factory.min < 0 || factory.min !== Math.round(factory.min)) {\n      throw new Error('min must be an integer >= 0');\n    }\n\n    if (typeof factory.max !== 'number' || factory.max <= 0 || factory.max !== Math.round(factory.max)) {\n      throw new Error('max must be an integer > 0');\n    }\n\n    if (factory.min > factory.max) {\n      throw new Error('max is smaller than min');\n    }\n\n    if (factory.maxUses !== undefined && (typeof factory.maxUses !== 'number' || factory.maxUses < 0)) {\n      throw new Error('maxUses must be an integer >= 0');\n    }\n\n    this.idleTimeoutMillis = factory.idleTimeoutMillis || 30000;\n    this.acquireTimeoutMillis = factory.acquireTimeoutMillis || 30000;\n    this.reapIntervalMillis = factory.reapIntervalMillis || 1000;\n    this.maxUsesPerResource = factory.maxUses || Infinity;\n    this.log = factory.log || false;\n    this._factory = factory;\n    this._count = 0;\n    this._draining = false;\n    this._pendingAcquires = [];\n    this._inUseObjects = [];\n    this._availableObjects = [];\n    this._removeIdleScheduled = false;\n  }\n\n  _createClass(Pool, [{\n    key: \"_log\",\n    value: function _log(message, level) {\n      if (typeof this.log === 'function') {\n        this.log(message, level);\n      } else if (this.log) {\n        console.log(\"\".concat(level.toUpperCase(), \" pool \").concat(this.name || '', \" - \").concat(message));\n      }\n    }\n  }, {\n    key: \"_removeIdle\",\n    value: function _removeIdle() {\n      var toRemove = [];\n      var now = Date.now();\n      var i;\n      var available = this._availableObjects.length;\n      var maxRemovable = this.size - this.minSize;\n      var timeout;\n      this._removeIdleScheduled = false;\n\n      for (i = 0; i < available && maxRemovable > toRemove.length; i++) {\n        timeout = this._availableObjects[i].timeout;\n\n        if (now >= timeout) {\n          this._log('removeIdle() destroying obj - now:' + now + ' timeout:' + timeout, 'verbose');\n\n          toRemove.push(this._availableObjects[i].resource);\n        }\n      }\n\n      toRemove.forEach(this.destroy, this);\n      available = this._availableObjects.length;\n\n      if (available > 0) {\n        this._log('this._availableObjects.length=' + available, 'verbose');\n\n        this._scheduleRemoveIdle();\n      } else {\n        this._log('removeIdle() all objects removed', 'verbose');\n      }\n    }\n  }, {\n    key: \"_scheduleRemoveIdle\",\n    value: function _scheduleRemoveIdle() {\n      var _this = this;\n\n      if (!this._removeIdleScheduled) {\n        this._removeIdleScheduled = true;\n        this._removeIdleTimer = setTimeout(function () {\n          _this._removeIdle();\n        }, this.reapIntervalMillis);\n      }\n    }\n  }, {\n    key: \"_dispense\",\n    value: function _dispense() {\n      var wrappedResource = null;\n      var waitingCount = this._pendingAcquires.length;\n\n      this._log(\"dispense() clients=\".concat(waitingCount, \" available=\").concat(this._availableObjects.length), 'info');\n\n      if (waitingCount < 1) {\n        return;\n      }\n\n      while (this._availableObjects.length > 0) {\n        this._log('dispense() - reusing obj', 'verbose');\n\n        wrappedResource = this._availableObjects[this._availableObjects.length - 1];\n\n        if (!this._factory.validate(wrappedResource.resource)) {\n          this.destroy(wrappedResource.resource);\n          continue;\n        }\n\n        this._availableObjects.pop();\n\n        this._addResourceToInUseObjects(wrappedResource.resource, wrappedResource.useCount);\n\n        var deferred = this._pendingAcquires.shift();\n\n        return deferred.resolve(wrappedResource.resource);\n      }\n\n      if (this.size < this.maxSize) {\n        this._createResource();\n      }\n    }\n  }, {\n    key: \"_createResource\",\n    value: function _createResource() {\n      var _this2 = this;\n\n      this._count += 1;\n\n      this._log(\"createResource() - creating obj - count=\".concat(this.size, \" min=\").concat(this.minSize, \" max=\").concat(this.maxSize), 'verbose');\n\n      this._factory.create().then(function (resource) {\n        var deferred = _this2._pendingAcquires.shift();\n\n        if (deferred) {\n          _this2._addResourceToInUseObjects(resource, 0);\n\n          deferred.resolve(resource);\n        } else {\n          _this2._addResourceToAvailableObjects(resource, 0);\n        }\n      }).catch(function (error) {\n        var deferred = _this2._pendingAcquires.shift();\n\n        _this2._count -= 1;\n        if (_this2._count < 0) _this2._count = 0;\n\n        if (deferred) {\n          deferred.reject(error);\n        }\n\n        process.nextTick(function () {\n          _this2._dispense();\n        });\n      });\n    }\n  }, {\n    key: \"_addResourceToAvailableObjects\",\n    value: function _addResourceToAvailableObjects(resource, useCount) {\n      var wrappedResource = {\n        resource: resource,\n        useCount: useCount,\n        timeout: Date.now() + this.idleTimeoutMillis\n      };\n\n      this._availableObjects.push(wrappedResource);\n\n      this._dispense();\n\n      this._scheduleRemoveIdle();\n    }\n  }, {\n    key: \"_addResourceToInUseObjects\",\n    value: function _addResourceToInUseObjects(resource, useCount) {\n      var wrappedResource = {\n        resource: resource,\n        useCount: useCount\n      };\n\n      this._inUseObjects.push(wrappedResource);\n    }\n  }, {\n    key: \"_ensureMinimum\",\n    value: function _ensureMinimum() {\n      var i, diff;\n\n      if (!this._draining && this.size < this.minSize) {\n        diff = this.minSize - this.size;\n\n        for (i = 0; i < diff; i++) {\n          this._createResource();\n        }\n      }\n    }\n  }, {\n    key: \"acquire\",\n    value: function acquire() {\n      var _this3 = this;\n\n      if (this._draining) {\n        return Promise.reject(new Error('pool is draining and cannot accept work'));\n      }\n\n      var deferred = new Deferred_1.Deferred();\n      deferred.registerTimeout(this.acquireTimeoutMillis, function () {\n        _this3._pendingAcquires = _this3._pendingAcquires.filter(function (pending) {\n          return pending !== deferred;\n        });\n      });\n\n      this._pendingAcquires.push(deferred);\n\n      this._dispense();\n\n      return deferred.promise();\n    }\n  }, {\n    key: \"release\",\n    value: function release(resource) {\n      if (this._availableObjects.some(function (resourceWithTimeout) {\n        return resourceWithTimeout.resource === resource;\n      })) {\n        this._log('release called twice for the same resource: ' + new Error().stack, 'error');\n\n        return;\n      }\n\n      var index = this._inUseObjects.findIndex(function (wrappedResource) {\n        return wrappedResource.resource === resource;\n      });\n\n      if (index < 0) {\n        this._log('attempt to release an invalid resource: ' + new Error().stack, 'error');\n\n        return;\n      }\n\n      var wrappedResource = this._inUseObjects[index];\n      wrappedResource.useCount += 1;\n\n      if (wrappedResource.useCount >= this.maxUsesPerResource) {\n        this._log('release() destroying obj - useCount:' + wrappedResource.useCount + ' maxUsesPerResource:' + this.maxUsesPerResource, 'verbose');\n\n        this.destroy(wrappedResource.resource);\n\n        this._dispense();\n      } else {\n        this._inUseObjects.splice(index, 1);\n\n        this._addResourceToAvailableObjects(wrappedResource.resource, wrappedResource.useCount);\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(resource) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var available, using;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                available = this._availableObjects.length;\n                using = this._inUseObjects.length;\n                this._availableObjects = this._availableObjects.filter(function (object) {\n                  return object.resource !== resource;\n                });\n                this._inUseObjects = this._inUseObjects.filter(function (object) {\n                  return object.resource !== resource;\n                });\n\n                if (!(available === this._availableObjects.length && using === this._inUseObjects.length)) {\n                  _context.next = 7;\n                  break;\n                }\n\n                this._ensureMinimum();\n\n                return _context.abrupt(\"return\");\n\n              case 7:\n                this._count -= 1;\n                if (this._count < 0) this._count = 0;\n                _context.prev = 9;\n                _context.next = 12;\n                return this._factory.destroy(resource);\n\n              case 12:\n                _context.prev = 12;\n\n                this._ensureMinimum();\n\n                return _context.finish(12);\n\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[9,, 12, 15]]);\n      }));\n    }\n  }, {\n    key: \"drain\",\n    value: function drain() {\n      var _this4 = this;\n\n      this._log('draining', 'info');\n\n      this._draining = true;\n\n      var check = function check(callback) {\n        if (_this4._pendingAcquires.length > 0) {\n          _this4._dispense();\n\n          setTimeout(function () {\n            check(callback);\n          }, 100);\n          return;\n        }\n\n        if (_this4._availableObjects.length !== _this4._count) {\n          setTimeout(function () {\n            check(callback);\n          }, 100);\n          return;\n        }\n\n        callback();\n      };\n\n      return new Promise(function (resolve) {\n        return check(resolve);\n      });\n    }\n  }, {\n    key: \"destroyAllNow\",\n    value: function destroyAllNow() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var resources, errors, _iterator, _step, resource;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this._log('force destroying all objects', 'info');\n\n                this._removeIdleScheduled = false;\n                clearTimeout(this._removeIdleTimer);\n                resources = this._availableObjects.map(function (resource) {\n                  return resource.resource;\n                });\n                errors = [];\n                _iterator = _createForOfIteratorHelper(resources);\n                _context2.prev = 6;\n\n                _iterator.s();\n\n              case 8:\n                if ((_step = _iterator.n()).done) {\n                  _context2.next = 21;\n                  break;\n                }\n\n                resource = _step.value;\n                _context2.prev = 10;\n                _context2.next = 13;\n                return this.destroy(resource);\n\n              case 13:\n                _context2.next = 19;\n                break;\n\n              case 15:\n                _context2.prev = 15;\n                _context2.t0 = _context2[\"catch\"](10);\n\n                this._log('Error destroying resource: ' + _context2.t0.stack, 'error');\n\n                errors.push(_context2.t0);\n\n              case 19:\n                _context2.next = 8;\n                break;\n\n              case 21:\n                _context2.next = 26;\n                break;\n\n              case 23:\n                _context2.prev = 23;\n                _context2.t1 = _context2[\"catch\"](6);\n\n                _iterator.e(_context2.t1);\n\n              case 26:\n                _context2.prev = 26;\n\n                _iterator.f();\n\n                return _context2.finish(26);\n\n              case 29:\n                if (!(errors.length > 0)) {\n                  _context2.next = 31;\n                  break;\n                }\n\n                throw new AggregateError_1.AggregateError(errors);\n\n              case 31:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[6, 23, 26, 29], [10, 15]]);\n      }));\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._count;\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return this._factory.name;\n    }\n  }, {\n    key: \"available\",\n    get: function get() {\n      return this._availableObjects.length;\n    }\n  }, {\n    key: \"using\",\n    get: function get() {\n      return this._inUseObjects.length;\n    }\n  }, {\n    key: \"waiting\",\n    get: function get() {\n      return this._pendingAcquires.length;\n    }\n  }, {\n    key: \"maxSize\",\n    get: function get() {\n      return this._factory.max;\n    }\n  }, {\n    key: \"minSize\",\n    get: function get() {\n      return this._factory.min;\n    }\n  }]);\n\n  return Pool;\n}();\n\nexports.Pool = Pool;","map":null,"metadata":{},"sourceType":"script"}