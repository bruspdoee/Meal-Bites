{"ast":null,"code":"'use strict';\n\nvar _assertThisInitialized = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _get = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _ = require('lodash');\n\nvar wkx = require('wkx');\n\nmodule.exports = function (BaseTypes) {\n  var warn = BaseTypes.ABSTRACT.warn.bind(undefined, 'http://www.postgresql.org/docs/9.4/static/datatype.html');\n  /**\n   * Removes unsupported Postgres options, i.e., LENGTH, UNSIGNED and ZEROFILL, for the integer data types.\n   *\n   * @param {object} dataType The base integer data type.\n   * @private\n   */\n\n  function removeUnsupportedIntegerOptions(dataType) {\n    if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {\n      warn(\"PostgresSQL does not support '\".concat(dataType.key, \"' with LENGTH, UNSIGNED or ZEROFILL. Plain '\").concat(dataType.key, \"' will be used instead.\"));\n      dataType._length = undefined;\n      dataType.options.length = undefined;\n      dataType._unsigned = undefined;\n      dataType._zerofill = undefined;\n    }\n  }\n  /**\n   * types:\n   * {\n   *   oids: [oid],\n   *   array_oids: [oid]\n   * }\n   *\n   * @see oid here https://github.com/lib/pq/blob/master/oid/types.go\n   */\n\n\n  BaseTypes.UUID.types.postgres = ['uuid'];\n  BaseTypes.CIDR.types.postgres = ['cidr'];\n  BaseTypes.INET.types.postgres = ['inet'];\n  BaseTypes.MACADDR.types.postgres = ['macaddr'];\n  BaseTypes.JSON.types.postgres = ['json'];\n  BaseTypes.JSONB.types.postgres = ['jsonb'];\n  BaseTypes.TIME.types.postgres = ['time'];\n\n  var DATEONLY = /*#__PURE__*/function (_BaseTypes$DATEONLY) {\n    _inherits(DATEONLY, _BaseTypes$DATEONLY);\n\n    function DATEONLY() {\n      _classCallCheck(this, DATEONLY);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(DATEONLY).apply(this, arguments));\n    }\n\n    _createClass(DATEONLY, [{\n      key: \"_stringify\",\n      value: function _stringify(value, options) {\n        if (value === Infinity) {\n          return 'Infinity';\n        }\n\n        if (value === -Infinity) {\n          return '-Infinity';\n        }\n\n        return _get(_getPrototypeOf(DATEONLY.prototype), \"_stringify\", this).call(this, value, options);\n      }\n    }, {\n      key: \"_sanitize\",\n      value: function _sanitize(value, options) {\n        if ((!options || options && !options.raw) && value !== Infinity && value !== -Infinity) {\n          if (typeof value === 'string') {\n            var lower = value.toLowerCase();\n\n            if (lower === 'infinity') {\n              return Infinity;\n            }\n\n            if (lower === '-infinity') {\n              return -Infinity;\n            }\n          }\n\n          return _get(_getPrototypeOf(DATEONLY.prototype), \"_sanitize\", this).call(this, value);\n        }\n\n        return value;\n      }\n    }], [{\n      key: \"parse\",\n      value: function parse(value) {\n        if (value === 'infinity') {\n          return Infinity;\n        }\n\n        if (value === '-infinity') {\n          return -Infinity;\n        }\n\n        return value;\n      }\n    }]);\n\n    return DATEONLY;\n  }(BaseTypes.DATEONLY);\n\n  BaseTypes.DATEONLY.types.postgres = ['date'];\n\n  var DECIMAL = /*#__PURE__*/function (_BaseTypes$DECIMAL) {\n    _inherits(DECIMAL, _BaseTypes$DECIMAL);\n\n    function DECIMAL() {\n      _classCallCheck(this, DECIMAL);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(DECIMAL).apply(this, arguments));\n    }\n\n    _createClass(DECIMAL, null, [{\n      key: \"parse\",\n      value: function parse(value) {\n        return value;\n      }\n    }]);\n\n    return DECIMAL;\n  }(BaseTypes.DECIMAL); // numeric\n\n\n  BaseTypes.DECIMAL.types.postgres = ['numeric'];\n\n  var STRING = /*#__PURE__*/function (_BaseTypes$STRING) {\n    _inherits(STRING, _BaseTypes$STRING);\n\n    function STRING() {\n      _classCallCheck(this, STRING);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(STRING).apply(this, arguments));\n    }\n\n    _createClass(STRING, [{\n      key: \"toSql\",\n      value: function toSql() {\n        if (this._binary) {\n          return 'BYTEA';\n        }\n\n        return _get(_getPrototypeOf(STRING.prototype), \"toSql\", this).call(this);\n      }\n    }]);\n\n    return STRING;\n  }(BaseTypes.STRING);\n\n  BaseTypes.STRING.types.postgres = ['varchar'];\n\n  var TEXT = /*#__PURE__*/function (_BaseTypes$TEXT) {\n    _inherits(TEXT, _BaseTypes$TEXT);\n\n    function TEXT() {\n      _classCallCheck(this, TEXT);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(TEXT).apply(this, arguments));\n    }\n\n    _createClass(TEXT, [{\n      key: \"toSql\",\n      value: function toSql() {\n        if (this._length) {\n          warn('PostgreSQL does not support TEXT with options. Plain `TEXT` will be used instead.');\n          this._length = undefined;\n        }\n\n        return 'TEXT';\n      }\n    }]);\n\n    return TEXT;\n  }(BaseTypes.TEXT);\n\n  BaseTypes.TEXT.types.postgres = ['text'];\n\n  var CITEXT = /*#__PURE__*/function (_BaseTypes$CITEXT) {\n    _inherits(CITEXT, _BaseTypes$CITEXT);\n\n    function CITEXT() {\n      _classCallCheck(this, CITEXT);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(CITEXT).apply(this, arguments));\n    }\n\n    _createClass(CITEXT, null, [{\n      key: \"parse\",\n      value: function parse(value) {\n        return value;\n      }\n    }]);\n\n    return CITEXT;\n  }(BaseTypes.CITEXT);\n\n  BaseTypes.CITEXT.types.postgres = ['citext'];\n\n  var CHAR = /*#__PURE__*/function (_BaseTypes$CHAR) {\n    _inherits(CHAR, _BaseTypes$CHAR);\n\n    function CHAR() {\n      _classCallCheck(this, CHAR);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(CHAR).apply(this, arguments));\n    }\n\n    _createClass(CHAR, [{\n      key: \"toSql\",\n      value: function toSql() {\n        if (this._binary) {\n          return 'BYTEA';\n        }\n\n        return _get(_getPrototypeOf(CHAR.prototype), \"toSql\", this).call(this);\n      }\n    }]);\n\n    return CHAR;\n  }(BaseTypes.CHAR);\n\n  BaseTypes.CHAR.types.postgres = ['char', 'bpchar'];\n\n  var BOOLEAN = /*#__PURE__*/function (_BaseTypes$BOOLEAN) {\n    _inherits(BOOLEAN, _BaseTypes$BOOLEAN);\n\n    function BOOLEAN() {\n      _classCallCheck(this, BOOLEAN);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(BOOLEAN).apply(this, arguments));\n    }\n\n    _createClass(BOOLEAN, [{\n      key: \"toSql\",\n      value: function toSql() {\n        return 'BOOLEAN';\n      }\n    }, {\n      key: \"_sanitize\",\n      value: function _sanitize(value) {\n        if (value !== null && value !== undefined) {\n          if (Buffer.isBuffer(value) && value.length === 1) {\n            // Bit fields are returned as buffers\n            value = value[0];\n          }\n\n          if (typeof value === 'string') {\n            // Only take action on valid boolean strings.\n            return value === 'true' || value === 't' ? true : value === 'false' || value === 'f' ? false : value;\n          }\n\n          if (typeof value === 'number') {\n            // Only take action on valid boolean integers.\n            return value === 1 ? true : value === 0 ? false : value;\n          }\n        }\n\n        return value;\n      }\n    }]);\n\n    return BOOLEAN;\n  }(BaseTypes.BOOLEAN);\n\n  BOOLEAN.parse = BOOLEAN.prototype._sanitize;\n  BaseTypes.BOOLEAN.types.postgres = ['bool'];\n\n  var DATE = /*#__PURE__*/function (_BaseTypes$DATE) {\n    _inherits(DATE, _BaseTypes$DATE);\n\n    function DATE() {\n      _classCallCheck(this, DATE);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(DATE).apply(this, arguments));\n    }\n\n    _createClass(DATE, [{\n      key: \"toSql\",\n      value: function toSql() {\n        return 'TIMESTAMP WITH TIME ZONE';\n      }\n    }, {\n      key: \"validate\",\n      value: function validate(value) {\n        if (value !== Infinity && value !== -Infinity) {\n          return _get(_getPrototypeOf(DATE.prototype), \"validate\", this).call(this, value);\n        }\n\n        return true;\n      }\n    }, {\n      key: \"_stringify\",\n      value: function _stringify(value, options) {\n        if (value === Infinity) {\n          return 'Infinity';\n        }\n\n        if (value === -Infinity) {\n          return '-Infinity';\n        }\n\n        return _get(_getPrototypeOf(DATE.prototype), \"_stringify\", this).call(this, value, options);\n      }\n    }, {\n      key: \"_sanitize\",\n      value: function _sanitize(value, options) {\n        if ((!options || options && !options.raw) && !(value instanceof Date) && !!value && value !== Infinity && value !== -Infinity) {\n          if (typeof value === 'string') {\n            var lower = value.toLowerCase();\n\n            if (lower === 'infinity') {\n              return Infinity;\n            }\n\n            if (lower === '-infinity') {\n              return -Infinity;\n            }\n          }\n\n          return new Date(value);\n        }\n\n        return value;\n      }\n    }]);\n\n    return DATE;\n  }(BaseTypes.DATE);\n\n  BaseTypes.DATE.types.postgres = ['timestamptz'];\n\n  var TINYINT = /*#__PURE__*/function (_BaseTypes$TINYINT) {\n    _inherits(TINYINT, _BaseTypes$TINYINT);\n\n    function TINYINT(length) {\n      var _this;\n\n      _classCallCheck(this, TINYINT);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(TINYINT).call(this, length));\n      removeUnsupportedIntegerOptions(_assertThisInitialized(_assertThisInitialized(_this)));\n      return _this;\n    }\n\n    return TINYINT;\n  }(BaseTypes.TINYINT); // int2\n\n\n  BaseTypes.TINYINT.types.postgres = ['int2'];\n\n  var SMALLINT = /*#__PURE__*/function (_BaseTypes$SMALLINT) {\n    _inherits(SMALLINT, _BaseTypes$SMALLINT);\n\n    function SMALLINT(length) {\n      var _this2;\n\n      _classCallCheck(this, SMALLINT);\n\n      _this2 = _possibleConstructorReturn(this, _getPrototypeOf(SMALLINT).call(this, length));\n      removeUnsupportedIntegerOptions(_assertThisInitialized(_assertThisInitialized(_this2)));\n      return _this2;\n    }\n\n    return SMALLINT;\n  }(BaseTypes.SMALLINT); // int2\n\n\n  BaseTypes.SMALLINT.types.postgres = ['int2'];\n\n  var INTEGER = /*#__PURE__*/function (_BaseTypes$INTEGER) {\n    _inherits(INTEGER, _BaseTypes$INTEGER);\n\n    function INTEGER(length) {\n      var _this3;\n\n      _classCallCheck(this, INTEGER);\n\n      _this3 = _possibleConstructorReturn(this, _getPrototypeOf(INTEGER).call(this, length));\n      removeUnsupportedIntegerOptions(_assertThisInitialized(_assertThisInitialized(_this3)));\n      return _this3;\n    }\n\n    return INTEGER;\n  }(BaseTypes.INTEGER);\n\n  INTEGER.parse = function parse(value) {\n    return parseInt(value, 10);\n  }; // int4\n\n\n  BaseTypes.INTEGER.types.postgres = ['int4'];\n\n  var BIGINT = /*#__PURE__*/function (_BaseTypes$BIGINT) {\n    _inherits(BIGINT, _BaseTypes$BIGINT);\n\n    function BIGINT(length) {\n      var _this4;\n\n      _classCallCheck(this, BIGINT);\n\n      _this4 = _possibleConstructorReturn(this, _getPrototypeOf(BIGINT).call(this, length));\n      removeUnsupportedIntegerOptions(_assertThisInitialized(_assertThisInitialized(_this4)));\n      return _this4;\n    }\n\n    return BIGINT;\n  }(BaseTypes.BIGINT); // int8\n\n\n  BaseTypes.BIGINT.types.postgres = ['int8'];\n\n  var REAL = /*#__PURE__*/function (_BaseTypes$REAL) {\n    _inherits(REAL, _BaseTypes$REAL);\n\n    function REAL(length) {\n      var _this5;\n\n      _classCallCheck(this, REAL);\n\n      _this5 = _possibleConstructorReturn(this, _getPrototypeOf(REAL).call(this, length));\n      removeUnsupportedIntegerOptions(_assertThisInitialized(_assertThisInitialized(_this5)));\n      return _this5;\n    }\n\n    return REAL;\n  }(BaseTypes.REAL); // float4\n\n\n  BaseTypes.REAL.types.postgres = ['float4'];\n\n  var DOUBLE = /*#__PURE__*/function (_BaseTypes$DOUBLE) {\n    _inherits(DOUBLE, _BaseTypes$DOUBLE);\n\n    function DOUBLE(length) {\n      var _this6;\n\n      _classCallCheck(this, DOUBLE);\n\n      _this6 = _possibleConstructorReturn(this, _getPrototypeOf(DOUBLE).call(this, length));\n      removeUnsupportedIntegerOptions(_assertThisInitialized(_assertThisInitialized(_this6)));\n      return _this6;\n    }\n\n    return DOUBLE;\n  }(BaseTypes.DOUBLE); // float8\n\n\n  BaseTypes.DOUBLE.types.postgres = ['float8'];\n\n  var FLOAT = /*#__PURE__*/function (_BaseTypes$FLOAT) {\n    _inherits(FLOAT, _BaseTypes$FLOAT);\n\n    function FLOAT(length, decimals) {\n      var _this7;\n\n      _classCallCheck(this, FLOAT);\n\n      _this7 = _possibleConstructorReturn(this, _getPrototypeOf(FLOAT).call(this, length, decimals)); // POSTGRES does only support lengths as parameter.\n      // Values between 1-24 result in REAL\n      // Values between 25-53 result in DOUBLE PRECISION\n      // If decimals are provided remove these and print a warning\n\n      if (_this7._decimals) {\n        warn('PostgreSQL does not support FLOAT with decimals. Plain `FLOAT` will be used instead.');\n        _this7._length = undefined;\n        _this7.options.length = undefined;\n        _this7._decimals = undefined;\n      }\n\n      if (_this7._unsigned) {\n        warn('PostgreSQL does not support FLOAT unsigned. `UNSIGNED` was removed.');\n        _this7._unsigned = undefined;\n      }\n\n      if (_this7._zerofill) {\n        warn('PostgreSQL does not support FLOAT zerofill. `ZEROFILL` was removed.');\n        _this7._zerofill = undefined;\n      }\n\n      return _this7;\n    }\n\n    return FLOAT;\n  }(BaseTypes.FLOAT);\n\n  delete FLOAT.parse; // Float has no separate type in PG\n\n  var BLOB = /*#__PURE__*/function (_BaseTypes$BLOB) {\n    _inherits(BLOB, _BaseTypes$BLOB);\n\n    function BLOB() {\n      _classCallCheck(this, BLOB);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(BLOB).apply(this, arguments));\n    }\n\n    _createClass(BLOB, [{\n      key: \"toSql\",\n      value: function toSql() {\n        if (this._length) {\n          warn('PostgreSQL does not support BLOB (BYTEA) with options. Plain `BYTEA` will be used instead.');\n          this._length = undefined;\n        }\n\n        return 'BYTEA';\n      }\n    }, {\n      key: \"_hexify\",\n      value: function _hexify(hex) {\n        // bytea hex format http://www.postgresql.org/docs/current/static/datatype-binary.html\n        return \"E'\\\\\\\\x\".concat(hex, \"'\");\n      }\n    }]);\n\n    return BLOB;\n  }(BaseTypes.BLOB);\n\n  BaseTypes.BLOB.types.postgres = ['bytea'];\n\n  var GEOMETRY = /*#__PURE__*/function (_BaseTypes$GEOMETRY) {\n    _inherits(GEOMETRY, _BaseTypes$GEOMETRY);\n\n    function GEOMETRY() {\n      _classCallCheck(this, GEOMETRY);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(GEOMETRY).apply(this, arguments));\n    }\n\n    _createClass(GEOMETRY, [{\n      key: \"toSql\",\n      value: function toSql() {\n        var result = this.key;\n\n        if (this.type) {\n          result += \"(\".concat(this.type);\n\n          if (this.srid) {\n            result += \",\".concat(this.srid);\n          }\n\n          result += ')';\n        }\n\n        return result;\n      }\n    }, {\n      key: \"_stringify\",\n      value: function _stringify(value, options) {\n        return \"ST_GeomFromGeoJSON(\".concat(options.escape(JSON.stringify(value)), \")\");\n      }\n    }, {\n      key: \"_bindParam\",\n      value: function _bindParam(value, options) {\n        return \"ST_GeomFromGeoJSON(\".concat(options.bindParam(value), \")\");\n      }\n    }], [{\n      key: \"parse\",\n      value: function parse(value) {\n        var b = Buffer.from(value, 'hex');\n        return wkx.Geometry.parse(b).toGeoJSON({\n          shortCrs: true\n        });\n      }\n    }]);\n\n    return GEOMETRY;\n  }(BaseTypes.GEOMETRY);\n\n  BaseTypes.GEOMETRY.types.postgres = ['geometry'];\n\n  var GEOGRAPHY = /*#__PURE__*/function (_BaseTypes$GEOGRAPHY) {\n    _inherits(GEOGRAPHY, _BaseTypes$GEOGRAPHY);\n\n    function GEOGRAPHY() {\n      _classCallCheck(this, GEOGRAPHY);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(GEOGRAPHY).apply(this, arguments));\n    }\n\n    _createClass(GEOGRAPHY, [{\n      key: \"toSql\",\n      value: function toSql() {\n        var result = 'GEOGRAPHY';\n\n        if (this.type) {\n          result += \"(\".concat(this.type);\n\n          if (this.srid) {\n            result += \",\".concat(this.srid);\n          }\n\n          result += ')';\n        }\n\n        return result;\n      }\n    }, {\n      key: \"_stringify\",\n      value: function _stringify(value, options) {\n        return \"ST_GeomFromGeoJSON(\".concat(options.escape(JSON.stringify(value)), \")\");\n      }\n    }, {\n      key: \"bindParam\",\n      value: function bindParam(value, options) {\n        return \"ST_GeomFromGeoJSON(\".concat(options.bindParam(value), \")\");\n      }\n    }], [{\n      key: \"parse\",\n      value: function parse(value) {\n        var b = Buffer.from(value, 'hex');\n        return wkx.Geometry.parse(b).toGeoJSON({\n          shortCrs: true\n        });\n      }\n    }]);\n\n    return GEOGRAPHY;\n  }(BaseTypes.GEOGRAPHY);\n\n  BaseTypes.GEOGRAPHY.types.postgres = ['geography'];\n  var hstore;\n\n  var HSTORE = /*#__PURE__*/function (_BaseTypes$HSTORE) {\n    _inherits(HSTORE, _BaseTypes$HSTORE);\n\n    function HSTORE() {\n      var _this8;\n\n      _classCallCheck(this, HSTORE);\n\n      _this8 = _possibleConstructorReturn(this, _getPrototypeOf(HSTORE).call(this));\n\n      if (!hstore) {\n        // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated\n        hstore = require('./hstore');\n      }\n\n      return _this8;\n    }\n\n    _createClass(HSTORE, [{\n      key: \"_value\",\n      value: function _value(value) {\n        if (!hstore) {\n          // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated\n          hstore = require('./hstore');\n        }\n\n        return hstore.stringify(value);\n      }\n    }, {\n      key: \"_stringify\",\n      value: function _stringify(value) {\n        return \"'\".concat(this._value(value), \"'\");\n      }\n    }, {\n      key: \"_bindParam\",\n      value: function _bindParam(value, options) {\n        return options.bindParam(this._value(value));\n      }\n    }], [{\n      key: \"parse\",\n      value: function parse(value) {\n        if (!hstore) {\n          // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated\n          hstore = require('./hstore');\n        }\n\n        return hstore.parse(value);\n      }\n    }]);\n\n    return HSTORE;\n  }(BaseTypes.HSTORE);\n\n  HSTORE.prototype.escape = false;\n  BaseTypes.HSTORE.types.postgres = ['hstore'];\n\n  var RANGE = /*#__PURE__*/function (_BaseTypes$RANGE) {\n    _inherits(RANGE, _BaseTypes$RANGE);\n\n    function RANGE() {\n      _classCallCheck(this, RANGE);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(RANGE).apply(this, arguments));\n    }\n\n    _createClass(RANGE, [{\n      key: \"_value\",\n      value: function _value(values, options) {\n        var _this9 = this;\n\n        if (!Array.isArray(values)) {\n          return this.options.subtype.stringify(values, options);\n        }\n\n        var valueInclusivity = [true, false];\n        var valuesStringified = values.map(function (value, index) {\n          if (_.isObject(value) && Object.prototype.hasOwnProperty.call(value, 'value')) {\n            if (Object.prototype.hasOwnProperty.call(value, 'inclusive')) {\n              valueInclusivity[index] = value.inclusive;\n            }\n\n            value = value.value;\n          }\n\n          if (value === null || value === -Infinity || value === Infinity) {\n            // Pass through \"unbounded\" bounds unchanged\n            return value;\n          }\n\n          if (_this9.options.subtype.stringify) {\n            return _this9.options.subtype.stringify(value, options);\n          }\n\n          return options.escape(value);\n        }); // Array.map does not preserve extra array properties\n\n        valuesStringified.inclusive = valueInclusivity;\n        return range.stringify(valuesStringified);\n      }\n    }, {\n      key: \"_stringify\",\n      value: function _stringify(values, options) {\n        var value = this._value(values, options);\n\n        if (!Array.isArray(values)) {\n          return \"'\".concat(value, \"'::\").concat(this.toCastType());\n        }\n\n        return \"'\".concat(value, \"'\");\n      }\n    }, {\n      key: \"_bindParam\",\n      value: function _bindParam(values, options) {\n        var value = this._value(values, options);\n\n        if (!Array.isArray(values)) {\n          return \"\".concat(options.bindParam(value), \"::\").concat(this.toCastType());\n        }\n\n        return options.bindParam(value);\n      }\n    }, {\n      key: \"toSql\",\n      value: function toSql() {\n        return BaseTypes.RANGE.types.postgres.subtypes[this._subtype.toLowerCase()];\n      }\n    }, {\n      key: \"toCastType\",\n      value: function toCastType() {\n        return BaseTypes.RANGE.types.postgres.castTypes[this._subtype.toLowerCase()];\n      }\n    }], [{\n      key: \"parse\",\n      value: function parse(value) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n          parser: function parser(val) {\n            return val;\n          }\n        };\n        return range.parse(value, options.parser);\n      }\n    }]);\n\n    return RANGE;\n  }(BaseTypes.RANGE);\n\n  var range = require('./range');\n\n  RANGE.prototype.escape = false;\n  BaseTypes.RANGE.types.postgres = {\n    subtypes: {\n      integer: 'int4range',\n      decimal: 'numrange',\n      date: 'tstzrange',\n      dateonly: 'daterange',\n      bigint: 'int8range'\n    },\n    castTypes: {\n      integer: 'int4',\n      decimal: 'numeric',\n      date: 'timestamptz',\n      dateonly: 'date',\n      bigint: 'int8'\n    }\n  }; // TODO: Why are base types being manipulated??\n\n  BaseTypes.ARRAY.prototype.escape = false;\n\n  BaseTypes.ARRAY.prototype._value = function _value(values, options) {\n    var _this10 = this;\n\n    return values.map(function (value) {\n      if (options && options.bindParam && _this10.type && _this10.type._value) {\n        return _this10.type._value(value, options);\n      }\n\n      if (_this10.type && _this10.type.stringify) {\n        value = _this10.type.stringify(value, options);\n\n        if (_this10.type.escape === false) {\n          return value;\n        }\n      }\n\n      return options.escape(value);\n    }, this);\n  };\n\n  BaseTypes.ARRAY.prototype._stringify = function _stringify(values, options) {\n    var str = \"ARRAY[\".concat(this._value(values, options).join(','), \"]\");\n\n    if (this.type) {\n      var Utils = require('../../utils');\n\n      var castKey = this.toSql();\n\n      if (this.type instanceof BaseTypes.ENUM) {\n        castKey = \"\".concat(Utils.addTicks(Utils.generateEnumName(options.field.Model.getTableName(), options.field.fieldName), '\"'), \"[]\");\n      }\n\n      str += \"::\".concat(castKey);\n    }\n\n    return str;\n  };\n\n  BaseTypes.ARRAY.prototype._bindParam = function _bindParam(values, options) {\n    return options.bindParam(this._value(values, options));\n  };\n\n  var ENUM = /*#__PURE__*/function (_BaseTypes$ENUM) {\n    _inherits(ENUM, _BaseTypes$ENUM);\n\n    function ENUM() {\n      _classCallCheck(this, ENUM);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(ENUM).apply(this, arguments));\n    }\n\n    _createClass(ENUM, null, [{\n      key: \"parse\",\n      value: function parse(value) {\n        return value;\n      }\n    }]);\n\n    return ENUM;\n  }(BaseTypes.ENUM);\n\n  BaseTypes.ENUM.types.postgres = [null];\n  return {\n    DECIMAL: DECIMAL,\n    BLOB: BLOB,\n    STRING: STRING,\n    CHAR: CHAR,\n    TEXT: TEXT,\n    CITEXT: CITEXT,\n    TINYINT: TINYINT,\n    SMALLINT: SMALLINT,\n    INTEGER: INTEGER,\n    BIGINT: BIGINT,\n    BOOLEAN: BOOLEAN,\n    DATE: DATE,\n    DATEONLY: DATEONLY,\n    REAL: REAL,\n    'DOUBLE PRECISION': DOUBLE,\n    FLOAT: FLOAT,\n    GEOMETRY: GEOMETRY,\n    GEOGRAPHY: GEOGRAPHY,\n    HSTORE: HSTORE,\n    RANGE: RANGE,\n    ENUM: ENUM\n  };\n};","map":null,"metadata":{},"sourceType":"script"}