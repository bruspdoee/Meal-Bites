{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar BaseError = require('./base-error');\n/**\n * Validation Error. Thrown when the sequelize validation has failed. The error contains an `errors` property,\n * which is an array with 1 or more ValidationErrorItems, one for each validation that failed.\n *\n * @param {string} message Error message\n * @param {Array} [errors] Array of ValidationErrorItem objects describing the validation errors\n *\n * @property errors {ValidationErrorItems[]}\n */\n\n\nvar ValidationError = /*#__PURE__*/function (_BaseError) {\n  _inherits(ValidationError, _BaseError);\n\n  function ValidationError(message, errors) {\n    var _this;\n\n    _classCallCheck(this, ValidationError);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ValidationError).call(this, message));\n    _this.name = 'SequelizeValidationError';\n    _this.message = 'Validation Error';\n    /**\n     *\n     * @type {ValidationErrorItem[]}\n     */\n\n    _this.errors = errors || []; // Use provided error message if available...\n\n    if (message) {\n      _this.message = message; // ... otherwise create a concatenated message out of existing errors.\n    } else if (_this.errors.length > 0 && _this.errors[0].message) {\n      _this.message = _this.errors.map(function (err) {\n        return \"\".concat(err.type || err.origin, \": \").concat(err.message);\n      }).join(',\\n');\n    }\n\n    Error.captureStackTrace(_assertThisInitialized(_assertThisInitialized(_this)), _this.constructor);\n    return _this;\n  }\n  /**\n   * Gets all validation error items for the path / field specified.\n   *\n   * @param {string} path The path to be checked for error items\n   *\n   * @returns {Array<ValidationErrorItem>} Validation error items for the specified path\n   */\n\n\n  _createClass(ValidationError, [{\n    key: \"get\",\n    value: function get(path) {\n      return this.errors.reduce(function (reduced, error) {\n        if (error.path === path) {\n          reduced.push(error);\n        }\n\n        return reduced;\n      }, []);\n    }\n  }]);\n\n  return ValidationError;\n}(BaseError);\n/**\n * Validation Error Item\n * Instances of this class are included in the `ValidationError.errors` property.\n */\n\n\nvar ValidationErrorItem = /*#__PURE__*/function () {\n  /**\n   * Creates new validation error item\n   *\n   * @param {string} message An error message\n   * @param {string} type The type/origin of the validation error\n   * @param {string} path The field that triggered the validation error\n   * @param {string} value The value that generated the error\n   * @param {Object} [inst] the DAO instance that caused the validation error\n   * @param {Object} [validatorKey] a validation \"key\", used for identification\n   * @param {string} [fnName] property name of the BUILT-IN validator function that caused the validation error (e.g. \"in\" or \"len\"), if applicable\n   * @param {string} [fnArgs] parameters used with the BUILT-IN validator function, if applicable\n   */\n  function ValidationErrorItem(message, type, path, value, inst, validatorKey, fnName, fnArgs) {\n    _classCallCheck(this, ValidationErrorItem);\n\n    /**\n     * An error message\n     *\n     * @type {string} message\n     */\n    this.message = message || '';\n    /**\n     * The type/origin of the validation error\n     *\n     * @type {string}\n     */\n\n    this.type = null;\n    /**\n     * The field that triggered the validation error\n     *\n     * @type {string}\n     */\n\n    this.path = path || null;\n    /**\n     * The value that generated the error\n     *\n     * @type {string}\n     */\n\n    this.value = value !== undefined ? value : null;\n    this.origin = null;\n    /**\n     * The DAO instance that caused the validation error\n     *\n     * @type {Model}\n     */\n\n    this.instance = inst || null;\n    /**\n     * A validation \"key\", used for identification\n     *\n     * @type {string}\n     */\n\n    this.validatorKey = validatorKey || null;\n    /**\n     * Property name of the BUILT-IN validator function that caused the validation error (e.g. \"in\" or \"len\"), if applicable\n     *\n     * @type {string}\n     */\n\n    this.validatorName = fnName || null;\n    /**\n     * Parameters used with the BUILT-IN validator function, if applicable\n     *\n     * @type {string}\n     */\n\n    this.validatorArgs = fnArgs || [];\n\n    if (type) {\n      if (ValidationErrorItem.Origins[type]) {\n        this.origin = type;\n      } else {\n        var lowercaseType = \"\".concat(type).toLowerCase().trim();\n        var realType = ValidationErrorItem.TypeStringMap[lowercaseType];\n\n        if (realType && ValidationErrorItem.Origins[realType]) {\n          this.origin = realType;\n          this.type = type;\n        }\n      }\n    } // This doesn't need captureStackTrace because it's not a subclass of Error\n\n  }\n  /**\n   * return a lowercase, trimmed string \"key\" that identifies the validator.\n   *\n   * Note: the string will be empty if the instance has neither a valid `validatorKey` property nor a valid `validatorName` property\n   *\n   * @param   {boolean} [useTypeAsNS=true]      controls whether the returned value is \"namespace\",\n   *                                            this parameter is ignored if the validator's `type` is not one of ValidationErrorItem.Origins\n   * @param   {string}  [NSSeparator='.']       a separator string for concatenating the namespace, must be not be empty,\n   *                                            defaults to \".\" (fullstop). only used and validated if useTypeAsNS is TRUE.\n   * @throws  {Error}                           thrown if NSSeparator is found to be invalid.\n   * @returns  {string}\n   *\n   * @private\n   */\n\n\n  _createClass(ValidationErrorItem, [{\n    key: \"getValidatorKey\",\n    value: function getValidatorKey(useTypeAsNS, NSSeparator) {\n      var useTANS = useTypeAsNS === undefined || !!useTypeAsNS;\n      var NSSep = NSSeparator === undefined ? '.' : NSSeparator;\n      var type = this.origin;\n      var key = this.validatorKey || this.validatorName;\n      var useNS = useTANS && type && ValidationErrorItem.Origins[type];\n\n      if (useNS && (typeof NSSep !== 'string' || !NSSep.length)) {\n        throw new Error('Invalid namespace separator given, must be a non-empty string');\n      }\n\n      if (!(typeof key === 'string' && key.length)) {\n        return '';\n      }\n\n      return (useNS ? [type, key].join(NSSep) : key).toLowerCase().trim();\n    }\n  }]);\n\n  return ValidationErrorItem;\n}();\n/**\n * An enum that defines valid ValidationErrorItem `origin` values\n *\n * @type {Object}\n * @property CORE       {string}  specifies errors that originate from the sequelize \"core\"\n * @property DB         {string}  specifies validation errors that originate from the storage engine\n * @property FUNCTION   {string}  specifies validation errors that originate from validator functions (both built-in and custom) defined for a given attribute\n */\n\n\nValidationErrorItem.Origins = {\n  CORE: 'CORE',\n  DB: 'DB',\n  FUNCTION: 'FUNCTION'\n};\n/**\n * An object that is used internally by the `ValidationErrorItem` class\n * that maps current `type` strings (as given to ValidationErrorItem.constructor()) to\n * our new `origin` values.\n *\n * @type {Object}\n */\n\nValidationErrorItem.TypeStringMap = {\n  'notnull violation': 'CORE',\n  'string violation': 'CORE',\n  'unique violation': 'DB',\n  'validation error': 'FUNCTION'\n};\nmodule.exports = ValidationError;\nmodule.exports.ValidationErrorItem = ValidationErrorItem;","map":null,"metadata":{},"sourceType":"script"}