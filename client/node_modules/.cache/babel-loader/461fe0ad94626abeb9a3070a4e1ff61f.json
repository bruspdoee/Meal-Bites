{"ast":null,"code":"'use strict';\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar _ = require('lodash');\n\nvar Promise = require('../../promise');\n\nvar sequelizeErrors = require('../../errors');\n\nvar QueryTypes = require('../../query-types');\n/**\n Returns an object that treats SQLite's inabilities to do certain queries.\n\n @class QueryInterface\n @static\n @private\n */\n\n/**\n  A wrapper that fixes SQLite's inability to remove columns from existing tables.\n  It will create a backup of the table, drop the table afterwards and create a\n  new table with the same name but without the obsolete column.\n\n  @param  {QueryInterface} qi\n  @param  {string} tableName     The name of the table.\n  @param  {string} attributeName The name of the attribute that we want to remove.\n  @param  {Object} options\n  @param  {boolean|Function} [options.logging] A function that logs the sql queries, or false for explicitly not logging these queries\n\n  @since 1.6.0\n  @private\n */\n\n\nfunction removeColumn(qi, tableName, attributeName, options) {\n  options = options || {};\n  return qi.describeTable(tableName, options).then(function (fields) {\n    delete fields[attributeName];\n    var sql = qi.QueryGenerator.removeColumnQuery(tableName, fields);\n    var subQueries = sql.split(';').filter(function (q) {\n      return q !== '';\n    });\n    return Promise.each(subQueries, function (subQuery) {\n      return qi.sequelize.query(\"\".concat(subQuery, \";\"), Object.assign({\n        raw: true\n      }, options));\n    });\n  });\n}\n\nexports.removeColumn = removeColumn;\n/**\n  A wrapper that fixes SQLite's inability to change columns from existing tables.\n  It will create a backup of the table, drop the table afterwards and create a\n  new table with the same name but with a modified version of the respective column.\n\n  @param  {QueryInterface} qi\n  @param  {string} tableName The name of the table.\n  @param  {Object} attributes An object with the attribute's name as key and its options as value object.\n  @param  {Object} options\n  @param  {boolean|Function} [options.logging] A function that logs the sql queries, or false for explicitly not logging these queries\n\n  @since 1.6.0\n  @private\n */\n\nfunction changeColumn(qi, tableName, attributes, options) {\n  var attributeName = Object.keys(attributes)[0];\n  options = options || {};\n  return qi.describeTable(tableName, options).then(function (fields) {\n    Object.assign(fields[attributeName], attributes[attributeName]);\n    var sql = qi.QueryGenerator.removeColumnQuery(tableName, fields);\n    var subQueries = sql.split(';').filter(function (q) {\n      return q !== '';\n    });\n    return Promise.each(subQueries, function (subQuery) {\n      return qi.sequelize.query(\"\".concat(subQuery, \";\"), Object.assign({\n        raw: true\n      }, options));\n    });\n  });\n}\n\nexports.changeColumn = changeColumn;\n/**\n  A wrapper that fixes SQLite's inability to rename columns from existing tables.\n  It will create a backup of the table, drop the table afterwards and create a\n  new table with the same name but with a renamed version of the respective column.\n\n  @param  {QueryInterface} qi\n  @param  {string} tableName The name of the table.\n  @param  {string} attrNameBefore The name of the attribute before it was renamed.\n  @param  {string} attrNameAfter The name of the attribute after it was renamed.\n  @param  {Object} options\n  @param  {boolean|Function} [options.logging] A function that logs the sql queries, or false for explicitly not logging these queries\n\n  @since 1.6.0\n  @private\n */\n\nfunction renameColumn(qi, tableName, attrNameBefore, attrNameAfter, options) {\n  options = options || {};\n  return qi.describeTable(tableName, options).then(function (fields) {\n    fields[attrNameAfter] = _.clone(fields[attrNameBefore]);\n    delete fields[attrNameBefore];\n    var sql = qi.QueryGenerator.renameColumnQuery(tableName, attrNameBefore, attrNameAfter, fields);\n    var subQueries = sql.split(';').filter(function (q) {\n      return q !== '';\n    });\n    return Promise.each(subQueries, function (subQuery) {\n      return qi.sequelize.query(\"\".concat(subQuery, \";\"), Object.assign({\n        raw: true\n      }, options));\n    });\n  });\n}\n\nexports.renameColumn = renameColumn;\n/**\n * @param {QueryInterface} qi\n * @param {string} tableName\n * @param {string} constraintName\n * @param {Object} options\n *\n * @private\n */\n\nfunction removeConstraint(qi, tableName, constraintName, options) {\n  var createTableSql;\n  return qi.showConstraint(tableName, constraintName).then(function (constraints) {\n    // sqlite can't show only one constraint, so we find here the one to remove\n    var constraint = constraints.find(function (constaint) {\n      return constaint.constraintName === constraintName;\n    });\n\n    if (constraint) {\n      createTableSql = constraint.sql;\n      constraint.constraintName = qi.QueryGenerator.quoteIdentifier(constraint.constraintName);\n      var constraintSnippet = \", CONSTRAINT \".concat(constraint.constraintName, \" \").concat(constraint.constraintType, \" \").concat(constraint.constraintCondition);\n\n      if (constraint.constraintType === 'FOREIGN KEY') {\n        var referenceTableName = qi.QueryGenerator.quoteTable(constraint.referenceTableName);\n        constraint.referenceTableKeys = constraint.referenceTableKeys.map(function (columnName) {\n          return qi.QueryGenerator.quoteIdentifier(columnName);\n        });\n        var referenceTableKeys = constraint.referenceTableKeys.join(', ');\n        constraintSnippet += \" REFERENCES \".concat(referenceTableName, \" (\").concat(referenceTableKeys, \")\");\n        constraintSnippet += \" ON UPDATE \".concat(constraint.updateAction);\n        constraintSnippet += \" ON DELETE \".concat(constraint.deleteAction);\n      }\n\n      createTableSql = createTableSql.replace(constraintSnippet, '');\n      createTableSql += ';';\n      return qi.describeTable(tableName, options);\n    }\n\n    throw new sequelizeErrors.UnknownConstraintError({\n      message: \"Constraint \".concat(constraintName, \" on table \").concat(tableName, \" does not exist\"),\n      constraint: constraintName,\n      table: tableName\n    });\n  }).then(function (fields) {\n    var sql = qi.QueryGenerator._alterConstraintQuery(tableName, fields, createTableSql);\n\n    var subQueries = sql.split(';').filter(function (q) {\n      return q !== '';\n    });\n    return Promise.each(subQueries, function (subQuery) {\n      return qi.sequelize.query(\"\".concat(subQuery, \";\"), Object.assign({\n        raw: true\n      }, options));\n    });\n  });\n}\n\nexports.removeConstraint = removeConstraint;\n/**\n * @param {QueryInterface} qi\n * @param {string} tableName\n * @param {Object} options\n *\n * @private\n */\n\nfunction addConstraint(qi, tableName, options) {\n  var constraintSnippet = qi.QueryGenerator.getConstraintSnippet(tableName, options);\n  var describeCreateTableSql = qi.QueryGenerator.describeCreateTableQuery(tableName);\n  var createTableSql;\n  return qi.sequelize.query(describeCreateTableSql, Object.assign({}, options, {\n    type: QueryTypes.SELECT,\n    raw: true\n  })).then(function (constraints) {\n    var sql = constraints[0].sql;\n    var index = sql.length - 1; //Replace ending ')' with constraint snippet - Simulates String.replaceAt\n    //http://stackoverflow.com/questions/1431094\n\n    createTableSql = \"\".concat(sql.substr(0, index), \", \").concat(constraintSnippet, \")\").concat(sql.substr(index + 1), \";\");\n    return qi.describeTable(tableName, options);\n  }).then(function (fields) {\n    var sql = qi.QueryGenerator._alterConstraintQuery(tableName, fields, createTableSql);\n\n    var subQueries = sql.split(';').filter(function (q) {\n      return q !== '';\n    });\n    return Promise.each(subQueries, function (subQuery) {\n      return qi.sequelize.query(\"\".concat(subQuery, \";\"), Object.assign({\n        raw: true\n      }, options));\n    });\n  });\n}\n\nexports.addConstraint = addConstraint;\n/**\n * @param {QueryInterface} qi\n * @param {string} tableName\n * @param {Object} options  Query Options\n *\n * @private\n * @returns {Promise}\n */\n\nfunction getForeignKeyReferencesForTable(qi, tableName, options) {\n  var database = qi.sequelize.config.database;\n  var query = qi.QueryGenerator.getForeignKeysQuery(tableName, database);\n  return qi.sequelize.query(query, options).then(function (result) {\n    return result.map(function (row) {\n      return {\n        tableName: tableName,\n        columnName: row.from,\n        referencedTableName: row.table,\n        referencedColumnName: row.to,\n        tableCatalog: database,\n        referencedTableCatalog: database\n      };\n    });\n  });\n}\n\nexports.getForeignKeyReferencesForTable = getForeignKeyReferencesForTable;\n/**\n * Describe a table structure\n *\n * This method returns an array of hashes containing information about all attributes in the table.\n *\n * ```js\n * {\n *    name: {\n *      type:         'VARCHAR(255)', // this will be 'CHARACTER VARYING' for pg!\n *      allowNull:    true,\n *      defaultValue: null,\n *      unique:       true,           // available for sqlite only\n *      references:   {},             // available for sqlite only\n *    },\n *    isBetaMember: {\n *      type:         'TINYINT(1)', // this will be 'BOOLEAN' for pg!\n *      allowNull:    false,\n *      defaultValue: false,\n *      unique:       false,        // available for sqlite only\n *      references:   {},           // available for sqlite only\n *    }\n * }\n * ```\n *\n * @param {QueryInterface} qi\n * @param {string} tableName table name\n * @param {Object} [options] Query options\n *\n * @returns {Promise<Object>}\n */\n\nfunction describeTable(qi, tableName, options) {\n  var schema = null;\n  var schemaDelimiter = null;\n\n  if (typeof options === 'string') {\n    schema = options;\n  } else if (typeof options === 'object' && options !== null) {\n    schema = options.schema || null;\n    schemaDelimiter = options.schemaDelimiter || null;\n  }\n\n  if (typeof tableName === 'object' && tableName !== null) {\n    schema = tableName.schema;\n    tableName = tableName.tableName;\n  }\n\n  var sql = qi.QueryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);\n  options = Object.assign({}, options, {\n    type: QueryTypes.DESCRIBE\n  });\n  return qi.sequelize.query(sql, options).then(function (data) {\n    /*\n      * If no data is returned from the query, then the table name may be wrong.\n      * Query generators that use information_schema for retrieving table info will just return an empty result set,\n      * it will not throw an error like built-ins do (e.g. DESCRIBE on MySql).\n      */\n    if (_.isEmpty(data)) {\n      throw new Error(\"No description found for \\\"\".concat(tableName, \"\\\" table. Check the table name and schema; remember, they _are_ case sensitive.\"));\n    }\n\n    return qi.showIndex(tableName, options).then(function (indexes) {\n      for (var prop in data) {\n        data[prop].unique = false;\n      }\n\n      var _iterator = _createForOfIteratorHelper(indexes),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var index = _step.value;\n\n          var _iterator3 = _createForOfIteratorHelper(index.fields),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var field = _step3.value;\n\n              if (index.unique !== undefined) {\n                data[field.attribute].unique = index.unique;\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return qi.getForeignKeyReferencesForTable(tableName, options).then(function (foreignKeys) {\n        var _iterator2 = _createForOfIteratorHelper(foreignKeys),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var foreignKey = _step2.value;\n            data[foreignKey.columnName].references = {\n              model: foreignKey.referencedTableName,\n              key: foreignKey.referencedColumnName\n            };\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        return data;\n      });\n    });\n  }).catch(function (e) {\n    if (e.original && e.original.code === 'ER_NO_SUCH_TABLE') {\n      throw Error(\"No description found for \\\"\".concat(tableName, \"\\\" table. Check the table name and schema; remember, they _are_ case sensitive.\"));\n    }\n\n    throw e;\n  });\n}\n\nexports.describeTable = describeTable;","map":null,"metadata":{},"sourceType":"script"}