{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar ErrorCodeToName = require('../constants/errors.js');\n\nvar NativeBuffer = require('buffer').Buffer;\n\nvar Long = require('long');\n\nvar StringParser = require('../parsers/string.js');\n\nvar INVALID_DATE = new Date(NaN); // this is nearly duplicate of previous function so generated code is not slower\n// due to \"if (dateStrings)\" branching\n\nvar pad = '000000000000';\n\nfunction leftPad(num, value) {\n  var s = value.toString(); // if we don't need to pad\n\n  if (s.length >= num) {\n    return s;\n  }\n\n  return (pad + s).slice(-num);\n} // The whole reason parse* function below exist\n// is because String creation is relatively expensive (at least with V8), and if we have\n// a buffer with \"12345\" content ideally we would like to bypass intermediate\n// \"12345\" string creation and directly build 12345 number out of\n// <Buffer 31 32 33 34 35> data.\n// In my benchmarks the difference is ~25M 8-digit numbers per second vs\n// 4.5 M using Number(packet.readLengthCodedString())\n// not used when size is close to max precision as series of *10 accumulate error\n// and approximate result mihgt be diffreent from (approximate as well) Number(bigNumStringValue))\n// In the futire node version if speed difference is smaller parse* functions might be removed\n// don't consider them as Packet public API\n\n\nvar minus = '-'.charCodeAt(0);\nvar plus = '+'.charCodeAt(0); // TODO: handle E notation\n\nvar dot = '.'.charCodeAt(0);\nvar exponent = 'e'.charCodeAt(0);\nvar exponentCapital = 'E'.charCodeAt(0);\n\nvar Packet = /*#__PURE__*/function () {\n  function Packet(id, buffer, start, end) {\n    _classCallCheck(this, Packet);\n\n    // hot path, enable checks when testing only\n    // if (!Buffer.isBuffer(buffer) || typeof start == 'undefined' || typeof end == 'undefined')\n    //  throw new Error('invalid packet');\n    this.sequenceId = id;\n    this.numPackets = 1;\n    this.buffer = buffer;\n    this.start = start;\n    this.offset = start + 4;\n    this.end = end;\n  } // ==============================\n  // readers\n  // ==============================\n\n\n  _createClass(Packet, [{\n    key: \"reset\",\n    value: function reset() {\n      this.offset = this.start + 4;\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return this.end - this.start;\n    }\n  }, {\n    key: \"slice\",\n    value: function slice() {\n      return this.buffer.slice(this.start, this.end);\n    }\n  }, {\n    key: \"dump\",\n    value: function dump() {\n      // eslint-disable-next-line no-console\n      console.log([this.buffer.asciiSlice(this.start, this.end)], this.buffer.slice(this.start, this.end), this.length(), this.sequenceId);\n    }\n  }, {\n    key: \"haveMoreData\",\n    value: function haveMoreData() {\n      return this.end > this.offset;\n    }\n  }, {\n    key: \"skip\",\n    value: function skip(num) {\n      this.offset += num;\n    }\n  }, {\n    key: \"readInt8\",\n    value: function readInt8() {\n      return this.buffer[this.offset++];\n    }\n  }, {\n    key: \"readInt16\",\n    value: function readInt16() {\n      this.offset += 2;\n      return this.buffer.readUInt16LE(this.offset - 2);\n    }\n  }, {\n    key: \"readInt24\",\n    value: function readInt24() {\n      return this.readInt16() + (this.readInt8() << 16);\n    }\n  }, {\n    key: \"readInt32\",\n    value: function readInt32() {\n      this.offset += 4;\n      return this.buffer.readUInt32LE(this.offset - 4);\n    }\n  }, {\n    key: \"readSInt8\",\n    value: function readSInt8() {\n      return this.buffer.readInt8(this.offset++);\n    }\n  }, {\n    key: \"readSInt16\",\n    value: function readSInt16() {\n      this.offset += 2;\n      return this.buffer.readInt16LE(this.offset - 2);\n    }\n  }, {\n    key: \"readSInt32\",\n    value: function readSInt32() {\n      this.offset += 4;\n      return this.buffer.readInt32LE(this.offset - 4);\n    }\n  }, {\n    key: \"readInt64JSNumber\",\n    value: function readInt64JSNumber() {\n      var word0 = this.readInt32();\n      var word1 = this.readInt32();\n      var l = new Long(word0, word1, true);\n      return l.toNumber();\n    }\n  }, {\n    key: \"readSInt64JSNumber\",\n    value: function readSInt64JSNumber() {\n      var word0 = this.readInt32();\n      var word1 = this.readInt32();\n\n      if (!(word1 & 0x80000000)) {\n        return word0 + 0x100000000 * word1;\n      }\n\n      var l = new Long(word0, word1, false);\n      return l.toNumber();\n    }\n  }, {\n    key: \"readInt64String\",\n    value: function readInt64String() {\n      var word0 = this.readInt32();\n      var word1 = this.readInt32();\n      var res = new Long(word0, word1, true);\n      return res.toString();\n    }\n  }, {\n    key: \"readSInt64String\",\n    value: function readSInt64String() {\n      var word0 = this.readInt32();\n      var word1 = this.readInt32();\n      var res = new Long(word0, word1, false);\n      return res.toString();\n    }\n  }, {\n    key: \"readInt64\",\n    value: function readInt64() {\n      var word0 = this.readInt32();\n      var word1 = this.readInt32();\n      var res = new Long(word0, word1, true);\n      var resNumber = res.toNumber();\n      var resString = res.toString();\n      res = resNumber.toString() === resString ? resNumber : resString;\n      return res;\n    }\n  }, {\n    key: \"readSInt64\",\n    value: function readSInt64() {\n      var word0 = this.readInt32();\n      var word1 = this.readInt32();\n      var res = new Long(word0, word1, false);\n      var resNumber = res.toNumber();\n      var resString = res.toString();\n      res = resNumber.toString() === resString ? resNumber : resString;\n      return res;\n    }\n  }, {\n    key: \"isEOF\",\n    value: function isEOF() {\n      return this.buffer[this.offset] === 0xfe && this.length() < 13;\n    }\n  }, {\n    key: \"eofStatusFlags\",\n    value: function eofStatusFlags() {\n      return this.buffer.readInt16LE(this.offset + 3);\n    }\n  }, {\n    key: \"eofWarningCount\",\n    value: function eofWarningCount() {\n      return this.buffer.readInt16LE(this.offset + 1);\n    }\n  }, {\n    key: \"readLengthCodedNumber\",\n    value: function readLengthCodedNumber(bigNumberStrings, signed) {\n      var byte1 = this.buffer[this.offset++];\n\n      if (byte1 < 251) {\n        return byte1;\n      }\n\n      return this.readLengthCodedNumberExt(byte1, bigNumberStrings, signed);\n    }\n  }, {\n    key: \"readLengthCodedNumberSigned\",\n    value: function readLengthCodedNumberSigned(bigNumberStrings) {\n      return this.readLengthCodedNumber(bigNumberStrings, true);\n    }\n  }, {\n    key: \"readLengthCodedNumberExt\",\n    value: function readLengthCodedNumberExt(tag, bigNumberStrings, signed) {\n      var word0, word1;\n      var res;\n\n      if (tag === 0xfb) {\n        return null;\n      }\n\n      if (tag === 0xfc) {\n        return this.readInt8() + (this.readInt8() << 8);\n      }\n\n      if (tag === 0xfd) {\n        return this.readInt8() + (this.readInt8() << 8) + (this.readInt8() << 16);\n      }\n\n      if (tag === 0xfe) {\n        // TODO: check version\n        // Up to MySQL 3.22, 0xfe was followed by a 4-byte integer.\n        word0 = this.readInt32();\n        word1 = this.readInt32();\n\n        if (word1 === 0) {\n          return word0; // don't convert to float if possible\n        }\n\n        if (word1 < 2097152) {\n          // max exact float point int, 2^52 / 2^32\n          return word1 * 0x100000000 + word0;\n        }\n\n        res = new Long(word0, word1, !signed); // Long need unsigned\n\n        var resNumber = res.toNumber();\n        var resString = res.toString();\n        res = resNumber.toString() === resString ? resNumber : resString;\n        return bigNumberStrings ? resString : res;\n      } // eslint-disable-next-line no-console\n\n\n      console.trace();\n      throw new Error(\"Should not reach here: \".concat(tag));\n    }\n  }, {\n    key: \"readFloat\",\n    value: function readFloat() {\n      var res = this.buffer.readFloatLE(this.offset);\n      this.offset += 4;\n      return res;\n    }\n  }, {\n    key: \"readDouble\",\n    value: function readDouble() {\n      var res = this.buffer.readDoubleLE(this.offset);\n      this.offset += 8;\n      return res;\n    }\n  }, {\n    key: \"readBuffer\",\n    value: function readBuffer(len) {\n      if (typeof len === 'undefined') {\n        len = this.end - this.offset;\n      }\n\n      this.offset += len;\n      return this.buffer.slice(this.offset - len, this.offset);\n    } // DATE, DATETIME and TIMESTAMP\n\n  }, {\n    key: \"readDateTime\",\n    value: function readDateTime(timezone) {\n      if (!timezone || timezone === 'Z' || timezone === 'local') {\n        var length = this.readInt8();\n\n        if (length === 0xfb) {\n          return null;\n        }\n\n        var y = 0;\n        var m = 0;\n        var d = 0;\n        var H = 0;\n        var M = 0;\n        var S = 0;\n        var ms = 0;\n\n        if (length > 3) {\n          y = this.readInt16();\n          m = this.readInt8();\n          d = this.readInt8();\n        }\n\n        if (length > 6) {\n          H = this.readInt8();\n          M = this.readInt8();\n          S = this.readInt8();\n        }\n\n        if (length > 10) {\n          ms = this.readInt32() / 1000;\n        }\n\n        if (y + m + d + H + M + S + ms === 0) {\n          return INVALID_DATE;\n        }\n\n        if (timezone === 'Z') {\n          return new Date(Date.UTC(y, m - 1, d, H, M, S, ms));\n        }\n\n        return new Date(y, m - 1, d, H, M, S, ms);\n      }\n\n      var str = this.readDateTimeString(6, 'T');\n\n      if (str.length === 10) {\n        str += 'T00:00:00';\n      }\n\n      return new Date(str + timezone);\n    }\n  }, {\n    key: \"readDateTimeString\",\n    value: function readDateTimeString(decimals, timeSep) {\n      var length = this.readInt8();\n      var y = 0;\n      var m = 0;\n      var d = 0;\n      var H = 0;\n      var M = 0;\n      var S = 0;\n      var ms = 0;\n      var str;\n\n      if (length > 3) {\n        y = this.readInt16();\n        m = this.readInt8();\n        d = this.readInt8();\n        str = [leftPad(4, y), leftPad(2, m), leftPad(2, d)].join('-');\n      }\n\n      if (length > 6) {\n        H = this.readInt8();\n        M = this.readInt8();\n        S = this.readInt8();\n        str += \"\".concat(timeSep || ' ').concat([leftPad(2, H), leftPad(2, M), leftPad(2, S)].join(':'));\n      }\n\n      if (length > 10) {\n        ms = this.readInt32();\n        str += '.';\n\n        if (decimals) {\n          ms = leftPad(6, ms);\n\n          if (ms.length > decimals) {\n            ms = ms.substring(0, decimals); // rounding is done at the MySQL side, only 0 are here\n          }\n        }\n\n        str += ms;\n      }\n\n      return str;\n    } // TIME - value as a string, Can be negative\n\n  }, {\n    key: \"readTimeString\",\n    value: function readTimeString(convertTtoMs) {\n      var length = this.readInt8();\n\n      if (length === 0) {\n        return '00:00:00';\n      }\n\n      var sign = this.readInt8() ? -1 : 1; // 'isNegative' flag byte\n\n      var d = 0;\n      var H = 0;\n      var M = 0;\n      var S = 0;\n      var ms = 0;\n\n      if (length > 6) {\n        d = this.readInt32();\n        H = this.readInt8();\n        M = this.readInt8();\n        S = this.readInt8();\n      }\n\n      if (length > 10) {\n        ms = this.readInt32();\n      }\n\n      if (convertTtoMs) {\n        H += d * 24;\n        M += H * 60;\n        S += M * 60;\n        ms += S * 1000;\n        ms *= sign;\n        return ms;\n      }\n\n      return (sign === -1 ? '-' : '') + [d ? d * 24 + H : H, leftPad(2, M), leftPad(2, S)].join(':') + (ms ? \".\".concat(ms) : '');\n    }\n  }, {\n    key: \"readLengthCodedString\",\n    value: function readLengthCodedString(encoding) {\n      var len = this.readLengthCodedNumber(); // TODO: check manually first byte here to avoid polymorphic return type?\n\n      if (len === null) {\n        return null;\n      }\n\n      this.offset += len; // TODO: Use characterSetCode to get proper encoding\n      // https://github.com/sidorares/node-mysql2/pull/374\n\n      return StringParser.decode(this.buffer.slice(this.offset - len, this.offset), encoding);\n    }\n  }, {\n    key: \"readLengthCodedBuffer\",\n    value: function readLengthCodedBuffer() {\n      var len = this.readLengthCodedNumber();\n\n      if (len === null) {\n        return null;\n      }\n\n      return this.readBuffer(len);\n    }\n  }, {\n    key: \"readNullTerminatedString\",\n    value: function readNullTerminatedString(encoding) {\n      var start = this.offset;\n      var end = this.offset;\n\n      while (this.buffer[end]) {\n        end = end + 1; // TODO: handle OOB check\n      }\n\n      this.offset = end + 1;\n      return StringParser.decode(this.buffer.slice(start, end), encoding);\n    } // TODO reuse?\n\n  }, {\n    key: \"readString\",\n    value: function readString(len, encoding) {\n      if (typeof len === 'string' && typeof encoding === 'undefined') {\n        encoding = len;\n        len = undefined;\n      }\n\n      if (typeof len === 'undefined') {\n        len = this.end - this.offset;\n      }\n\n      this.offset += len;\n      return StringParser.decode(this.buffer.slice(this.offset - len, this.offset), encoding);\n    }\n  }, {\n    key: \"parseInt\",\n    value: function (_parseInt) {\n      function parseInt(_x, _x2) {\n        return _parseInt.apply(this, arguments);\n      }\n\n      parseInt.toString = function () {\n        return _parseInt.toString();\n      };\n\n      return parseInt;\n    }(function (len, supportBigNumbers) {\n      if (len === null) {\n        return null;\n      }\n\n      if (len >= 14 && !supportBigNumbers) {\n        var s = this.buffer.toString('ascii', this.offset, this.offset + len);\n        this.offset += len;\n        return Number(s);\n      }\n\n      var result = 0;\n      var start = this.offset;\n      var end = this.offset + len;\n      var sign = 1;\n\n      if (len === 0) {\n        return 0; // TODO: assert? exception?\n      }\n\n      if (this.buffer[this.offset] === minus) {\n        this.offset++;\n        sign = -1;\n      } // max precise int is 9007199254740992\n\n\n      var str;\n      var numDigits = end - this.offset;\n\n      if (supportBigNumbers) {\n        if (numDigits >= 15) {\n          str = this.readString(end - this.offset, 'binary');\n          result = parseInt(str, 10);\n\n          if (result.toString() === str) {\n            return sign * result;\n          }\n\n          return sign === -1 ? \"-\".concat(str) : str;\n        }\n\n        if (numDigits > 16) {\n          str = this.readString(end - this.offset);\n          return sign === -1 ? \"-\".concat(str) : str;\n        }\n      }\n\n      if (this.buffer[this.offset] === plus) {\n        this.offset++; // just ignore\n      }\n\n      while (this.offset < end) {\n        result *= 10;\n        result += this.buffer[this.offset] - 48;\n        this.offset++;\n      }\n\n      var num = result * sign;\n\n      if (!supportBigNumbers) {\n        return num;\n      }\n\n      str = this.buffer.toString('ascii', start, end);\n\n      if (num.toString() === str) {\n        return num;\n      }\n\n      return str;\n    }) // note that if value of inputNumberAsString is bigger than MAX_SAFE_INTEGER\n    // ( or smaller than MIN_SAFE_INTEGER ) the parseIntNoBigCheck result might be\n    // different from what you would get from Number(inputNumberAsString)\n    // String(parseIntNoBigCheck) <> String(Number(inputNumberAsString)) <> inputNumberAsString\n\n  }, {\n    key: \"parseIntNoBigCheck\",\n    value: function parseIntNoBigCheck(len) {\n      if (len === null) {\n        return null;\n      }\n\n      var result = 0;\n      var end = this.offset + len;\n      var sign = 1;\n\n      if (len === 0) {\n        return 0; // TODO: assert? exception?\n      }\n\n      if (this.buffer[this.offset] === minus) {\n        this.offset++;\n        sign = -1;\n      }\n\n      if (this.buffer[this.offset] === plus) {\n        this.offset++; // just ignore\n      }\n\n      while (this.offset < end) {\n        result *= 10;\n        result += this.buffer[this.offset] - 48;\n        this.offset++;\n      }\n\n      return result * sign;\n    } // copy-paste from https://github.com/mysqljs/mysql/blob/master/lib/protocol/Parser.js\n\n  }, {\n    key: \"parseGeometryValue\",\n    value: function parseGeometryValue() {\n      var buffer = this.readLengthCodedBuffer();\n      var offset = 4;\n\n      if (buffer === null || !buffer.length) {\n        return null;\n      }\n\n      function parseGeometry() {\n        var x, y, i, j, numPoints, line;\n        var result = null;\n        var byteOrder = buffer.readUInt8(offset);\n        offset += 1;\n        var wkbType = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n        offset += 4;\n\n        switch (wkbType) {\n          case 1:\n            // WKBPoint\n            x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n            offset += 8;\n            y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n            offset += 8;\n            result = {\n              x: x,\n              y: y\n            };\n            break;\n\n          case 2:\n            // WKBLineString\n            numPoints = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n            offset += 4;\n            result = [];\n\n            for (i = numPoints; i > 0; i--) {\n              x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n              offset += 8;\n              y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n              offset += 8;\n              result.push({\n                x: x,\n                y: y\n              });\n            }\n\n            break;\n\n          case 3:\n            // WKBPolygon\n            // eslint-disable-next-line no-case-declarations\n            var numRings = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n            offset += 4;\n            result = [];\n\n            for (i = numRings; i > 0; i--) {\n              numPoints = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n              offset += 4;\n              line = [];\n\n              for (j = numPoints; j > 0; j--) {\n                x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n                offset += 8;\n                y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n                offset += 8;\n                line.push({\n                  x: x,\n                  y: y\n                });\n              }\n\n              result.push(line);\n            }\n\n            break;\n\n          case 4: // WKBMultiPoint\n\n          case 5: // WKBMultiLineString\n\n          case 6: // WKBMultiPolygon\n\n          case 7:\n            // WKBGeometryCollection\n            // eslint-disable-next-line no-case-declarations\n            var num = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n            offset += 4;\n            result = [];\n\n            for (i = num; i > 0; i--) {\n              result.push(parseGeometry());\n            }\n\n            break;\n        }\n\n        return result;\n      }\n\n      return parseGeometry();\n    }\n  }, {\n    key: \"parseDate\",\n    value: function parseDate(timezone) {\n      var strLen = this.readLengthCodedNumber();\n\n      if (strLen === null) {\n        return null;\n      }\n\n      if (strLen !== 10) {\n        // we expect only YYYY-MM-DD here.\n        // if for some reason it's not the case return invalid date\n        return new Date(NaN);\n      }\n\n      var y = this.parseInt(4);\n      this.offset++; // -\n\n      var m = this.parseInt(2);\n      this.offset++; // -\n\n      var d = this.parseInt(2);\n\n      if (!timezone || timezone === 'local') {\n        return new Date(y, m - 1, d);\n      }\n\n      if (timezone === 'Z') {\n        return new Date(Date.UTC(y, m - 1, d));\n      }\n\n      return new Date(\"\".concat(leftPad(4, y), \"-\").concat(leftPad(2, m), \"-\").concat(leftPad(2, d), \"T00:00:00\").concat(timezone));\n    }\n  }, {\n    key: \"parseDateTime\",\n    value: function parseDateTime(timezone) {\n      var str = this.readLengthCodedString('binary');\n\n      if (str === null) {\n        return null;\n      }\n\n      if (!timezone || timezone === 'local') {\n        return new Date(str);\n      }\n\n      return new Date(\"\".concat(str).concat(timezone));\n    }\n  }, {\n    key: \"parseFloat\",\n    value: function parseFloat(len) {\n      if (len === null) {\n        return null;\n      }\n\n      var result = 0;\n      var end = this.offset + len;\n      var factor = 1;\n      var pastDot = false;\n      var charCode = 0;\n\n      if (len === 0) {\n        return 0; // TODO: assert? exception?\n      }\n\n      if (this.buffer[this.offset] === minus) {\n        this.offset++;\n        factor = -1;\n      }\n\n      if (this.buffer[this.offset] === plus) {\n        this.offset++; // just ignore\n      }\n\n      while (this.offset < end) {\n        charCode = this.buffer[this.offset];\n\n        if (charCode === dot) {\n          pastDot = true;\n          this.offset++;\n        } else if (charCode === exponent || charCode === exponentCapital) {\n          this.offset++;\n          var exponentValue = this.parseInt(end - this.offset);\n          return result / factor * Math.pow(10, exponentValue);\n        } else {\n          result *= 10;\n          result += this.buffer[this.offset] - 48;\n          this.offset++;\n\n          if (pastDot) {\n            factor = factor * 10;\n          }\n        }\n      }\n\n      return result / factor;\n    }\n  }, {\n    key: \"parseLengthCodedIntNoBigCheck\",\n    value: function parseLengthCodedIntNoBigCheck() {\n      return this.parseIntNoBigCheck(this.readLengthCodedNumber());\n    }\n  }, {\n    key: \"parseLengthCodedInt\",\n    value: function parseLengthCodedInt(supportBigNumbers) {\n      return this.parseInt(this.readLengthCodedNumber(), supportBigNumbers);\n    }\n  }, {\n    key: \"parseLengthCodedIntString\",\n    value: function parseLengthCodedIntString() {\n      return this.readLengthCodedString('binary');\n    }\n  }, {\n    key: \"parseLengthCodedFloat\",\n    value: function parseLengthCodedFloat() {\n      return this.parseFloat(this.readLengthCodedNumber());\n    }\n  }, {\n    key: \"peekByte\",\n    value: function peekByte() {\n      return this.buffer[this.offset];\n    } // OxFE is often used as \"Alt\" flag - not ok, not error.\n    // For example, it's first byte of AuthSwitchRequest\n\n  }, {\n    key: \"isAlt\",\n    value: function isAlt() {\n      return this.peekByte() === 0xfe;\n    }\n  }, {\n    key: \"isError\",\n    value: function isError() {\n      return this.peekByte() === 0xff;\n    }\n  }, {\n    key: \"asError\",\n    value: function asError(encoding) {\n      this.reset();\n      this.readInt8(); // fieldCount\n\n      var errorCode = this.readInt16();\n      var sqlState = '';\n\n      if (this.buffer[this.offset] === 0x23) {\n        this.skip(1);\n        sqlState = this.readBuffer(5).toString();\n      }\n\n      var message = this.readString(undefined, encoding);\n      var err = new Error(message);\n      err.code = ErrorCodeToName[errorCode];\n      err.errno = errorCode;\n      err.sqlState = sqlState;\n      err.sqlMessage = message;\n      return err;\n    }\n  }, {\n    key: \"writeInt32\",\n    value: function writeInt32(n) {\n      this.buffer.writeUInt32LE(n, this.offset);\n      this.offset += 4;\n    }\n  }, {\n    key: \"writeInt24\",\n    value: function writeInt24(n) {\n      this.writeInt8(n & 0xff);\n      this.writeInt16(n >> 8);\n    }\n  }, {\n    key: \"writeInt16\",\n    value: function writeInt16(n) {\n      this.buffer.writeUInt16LE(n, this.offset);\n      this.offset += 2;\n    }\n  }, {\n    key: \"writeInt8\",\n    value: function writeInt8(n) {\n      this.buffer.writeUInt8(n, this.offset);\n      this.offset++;\n    }\n  }, {\n    key: \"writeDouble\",\n    value: function writeDouble(n) {\n      this.buffer.writeDoubleLE(n, this.offset);\n      this.offset += 8;\n    }\n  }, {\n    key: \"writeBuffer\",\n    value: function writeBuffer(b) {\n      b.copy(this.buffer, this.offset);\n      this.offset += b.length;\n    }\n  }, {\n    key: \"writeNull\",\n    value: function writeNull() {\n      this.buffer[this.offset] = 0xfb;\n      this.offset++;\n    } // TODO: refactor following three?\n\n  }, {\n    key: \"writeNullTerminatedString\",\n    value: function writeNullTerminatedString(s, encoding) {\n      var buf = StringParser.encode(s, encoding);\n      this.buffer.length && buf.copy(this.buffer, this.offset);\n      this.offset += buf.length;\n      this.writeInt8(0);\n    }\n  }, {\n    key: \"writeString\",\n    value: function writeString(s, encoding) {\n      if (s === null) {\n        this.writeInt8(0xfb);\n        return;\n      }\n\n      if (s.length === 0) {\n        return;\n      } // const bytes = Buffer.byteLength(s, 'utf8');\n      // this.buffer.write(s, this.offset, bytes, 'utf8');\n      // this.offset += bytes;\n\n\n      var buf = StringParser.encode(s, encoding);\n      this.buffer.length && buf.copy(this.buffer, this.offset);\n      this.offset += buf.length;\n    }\n  }, {\n    key: \"writeLengthCodedString\",\n    value: function writeLengthCodedString(s, encoding) {\n      var buf = StringParser.encode(s, encoding);\n      this.writeLengthCodedNumber(buf.length);\n      this.buffer.length && buf.copy(this.buffer, this.offset);\n      this.offset += buf.length;\n    }\n  }, {\n    key: \"writeLengthCodedBuffer\",\n    value: function writeLengthCodedBuffer(b) {\n      this.writeLengthCodedNumber(b.length);\n      b.copy(this.buffer, this.offset);\n      this.offset += b.length;\n    }\n  }, {\n    key: \"writeLengthCodedNumber\",\n    value: function writeLengthCodedNumber(n) {\n      if (n < 0xfb) {\n        return this.writeInt8(n);\n      }\n\n      if (n < 0xffff) {\n        this.writeInt8(0xfc);\n        return this.writeInt16(n);\n      }\n\n      if (n < 0xffffff) {\n        this.writeInt8(0xfd);\n        return this.writeInt24(n);\n      }\n\n      if (n === null) {\n        return this.writeInt8(0xfb);\n      } // TODO: check that n is out of int precision\n\n\n      this.writeInt8(0xfe);\n      this.buffer.writeUInt32LE(n, this.offset);\n      this.offset += 4;\n      this.buffer.writeUInt32LE(n >> 32, this.offset);\n      this.offset += 4;\n      return this.offset;\n    }\n  }, {\n    key: \"writeDate\",\n    value: function writeDate(d, timezone) {\n      this.buffer.writeUInt8(11, this.offset);\n\n      if (!timezone || timezone === 'local') {\n        this.buffer.writeUInt16LE(d.getFullYear(), this.offset + 1);\n        this.buffer.writeUInt8(d.getMonth() + 1, this.offset + 3);\n        this.buffer.writeUInt8(d.getDate(), this.offset + 4);\n        this.buffer.writeUInt8(d.getHours(), this.offset + 5);\n        this.buffer.writeUInt8(d.getMinutes(), this.offset + 6);\n        this.buffer.writeUInt8(d.getSeconds(), this.offset + 7);\n        this.buffer.writeUInt32LE(d.getMilliseconds() * 1000, this.offset + 8);\n      } else {\n        if (timezone !== 'Z') {\n          var offset = (timezone[0] === '-' ? -1 : 1) * (parseInt(timezone.substring(1, 3), 10) * 60 + parseInt(timezone.substring(4), 10));\n\n          if (offset !== 0) {\n            d = new Date(d.getTime() + 60000 * offset);\n          }\n        }\n\n        this.buffer.writeUInt16LE(d.getUTCFullYear(), this.offset + 1);\n        this.buffer.writeUInt8(d.getUTCMonth() + 1, this.offset + 3);\n        this.buffer.writeUInt8(d.getUTCDate(), this.offset + 4);\n        this.buffer.writeUInt8(d.getUTCHours(), this.offset + 5);\n        this.buffer.writeUInt8(d.getUTCMinutes(), this.offset + 6);\n        this.buffer.writeUInt8(d.getUTCSeconds(), this.offset + 7);\n        this.buffer.writeUInt32LE(d.getUTCMilliseconds() * 1000, this.offset + 8);\n      }\n\n      this.offset += 12;\n    }\n  }, {\n    key: \"writeHeader\",\n    value: function writeHeader(sequenceId) {\n      var offset = this.offset;\n      this.offset = 0;\n      this.writeInt24(this.buffer.length - 4);\n      this.writeInt8(sequenceId);\n      this.offset = offset;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Packet(this.sequenceId, this.buffer, this.start, this.end);\n    }\n  }, {\n    key: \"type\",\n    value: function type() {\n      if (this.isEOF()) {\n        return 'EOF';\n      }\n\n      if (this.isError()) {\n        return 'Error';\n      }\n\n      if (this.buffer[this.offset] === 0) {\n        return 'maybeOK'; // could be other packet types as well\n      }\n\n      return '';\n    }\n  }], [{\n    key: \"lengthCodedNumberLength\",\n    value: function lengthCodedNumberLength(n) {\n      if (n < 0xfb) {\n        return 1;\n      }\n\n      if (n < 0xffff) {\n        return 3;\n      }\n\n      if (n < 0xffffff) {\n        return 5;\n      }\n\n      return 9;\n    }\n  }, {\n    key: \"lengthCodedStringLength\",\n    value: function lengthCodedStringLength(str, encoding) {\n      var buf = StringParser.encode(str, encoding);\n      var slen = buf.length;\n      return Packet.lengthCodedNumberLength(slen) + slen;\n    }\n  }, {\n    key: \"MockBuffer\",\n    value: function MockBuffer() {\n      var noop = function noop() {};\n\n      var res = Buffer.alloc(0);\n\n      for (var op in NativeBuffer.prototype) {\n        if (typeof res[op] === 'function') {\n          res[op] = noop;\n        }\n      }\n\n      return res;\n    }\n  }]);\n\n  return Packet;\n}();\n\nmodule.exports = Packet;","map":null,"metadata":{},"sourceType":"script"}