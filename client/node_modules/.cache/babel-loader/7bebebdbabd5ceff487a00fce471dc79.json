{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar Readable = require('stream').Readable;\n\nvar Command = require('./command.js');\n\nvar Packets = require('../packets/index.js');\n\nvar getTextParser = require('../parsers/text_parser.js');\n\nvar ServerStatus = require('../constants/server_status.js');\n\nvar CharsetToEncoding = require('../constants/charset_encodings.js');\n\nvar EmptyPacket = new Packets.Packet(0, Buffer.allocUnsafe(4), 0, 4); // http://dev.mysql.com/doc/internals/en/com-query.html\n\nvar Query = /*#__PURE__*/function (_Command) {\n  _inherits(Query, _Command);\n\n  function Query(options, callback) {\n    var _this;\n\n    _classCallCheck(this, Query);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Query).call(this));\n    _this.sql = options.sql;\n    _this.values = options.values;\n    _this._queryOptions = options;\n    _this.namedPlaceholders = options.namedPlaceholders || false;\n    _this.onResult = callback;\n    _this._fieldCount = 0;\n    _this._rowParser = null;\n    _this._fields = [];\n    _this._rows = [];\n    _this._receivedFieldsCount = 0;\n    _this._resultIndex = 0;\n    _this._localStream = null;\n\n    _this._unpipeStream = function () {};\n\n    _this._streamFactory = options.infileStreamFactory;\n    _this._connection = null;\n    return _this;\n  }\n\n  _createClass(Query, [{\n    key: \"then\",\n    value: function then() {\n      var err = \"You have tried to call .then(), .catch(), or invoked await on the result of query that is not a promise, which is a programming error. Try calling con.promise().query(), or require('mysql2/promise') instead of 'mysql2' for a promise-compatible version of the query interface. To learn how to use async/await or Promises check out documentation at https://www.npmjs.com/package/mysql2#using-promise-wrapper, or the mysql2 documentation at https://github.com/sidorares/node-mysql2/tree/master/documentation/Promise-Wrapper.md\"; // eslint-disable-next-line\n\n      console.log(err);\n      throw new Error(err);\n    }\n  }, {\n    key: \"start\",\n    value: function start(packet, connection) {\n      if (connection.config.debug) {\n        // eslint-disable-next-line\n        console.log('        Sending query command: %s', this.sql);\n      }\n\n      this._connection = connection;\n      this.options = Object.assign({}, connection.config, this._queryOptions);\n      var cmdPacket = new Packets.Query(this.sql, connection.config.charsetNumber);\n      connection.writePacket(cmdPacket.toPacket(1));\n      return Query.prototype.resultsetHeader;\n    }\n  }, {\n    key: \"done\",\n    value: function done() {\n      var _this2 = this;\n\n      this._unpipeStream();\n\n      if (this.onResult) {\n        var rows, fields;\n\n        if (this._resultIndex === 0) {\n          rows = this._rows[0];\n          fields = this._fields[0];\n        } else {\n          rows = this._rows;\n          fields = this._fields;\n        }\n\n        if (fields) {\n          process.nextTick(function () {\n            _this2.onResult(null, rows, fields);\n          });\n        } else {\n          process.nextTick(function () {\n            _this2.onResult(null, rows);\n          });\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"doneInsert\",\n    value: function doneInsert(rs) {\n      if (this._localStreamError) {\n        if (this.onResult) {\n          this.onResult(this._localStreamError, rs);\n        } else {\n          this.emit('error', this._localStreamError);\n        }\n\n        return null;\n      }\n\n      this._rows.push(rs);\n\n      this._fields.push(void 0);\n\n      this.emit('fields', void 0);\n      this.emit('result', rs);\n\n      if (rs.serverStatus & ServerStatus.SERVER_MORE_RESULTS_EXISTS) {\n        this._resultIndex++;\n        return this.resultsetHeader;\n      }\n\n      return this.done();\n    }\n  }, {\n    key: \"resultsetHeader\",\n    value: function resultsetHeader(packet, connection) {\n      var rs = new Packets.ResultSetHeader(packet, connection);\n      this._fieldCount = rs.fieldCount;\n\n      if (connection.config.debug) {\n        // eslint-disable-next-line\n        console.log(\"        Resultset header received, expecting \".concat(rs.fieldCount, \" column definition packets\"));\n      }\n\n      if (this._fieldCount === 0) {\n        return this.doneInsert(rs);\n      }\n\n      if (this._fieldCount === null) {\n        return this._streamLocalInfile(connection, rs.infileName);\n      }\n\n      this._receivedFieldsCount = 0;\n\n      this._rows.push([]);\n\n      this._fields.push([]);\n\n      return this.readField;\n    }\n  }, {\n    key: \"_streamLocalInfile\",\n    value: function _streamLocalInfile(connection, path) {\n      var _this3 = this;\n\n      if (this._streamFactory) {\n        this._localStream = this._streamFactory(path);\n      } else {\n        this._localStreamError = new Error(\"As a result of LOCAL INFILE command server wants to read \".concat(path, \" file, but as of v2.0 you must provide streamFactory option returning ReadStream.\"));\n        connection.writePacket(EmptyPacket);\n        return this.infileOk;\n      }\n\n      var onConnectionError = function onConnectionError() {\n        _this3._unpipeStream();\n      };\n\n      var onDrain = function onDrain() {\n        _this3._localStream.resume();\n      };\n\n      var onPause = function onPause() {\n        _this3._localStream.pause();\n      };\n\n      var onData = function onData(data) {\n        var dataWithHeader = Buffer.allocUnsafe(data.length + 4);\n        data.copy(dataWithHeader, 4);\n        connection.writePacket(new Packets.Packet(0, dataWithHeader, 0, dataWithHeader.length));\n      };\n\n      var onEnd = function onEnd() {\n        connection.removeListener('error', onConnectionError);\n        connection.writePacket(EmptyPacket);\n      };\n\n      var onError = function onError(err) {\n        _this3._localStreamError = err;\n        connection.removeListener('error', onConnectionError);\n        connection.writePacket(EmptyPacket);\n      };\n\n      this._unpipeStream = function () {\n        connection.stream.removeListener('pause', onPause);\n        connection.stream.removeListener('drain', onDrain);\n\n        _this3._localStream.removeListener('data', onData);\n\n        _this3._localStream.removeListener('end', onEnd);\n\n        _this3._localStream.removeListener('error', onError);\n      };\n\n      connection.stream.on('pause', onPause);\n      connection.stream.on('drain', onDrain);\n\n      this._localStream.on('data', onData);\n\n      this._localStream.on('end', onEnd);\n\n      this._localStream.on('error', onError);\n\n      connection.once('error', onConnectionError);\n      return this.infileOk;\n    }\n  }, {\n    key: \"readField\",\n    value: function readField(packet, connection) {\n      this._receivedFieldsCount++; // Often there is much more data in the column definition than in the row itself\n      // If you set manually _fields[0] to array of ColumnDefinition's (from previous call)\n      // you can 'cache' result of parsing. Field packets still received, but ignored in that case\n      // this is the reason _receivedFieldsCount exist (otherwise we could just use current length of fields array)\n\n      if (this._fields[this._resultIndex].length !== this._fieldCount) {\n        var field = new Packets.ColumnDefinition(packet, connection.clientEncoding);\n\n        this._fields[this._resultIndex].push(field);\n\n        if (connection.config.debug) {\n          /* eslint-disable no-console */\n          console.log('        Column definition:');\n          console.log(\"          name: \".concat(field.name));\n          console.log(\"          type: \".concat(field.columnType));\n          console.log(\"         flags: \".concat(field.flags));\n          /* eslint-enable no-console */\n        }\n      } // last field received\n\n\n      if (this._receivedFieldsCount === this._fieldCount) {\n        var fields = this._fields[this._resultIndex];\n        this.emit('fields', fields);\n        this._rowParser = getTextParser(fields, this.options, connection.config);\n        return Query.prototype.fieldsEOF;\n      }\n\n      return Query.prototype.readField;\n    }\n  }, {\n    key: \"fieldsEOF\",\n    value: function fieldsEOF(packet, connection) {\n      // check EOF\n      if (!packet.isEOF()) {\n        return connection.protocolError('Expected EOF packet');\n      }\n\n      return this.row;\n    }\n  }, {\n    key: \"row\",\n    value: function row(packet) {\n      if (packet.isEOF()) {\n        var status = packet.eofStatusFlags();\n        var moreResults = status & ServerStatus.SERVER_MORE_RESULTS_EXISTS;\n\n        if (moreResults) {\n          this._resultIndex++;\n          return Query.prototype.resultsetHeader;\n        }\n\n        return this.done();\n      }\n\n      var row = new this._rowParser(packet, this._fields[this._resultIndex], this.options, CharsetToEncoding);\n\n      if (this.onResult) {\n        this._rows[this._resultIndex].push(row);\n      } else {\n        this.emit('result', row);\n      }\n\n      return Query.prototype.row;\n    }\n  }, {\n    key: \"infileOk\",\n    value: function infileOk(packet, connection) {\n      var rs = new Packets.ResultSetHeader(packet, connection);\n      return this.doneInsert(rs);\n    }\n  }, {\n    key: \"stream\",\n    value: function stream(options) {\n      var _this4 = this;\n\n      options = options || {};\n      options.objectMode = true;\n      var stream = new Readable(options);\n\n      stream._read = function () {\n        _this4._connection && _this4._connection.resume();\n      };\n\n      this.on('result', function (row) {\n        if (!stream.push(row)) {\n          _this4._connection.pause();\n        }\n\n        stream.emit('result', row); // replicate old emitter\n      });\n      this.on('error', function (err) {\n        stream.emit('error', err); // Pass on any errors\n      });\n      this.on('end', function () {\n        stream.push(null); // pushing null, indicating EOF\n\n        stream.emit('close'); // notify readers that query has completed\n      });\n      this.on('fields', function (fields) {\n        stream.emit('fields', fields); // replicate old emitter\n      });\n      return stream;\n    }\n  }]);\n\n  return Query;\n}(Command);\n\nQuery.prototype.catch = Query.prototype.then;\nmodule.exports = Query;","map":null,"metadata":{},"sourceType":"script"}