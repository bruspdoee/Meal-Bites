{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _defineProperty = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _asyncToGenerator = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _objectSpread = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar Utils = require('./../utils');\n\nvar Helpers = require('./helpers');\n\nvar _ = require('lodash');\n\nvar Association = require('./base');\n\nvar BelongsTo = require('./belongs-to');\n\nvar HasMany = require('./has-many');\n\nvar HasOne = require('./has-one');\n\nvar AssociationError = require('../errors').AssociationError;\n\nvar EmptyResultError = require('../errors').EmptyResultError;\n\nvar Op = require('../operators');\n/**\n * Many-to-many association with a join table.\n *\n * When the join table has additional attributes, these can be passed in the options object:\n *\n * ```js\n * UserProject = sequelize.define('user_project', {\n *   role: Sequelize.STRING\n * });\n * User.belongsToMany(Project, { through: UserProject });\n * Project.belongsToMany(User, { through: UserProject });\n * // through is required!\n *\n * user.addProject(project, { through: { role: 'manager' }});\n * ```\n *\n * All methods allow you to pass either a persisted instance, its primary key, or a mixture:\n *\n * ```js\n * const project = await Project.create({ id: 11 });\n * await user.addProjects([project, 12]);\n * ```\n *\n * If you want to set several target instances, but with different attributes you have to set the attributes on the instance, using a property with the name of the through model:\n *\n * ```js\n * p1.UserProjects = {\n *   started: true\n * }\n * user.setProjects([p1, p2], { through: { started: false }}) // The default value is false, but p1 overrides that.\n * ```\n *\n * Similarly, when fetching through a join table with custom attributes, these attributes will be available as an object with the name of the through model.\n * ```js\n * const projects = await user.getProjects();\n * const p1 = projects[0];\n * p1.UserProjects.started // Is this project started yet?\n * })\n * ```\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.belongsToMany(Project)` the getter will be `user.getProjects()`.\n *\n * @see {@link Model.belongsToMany}\n */\n\n\nvar BelongsToMany = /*#__PURE__*/function (_Association) {\n  _inherits(BelongsToMany, _Association);\n\n  function BelongsToMany(source, target, options) {\n    var _this;\n\n    _classCallCheck(this, BelongsToMany);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(BelongsToMany).call(this, source, target, options));\n\n    if (_this.options.through === undefined || _this.options.through === true || _this.options.through === null) {\n      throw new AssociationError(\"\".concat(source.name, \".belongsToMany(\").concat(target.name, \") requires through option, pass either a string or a model\"));\n    }\n\n    if (!_this.options.through.model) {\n      _this.options.through = {\n        model: options.through\n      };\n    }\n\n    _this.associationType = 'BelongsToMany';\n    _this.targetAssociation = null;\n    _this.sequelize = source.sequelize;\n    _this.through = _objectSpread({}, _this.options.through);\n    _this.isMultiAssociation = true;\n    _this.doubleLinked = false;\n\n    if (!_this.as && _this.isSelfAssociation) {\n      throw new AssociationError('\\'as\\' must be defined for many-to-many self-associations');\n    }\n\n    if (_this.as) {\n      _this.isAliased = true;\n\n      if (_.isPlainObject(_this.as)) {\n        _this.options.name = _this.as;\n        _this.as = _this.as.plural;\n      } else {\n        _this.options.name = {\n          plural: _this.as,\n          singular: Utils.singularize(_this.as)\n        };\n      }\n    } else {\n      _this.as = _this.target.options.name.plural;\n      _this.options.name = _this.target.options.name;\n    }\n\n    _this.combinedTableName = Utils.combineTableNames(_this.source.tableName, _this.isSelfAssociation ? _this.as || _this.target.tableName : _this.target.tableName);\n    /*\n    * If self association, this is the target association - Unless we find a pairing association\n    */\n\n    if (_this.isSelfAssociation) {\n      _this.targetAssociation = _assertThisInitialized(_assertThisInitialized(_this));\n    }\n    /*\n    * Find paired association (if exists)\n    */\n\n\n    _.each(_this.target.associations, function (association) {\n      if (association.associationType !== 'BelongsToMany') return;\n      if (association.target !== _this.source) return;\n\n      if (_this.options.through.model === association.options.through.model) {\n        _this.paired = association;\n        association.paired = _assertThisInitialized(_assertThisInitialized(_this));\n      }\n    });\n    /*\n    * Default/generated source/target keys\n    */\n\n\n    _this.sourceKey = _this.options.sourceKey || _this.source.primaryKeyAttribute;\n    _this.sourceKeyField = _this.source.rawAttributes[_this.sourceKey].field || _this.sourceKey;\n\n    if (_this.options.targetKey) {\n      _this.targetKey = _this.options.targetKey;\n      _this.targetKeyField = _this.target.rawAttributes[_this.targetKey].field || _this.targetKey;\n    } else {\n      _this.targetKeyDefault = true;\n      _this.targetKey = _this.target.primaryKeyAttribute;\n      _this.targetKeyField = _this.target.rawAttributes[_this.targetKey].field || _this.targetKey;\n    }\n\n    _this._createForeignAndOtherKeys();\n\n    if (typeof _this.through.model === 'string') {\n      if (!_this.sequelize.isDefined(_this.through.model)) {\n        _this.through.model = _this.sequelize.define(_this.through.model, {}, Object.assign(_this.options, {\n          tableName: _this.through.model,\n          indexes: [],\n          //we don't want indexes here (as referenced in #2416)\n          paranoid: _this.through.paranoid ? _this.through.paranoid : false,\n          // Default to non-paranoid join (referenced in #11991)\n          validate: {} // Don't propagate model-level validations\n\n        }));\n      } else {\n        _this.through.model = _this.sequelize.model(_this.through.model);\n      }\n    }\n\n    Object.assign(_this.options, _.pick(_this.through.model.options, ['timestamps', 'createdAt', 'updatedAt', 'deletedAt', 'paranoid']));\n\n    if (_this.paired) {\n      var needInjectPaired = false;\n\n      if (_this.targetKeyDefault) {\n        _this.targetKey = _this.paired.sourceKey;\n        _this.targetKeyField = _this.paired.sourceKeyField;\n\n        _this._createForeignAndOtherKeys();\n      }\n\n      if (_this.paired.targetKeyDefault) {\n        // in this case paired.otherKey depends on paired.targetKey,\n        // so cleanup previously wrong generated otherKey\n        if (_this.paired.targetKey !== _this.sourceKey) {\n          delete _this.through.model.rawAttributes[_this.paired.otherKey];\n          _this.paired.targetKey = _this.sourceKey;\n          _this.paired.targetKeyField = _this.sourceKeyField;\n\n          _this.paired._createForeignAndOtherKeys();\n\n          needInjectPaired = true;\n        }\n      }\n\n      if (_this.otherKeyDefault) {\n        _this.otherKey = _this.paired.foreignKey;\n      }\n\n      if (_this.paired.otherKeyDefault) {\n        // If paired otherKey was inferred we should make sure to clean it up\n        // before adding a new one that matches the foreignKey\n        if (_this.paired.otherKey !== _this.foreignKey) {\n          delete _this.through.model.rawAttributes[_this.paired.otherKey];\n          _this.paired.otherKey = _this.foreignKey;\n          needInjectPaired = true;\n        }\n      }\n\n      if (needInjectPaired) {\n        _this.paired._injectAttributes();\n      }\n    }\n\n    if (_this.through) {\n      _this.throughModel = _this.through.model;\n    }\n\n    _this.options.tableName = _this.combinedName = _this.through.model === Object(_this.through.model) ? _this.through.model.tableName : _this.through.model;\n    _this.associationAccessor = _this.as; // Get singular and plural names, trying to uppercase the first letter, unless the model forbids it\n\n    var plural = _.upperFirst(_this.options.name.plural);\n\n    var singular = _.upperFirst(_this.options.name.singular);\n\n    _this.accessors = {\n      get: \"get\".concat(plural),\n      set: \"set\".concat(plural),\n      addMultiple: \"add\".concat(plural),\n      add: \"add\".concat(singular),\n      create: \"create\".concat(singular),\n      remove: \"remove\".concat(singular),\n      removeMultiple: \"remove\".concat(plural),\n      hasSingle: \"has\".concat(singular),\n      hasAll: \"has\".concat(plural),\n      count: \"count\".concat(plural)\n    };\n    return _this;\n  }\n\n  _createClass(BelongsToMany, [{\n    key: \"_createForeignAndOtherKeys\",\n    value: function _createForeignAndOtherKeys() {\n      /*\n      * Default/generated foreign/other keys\n      */\n      if (_.isObject(this.options.foreignKey)) {\n        this.foreignKeyAttribute = this.options.foreignKey;\n        this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n      } else {\n        this.foreignKeyAttribute = {};\n        this.foreignKey = this.options.foreignKey || Utils.camelize([this.source.options.name.singular, this.sourceKey].join('_'));\n      }\n\n      if (_.isObject(this.options.otherKey)) {\n        this.otherKeyAttribute = this.options.otherKey;\n        this.otherKey = this.otherKeyAttribute.name || this.otherKeyAttribute.fieldName;\n      } else {\n        if (!this.options.otherKey) {\n          this.otherKeyDefault = true;\n        }\n\n        this.otherKeyAttribute = {};\n        this.otherKey = this.options.otherKey || Utils.camelize([this.isSelfAssociation ? Utils.singularize(this.as) : this.target.options.name.singular, this.targetKey].join('_'));\n      }\n    } // the id is in the target table\n    // or in an extra table which connects two tables\n\n  }, {\n    key: \"_injectAttributes\",\n    value: function _injectAttributes() {\n      var _this2 = this;\n\n      this.identifier = this.foreignKey;\n      this.foreignIdentifier = this.otherKey; // remove any PKs previously defined by sequelize\n      // but ignore any keys that are part of this association (#5865)\n\n      _.each(this.through.model.rawAttributes, function (attribute, attributeName) {\n        if (attribute.primaryKey === true && attribute._autoGenerated === true) {\n          if (attributeName === _this2.foreignKey || attributeName === _this2.otherKey) {\n            // this key is still needed as it's part of the association\n            // so just set primaryKey to false\n            attribute.primaryKey = false;\n          } else {\n            delete _this2.through.model.rawAttributes[attributeName];\n          }\n\n          _this2.primaryKeyDeleted = true;\n        }\n      });\n\n      var sourceKey = this.source.rawAttributes[this.sourceKey];\n      var sourceKeyType = sourceKey.type;\n      var sourceKeyField = this.sourceKeyField;\n      var targetKey = this.target.rawAttributes[this.targetKey];\n      var targetKeyType = targetKey.type;\n      var targetKeyField = this.targetKeyField;\n\n      var sourceAttribute = _objectSpread({\n        type: sourceKeyType\n      }, this.foreignKeyAttribute);\n\n      var targetAttribute = _objectSpread({\n        type: targetKeyType\n      }, this.otherKeyAttribute);\n\n      if (this.primaryKeyDeleted === true) {\n        targetAttribute.primaryKey = sourceAttribute.primaryKey = true;\n      } else if (this.through.unique !== false) {\n        var uniqueKey;\n\n        if (typeof this.options.uniqueKey === 'string' && this.options.uniqueKey !== '') {\n          uniqueKey = this.options.uniqueKey;\n        } else {\n          uniqueKey = [this.through.model.tableName, this.foreignKey, this.otherKey, 'unique'].join('_');\n        }\n\n        targetAttribute.unique = sourceAttribute.unique = uniqueKey;\n      }\n\n      if (!this.through.model.rawAttributes[this.foreignKey]) {\n        this.through.model.rawAttributes[this.foreignKey] = {\n          _autoGenerated: true\n        };\n      }\n\n      if (!this.through.model.rawAttributes[this.otherKey]) {\n        this.through.model.rawAttributes[this.otherKey] = {\n          _autoGenerated: true\n        };\n      }\n\n      if (this.options.constraints !== false) {\n        sourceAttribute.references = {\n          model: this.source.getTableName(),\n          key: sourceKeyField\n        }; // For the source attribute the passed option is the priority\n\n        sourceAttribute.onDelete = this.options.onDelete || this.through.model.rawAttributes[this.foreignKey].onDelete;\n        sourceAttribute.onUpdate = this.options.onUpdate || this.through.model.rawAttributes[this.foreignKey].onUpdate;\n        if (!sourceAttribute.onDelete) sourceAttribute.onDelete = 'CASCADE';\n        if (!sourceAttribute.onUpdate) sourceAttribute.onUpdate = 'CASCADE';\n        targetAttribute.references = {\n          model: this.target.getTableName(),\n          key: targetKeyField\n        }; // But the for target attribute the previously defined option is the priority (since it could've been set by another belongsToMany call)\n\n        targetAttribute.onDelete = this.through.model.rawAttributes[this.otherKey].onDelete || this.options.onDelete;\n        targetAttribute.onUpdate = this.through.model.rawAttributes[this.otherKey].onUpdate || this.options.onUpdate;\n        if (!targetAttribute.onDelete) targetAttribute.onDelete = 'CASCADE';\n        if (!targetAttribute.onUpdate) targetAttribute.onUpdate = 'CASCADE';\n      }\n\n      Object.assign(this.through.model.rawAttributes[this.foreignKey], sourceAttribute);\n      Object.assign(this.through.model.rawAttributes[this.otherKey], targetAttribute);\n      this.through.model.refreshAttributes();\n      this.identifierField = this.through.model.rawAttributes[this.foreignKey].field || this.foreignKey;\n      this.foreignIdentifierField = this.through.model.rawAttributes[this.otherKey].field || this.otherKey;\n\n      if (this.paired && !this.paired.foreignIdentifierField) {\n        this.paired.foreignIdentifierField = this.through.model.rawAttributes[this.paired.otherKey].field || this.paired.otherKey;\n      }\n\n      this.toSource = new BelongsTo(this.through.model, this.source, {\n        foreignKey: this.foreignKey\n      });\n      this.manyFromSource = new HasMany(this.source, this.through.model, {\n        foreignKey: this.foreignKey\n      });\n      this.oneFromSource = new HasOne(this.source, this.through.model, {\n        foreignKey: this.foreignKey,\n        sourceKey: this.sourceKey,\n        as: this.through.model.name\n      });\n      this.toTarget = new BelongsTo(this.through.model, this.target, {\n        foreignKey: this.otherKey\n      });\n      this.manyFromTarget = new HasMany(this.target, this.through.model, {\n        foreignKey: this.otherKey\n      });\n      this.oneFromTarget = new HasOne(this.target, this.through.model, {\n        foreignKey: this.otherKey,\n        sourceKey: this.targetKey,\n        as: this.through.model.name\n      });\n\n      if (this.paired && this.paired.otherKeyDefault) {\n        this.paired.toTarget = new BelongsTo(this.paired.through.model, this.paired.target, {\n          foreignKey: this.paired.otherKey\n        });\n        this.paired.oneFromTarget = new HasOne(this.paired.target, this.paired.through.model, {\n          foreignKey: this.paired.otherKey,\n          sourceKey: this.paired.targetKey,\n          as: this.paired.through.model.name\n        });\n      }\n\n      Helpers.checkNamingCollision(this);\n      return this;\n    }\n  }, {\n    key: \"mixin\",\n    value: function mixin(obj) {\n      var methods = ['get', 'count', 'hasSingle', 'hasAll', 'set', 'add', 'addMultiple', 'remove', 'removeMultiple', 'create'];\n      var aliases = {\n        hasSingle: 'has',\n        hasAll: 'has',\n        addMultiple: 'add',\n        removeMultiple: 'remove'\n      };\n      Helpers.mixinMethods(this, obj, methods, aliases);\n    }\n    /**\n     * Get everything currently associated with this, using an optional where clause.\n     *\n     * @see\n     * {@link Model} for a full explanation of options\n     *\n     * @param {Model} instance instance\n     * @param {object} [options] find options\n     * @param {object} [options.where] An optional where clause to limit the associated models\n     * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n     * @param {string} [options.schema] Apply a schema on the related model\n     * @param {object} [options.through.where] An optional where clause applied to through model (join table)\n     * @param {boolean} [options.through.paranoid=true] If true, only non-deleted records will be returned from the join table. If false, both deleted and non-deleted records will be returned. Only applies if through model is paranoid\n     *\n     * @returns {Promise<Array<Model>>}\n     */\n\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(instance, options) {\n        var through, scopeWhere, throughWhere, model;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = Utils.cloneDeep(options) || {};\n                through = this.through;\n\n                if (this.scope) {\n                  scopeWhere = _objectSpread({}, this.scope);\n                }\n\n                options.where = _defineProperty({}, Op.and, [scopeWhere, options.where]);\n\n                if (Object(through.model) === through.model) {\n                  throughWhere = {};\n                  throughWhere[this.foreignKey] = instance.get(this.sourceKey);\n\n                  if (through.scope) {\n                    Object.assign(throughWhere, through.scope);\n                  } //If a user pass a where on the options through options, make an \"and\" with the current throughWhere\n\n\n                  if (options.through && options.through.where) {\n                    throughWhere = _defineProperty({}, Op.and, [throughWhere, options.through.where]);\n                  }\n\n                  options.include = options.include || [];\n                  options.include.push({\n                    association: this.oneFromTarget,\n                    attributes: options.joinTableAttributes,\n                    required: true,\n                    paranoid: _.get(options.through, 'paranoid', true),\n                    where: throughWhere\n                  });\n                }\n\n                model = this.target;\n\n                if (Object.prototype.hasOwnProperty.call(options, 'scope')) {\n                  if (!options.scope) {\n                    model = model.unscoped();\n                  } else {\n                    model = model.scope(options.scope);\n                  }\n                }\n\n                if (Object.prototype.hasOwnProperty.call(options, 'schema')) {\n                  model = model.schema(options.schema, options.schemaDelimiter);\n                }\n\n                return _context.abrupt(\"return\", model.findAll(options));\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function get(_x, _x2) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n    /**\n     * Count everything currently associated with this, using an optional where clause.\n     *\n     * @param {Model} instance instance\n     * @param {object} [options] find options\n     * @param {object} [options.where] An optional where clause to limit the associated models\n     * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n     *\n     * @returns {Promise<number>}\n     */\n\n  }, {\n    key: \"count\",\n    value: function () {\n      var _count = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(instance, options) {\n        var sequelize, result;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                sequelize = this.target.sequelize;\n                options = Utils.cloneDeep(options);\n                options.attributes = [[sequelize.fn('COUNT', sequelize.col([this.target.name, this.targetKeyField].join('.'))), 'count']];\n                options.joinTableAttributes = [];\n                options.raw = true;\n                options.plain = true;\n                _context2.next = 8;\n                return this.get(instance, options);\n\n              case 8:\n                result = _context2.sent;\n                return _context2.abrupt(\"return\", parseInt(result.count, 10));\n\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function count(_x3, _x4) {\n        return _count.apply(this, arguments);\n      }\n\n      return count;\n    }()\n    /**\n     * Check if one or more instance(s) are associated with this. If a list of instances is passed, the function returns true if _all_ instances are associated\n     *\n     * @param {Model} sourceInstance source instance to check for an association with\n     * @param {Model|Model[]|string[]|string|number[]|number} [instances] Can be an array of instances or their primary keys\n     * @param {object} [options] Options passed to getAssociations\n     *\n     * @returns {Promise<boolean>}\n     */\n\n  }, {\n    key: \"has\",\n    value: function () {\n      var _has = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(sourceInstance, instances, options) {\n        var _this3 = this;\n\n        var instancePrimaryKeys, associatedObjects;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!Array.isArray(instances)) {\n                  instances = [instances];\n                }\n\n                options = _objectSpread({\n                  raw: true\n                }, options, {\n                  scope: false,\n                  attributes: [this.targetKey],\n                  joinTableAttributes: []\n                });\n                instancePrimaryKeys = instances.map(function (instance) {\n                  if (instance instanceof _this3.target) {\n                    return instance.where();\n                  }\n\n                  return _defineProperty({}, _this3.targetKey, instance);\n                });\n                options.where = _defineProperty({}, Op.and, [_defineProperty({}, Op.or, instancePrimaryKeys), options.where]);\n                _context3.next = 6;\n                return this.get(sourceInstance, options);\n\n              case 6:\n                associatedObjects = _context3.sent;\n                return _context3.abrupt(\"return\", _.differenceWith(instancePrimaryKeys, associatedObjects, function (a, b) {\n                  return _.isEqual(a[_this3.targetKey], b[_this3.targetKey]);\n                }).length === 0);\n\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function has(_x5, _x6, _x7) {\n        return _has.apply(this, arguments);\n      }\n\n      return has;\n    }()\n    /**\n     * Set the associated models by passing an array of instances or their primary keys.\n     * Everything that it not in the passed array will be un-associated.\n     *\n     * @param {Model} sourceInstance source instance to associate new instances with\n     * @param {Model|Model[]|string[]|string|number[]|number} [newAssociatedObjects] A single instance or primary key, or a mixed array of persisted instances or primary keys\n     * @param {object} [options] Options passed to `through.findAll`, `bulkCreate`, `update` and `destroy`\n     * @param {object} [options.validate] Run validation for the join model\n     * @param {object} [options.through] Additional attributes for the join table.\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"set\",\n    value: function () {\n      var _set = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(sourceInstance, newAssociatedObjects, options) {\n        var _this4 = this;\n\n        var sourceKey, targetKey, identifier, foreignIdentifier, where, updateAssociations, currentRows;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                options = options || {};\n                sourceKey = this.sourceKey;\n                targetKey = this.targetKey;\n                identifier = this.identifier;\n                foreignIdentifier = this.foreignIdentifier;\n\n                if (newAssociatedObjects === null) {\n                  newAssociatedObjects = [];\n                } else {\n                  newAssociatedObjects = this.toInstanceArray(newAssociatedObjects);\n                }\n\n                where = _objectSpread(_defineProperty({}, identifier, sourceInstance.get(sourceKey)), this.through.scope);\n\n                updateAssociations = function updateAssociations(currentRows) {\n                  var obsoleteAssociations = [];\n                  var promises = [];\n                  var defaultAttributes = options.through || {};\n                  var unassociatedObjects = newAssociatedObjects.filter(function (obj) {\n                    return !currentRows.some(function (currentRow) {\n                      return currentRow[foreignIdentifier] === obj.get(targetKey);\n                    });\n                  });\n\n                  var _iterator = _createForOfIteratorHelper(currentRows),\n                      _step;\n\n                  try {\n                    var _loop = function _loop() {\n                      var currentRow = _step.value;\n                      var newObj = newAssociatedObjects.find(function (obj) {\n                        return currentRow[foreignIdentifier] === obj.get(targetKey);\n                      });\n\n                      if (!newObj) {\n                        obsoleteAssociations.push(currentRow);\n                      } else {\n                        var throughAttributes = newObj[_this4.through.model.name]; // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)\n\n                        if (throughAttributes instanceof _this4.through.model) {\n                          throughAttributes = {};\n                        }\n\n                        var attributes = _objectSpread({}, defaultAttributes, throughAttributes);\n\n                        if (Object.keys(attributes).length) {\n                          var _where;\n\n                          promises.push(_this4.through.model.update(attributes, Object.assign(options, {\n                            where: (_where = {}, _defineProperty(_where, identifier, sourceInstance.get(sourceKey)), _defineProperty(_where, foreignIdentifier, newObj.get(targetKey)), _where)\n                          })));\n                        }\n                      }\n                    };\n\n                    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                      _loop();\n                    }\n                  } catch (err) {\n                    _iterator.e(err);\n                  } finally {\n                    _iterator.f();\n                  }\n\n                  if (obsoleteAssociations.length > 0) {\n                    var _objectSpread3;\n\n                    promises.push(_this4.through.model.destroy(_objectSpread({}, options, {\n                      where: _objectSpread((_objectSpread3 = {}, _defineProperty(_objectSpread3, identifier, sourceInstance.get(sourceKey)), _defineProperty(_objectSpread3, foreignIdentifier, obsoleteAssociations.map(function (obsoleteAssociation) {\n                        return obsoleteAssociation[foreignIdentifier];\n                      })), _objectSpread3), _this4.through.scope)\n                    })));\n                  }\n\n                  if (unassociatedObjects.length > 0) {\n                    var bulk = unassociatedObjects.map(function (unassociatedObject) {\n                      var _objectSpread4;\n\n                      return _objectSpread({}, defaultAttributes, unassociatedObject[_this4.through.model.name], (_objectSpread4 = {}, _defineProperty(_objectSpread4, identifier, sourceInstance.get(sourceKey)), _defineProperty(_objectSpread4, foreignIdentifier, unassociatedObject.get(targetKey)), _objectSpread4), _this4.through.scope);\n                    });\n                    promises.push(_this4.through.model.bulkCreate(bulk, _objectSpread({\n                      validate: true\n                    }, options)));\n                  }\n\n                  return Promise.all(promises);\n                };\n\n                _context4.prev = 8;\n                _context4.next = 11;\n                return this.through.model.findAll(_objectSpread({}, options, {\n                  where: where,\n                  raw: true\n                }));\n\n              case 11:\n                currentRows = _context4.sent;\n                _context4.next = 14;\n                return updateAssociations(currentRows);\n\n              case 14:\n                return _context4.abrupt(\"return\", _context4.sent);\n\n              case 17:\n                _context4.prev = 17;\n                _context4.t0 = _context4[\"catch\"](8);\n\n                if (!(_context4.t0 instanceof EmptyResultError)) {\n                  _context4.next = 21;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", updateAssociations([]));\n\n              case 21:\n                throw _context4.t0;\n\n              case 22:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[8, 17]]);\n      }));\n\n      function set(_x8, _x9, _x10) {\n        return _set.apply(this, arguments);\n      }\n\n      return set;\n    }()\n    /**\n     * Associate one or several rows with source instance. It will not un-associate any already associated instance\n     * that may be missing from `newInstances`.\n     *\n     * @param {Model} sourceInstance source instance to associate new instances with\n     * @param {Model|Model[]|string[]|string|number[]|number} [newInstances] A single instance or primary key, or a mixed array of persisted instances or primary keys\n     * @param {object} [options] Options passed to `through.findAll`, `bulkCreate` and `update`\n     * @param {object} [options.validate] Run validation for the join model.\n     * @param {object} [options.through] Additional attributes for the join table.\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"add\",\n    value: function () {\n      var _add = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(sourceInstance, newInstances, options) {\n        var _objectSpread5;\n\n        var association, sourceKey, targetKey, identifier, foreignIdentifier, defaultAttributes, where, updateAssociations, currentRows, _yield$updateAssociat, _yield$updateAssociat2, associations;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (newInstances) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", Promise.resolve());\n\n              case 2:\n                options = _objectSpread({}, options);\n                association = this;\n                sourceKey = association.sourceKey;\n                targetKey = association.targetKey;\n                identifier = association.identifier;\n                foreignIdentifier = association.foreignIdentifier;\n                defaultAttributes = options.through || {};\n                newInstances = association.toInstanceArray(newInstances);\n                where = _objectSpread((_objectSpread5 = {}, _defineProperty(_objectSpread5, identifier, sourceInstance.get(sourceKey)), _defineProperty(_objectSpread5, foreignIdentifier, newInstances.map(function (newInstance) {\n                  return newInstance.get(targetKey);\n                })), _objectSpread5), association.through.scope);\n\n                updateAssociations = function updateAssociations(currentRows) {\n                  var promises = [];\n                  var unassociatedObjects = [];\n                  var changedAssociations = [];\n\n                  var _iterator2 = _createForOfIteratorHelper(newInstances),\n                      _step2;\n\n                  try {\n                    var _loop2 = function _loop2() {\n                      var obj = _step2.value;\n                      var existingAssociation = currentRows && currentRows.find(function (current) {\n                        return current[foreignIdentifier] === obj.get(targetKey);\n                      });\n\n                      if (!existingAssociation) {\n                        unassociatedObjects.push(obj);\n                      } else {\n                        var _throughAttributes = obj[association.through.model.name];\n\n                        var _attributes = _objectSpread({}, defaultAttributes, _throughAttributes);\n\n                        if (Object.keys(_attributes).some(function (attribute) {\n                          return _attributes[attribute] !== existingAssociation[attribute];\n                        })) {\n                          changedAssociations.push(obj);\n                        }\n                      }\n                    };\n\n                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                      _loop2();\n                    }\n                  } catch (err) {\n                    _iterator2.e(err);\n                  } finally {\n                    _iterator2.f();\n                  }\n\n                  if (unassociatedObjects.length > 0) {\n                    var bulk = unassociatedObjects.map(function (unassociatedObject) {\n                      var throughAttributes = unassociatedObject[association.through.model.name];\n\n                      var attributes = _objectSpread({}, defaultAttributes, throughAttributes);\n\n                      attributes[identifier] = sourceInstance.get(sourceKey);\n                      attributes[foreignIdentifier] = unassociatedObject.get(targetKey);\n                      Object.assign(attributes, association.through.scope);\n                      return attributes;\n                    });\n                    promises.push(association.through.model.bulkCreate(bulk, _objectSpread({\n                      validate: true\n                    }, options)));\n                  }\n\n                  for (var _i = 0, _changedAssociations = changedAssociations; _i < _changedAssociations.length; _i++) {\n                    var _where2;\n\n                    var assoc = _changedAssociations[_i];\n                    var throughAttributes = assoc[association.through.model.name];\n\n                    var attributes = _objectSpread({}, defaultAttributes, throughAttributes); // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)\n\n\n                    if (throughAttributes instanceof association.through.model) {\n                      throughAttributes = {};\n                    }\n\n                    promises.push(association.through.model.update(attributes, Object.assign(options, {\n                      where: (_where2 = {}, _defineProperty(_where2, identifier, sourceInstance.get(sourceKey)), _defineProperty(_where2, foreignIdentifier, assoc.get(targetKey)), _where2)\n                    })));\n                  }\n\n                  return Promise.all(promises);\n                };\n\n                _context5.prev = 12;\n                _context5.next = 15;\n                return association.through.model.findAll(_objectSpread({}, options, {\n                  where: where,\n                  raw: true\n                }));\n\n              case 15:\n                currentRows = _context5.sent;\n                _context5.next = 18;\n                return updateAssociations(currentRows);\n\n              case 18:\n                _yield$updateAssociat = _context5.sent;\n                _yield$updateAssociat2 = _slicedToArray(_yield$updateAssociat, 1);\n                associations = _yield$updateAssociat2[0];\n                return _context5.abrupt(\"return\", associations);\n\n              case 24:\n                _context5.prev = 24;\n                _context5.t0 = _context5[\"catch\"](12);\n\n                if (!(_context5.t0 instanceof EmptyResultError)) {\n                  _context5.next = 28;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", updateAssociations());\n\n              case 28:\n                throw _context5.t0;\n\n              case 29:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[12, 24]]);\n      }));\n\n      function add(_x11, _x12, _x13) {\n        return _add.apply(this, arguments);\n      }\n\n      return add;\n    }()\n    /**\n     * Un-associate one or more instance(s).\n     *\n     * @param {Model} sourceInstance instance to un associate instances with\n     * @param {Model|Model[]|string|string[]|number|number[]} [oldAssociatedObjects] Can be an Instance or its primary key, or a mixed array of instances and primary keys\n     * @param {object} [options] Options passed to `through.destroy`\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(sourceInstance, oldAssociatedObjects, options) {\n      var _where3;\n\n      var association = this;\n      options = options || {};\n      oldAssociatedObjects = association.toInstanceArray(oldAssociatedObjects);\n      var where = (_where3 = {}, _defineProperty(_where3, association.identifier, sourceInstance.get(association.sourceKey)), _defineProperty(_where3, association.foreignIdentifier, oldAssociatedObjects.map(function (newInstance) {\n        return newInstance.get(association.targetKey);\n      })), _where3);\n      return association.through.model.destroy(_objectSpread({}, options, {\n        where: where\n      }));\n    }\n    /**\n     * Create a new instance of the associated model and associate it with this.\n     *\n     * @param {Model} sourceInstance source instance\n     * @param {object} [values] values for target model\n     * @param {object} [options] Options passed to create and add\n     * @param {object} [options.through] Additional attributes for the join table\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"create\",\n    value: function () {\n      var _create = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(sourceInstance, values, options) {\n        var association, newAssociatedObject;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                association = this;\n                options = options || {};\n                values = values || {};\n\n                if (Array.isArray(options)) {\n                  options = {\n                    fields: options\n                  };\n                }\n\n                if (association.scope) {\n                  Object.assign(values, association.scope);\n\n                  if (options.fields) {\n                    options.fields = options.fields.concat(Object.keys(association.scope));\n                  }\n                } // Create the related model instance\n\n\n                _context6.next = 7;\n                return association.target.create(values, options);\n\n              case 7:\n                newAssociatedObject = _context6.sent;\n                _context6.next = 10;\n                return sourceInstance[association.accessors.add](newAssociatedObject, _.omit(options, ['fields']));\n\n              case 10:\n                return _context6.abrupt(\"return\", newAssociatedObject);\n\n              case 11:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function create(_x14, _x15, _x16) {\n        return _create.apply(this, arguments);\n      }\n\n      return create;\n    }()\n  }, {\n    key: \"verifyAssociationAlias\",\n    value: function verifyAssociationAlias(alias) {\n      if (typeof alias === 'string') {\n        return this.as === alias;\n      }\n\n      if (alias && alias.plural) {\n        return this.as === alias.plural;\n      }\n\n      return !this.isAliased;\n    }\n  }]);\n\n  return BelongsToMany;\n}(Association);\n\nmodule.exports = BelongsToMany;\nmodule.exports.BelongsToMany = BelongsToMany;\nmodule.exports.default = BelongsToMany;","map":null,"metadata":{},"sourceType":"script"}