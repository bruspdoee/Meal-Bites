{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _get = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar Utils = require('../../utils');\n\nvar Transaction = require('../../transaction');\n\nvar _ = require('lodash');\n\nvar MySqlQueryGenerator = require('../mysql/query-generator');\n\nvar AbstractQueryGenerator = require('../abstract/query-generator');\n\nvar SQLiteQueryGenerator = /*#__PURE__*/function (_MySqlQueryGenerator) {\n  _inherits(SQLiteQueryGenerator, _MySqlQueryGenerator);\n\n  function SQLiteQueryGenerator() {\n    _classCallCheck(this, SQLiteQueryGenerator);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(SQLiteQueryGenerator).apply(this, arguments));\n  }\n\n  _createClass(SQLiteQueryGenerator, [{\n    key: \"createSchema\",\n    value: function createSchema() {\n      return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n    }\n  }, {\n    key: \"showSchemasQuery\",\n    value: function showSchemasQuery() {\n      return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n    }\n  }, {\n    key: \"versionQuery\",\n    value: function versionQuery() {\n      return 'SELECT sqlite_version() as `version`';\n    }\n  }, {\n    key: \"createTableQuery\",\n    value: function createTableQuery(tableName, attributes, options) {\n      var _this = this;\n\n      options = options || {};\n      var primaryKeys = [];\n      var needsMultiplePrimaryKeys = _.values(attributes).filter(function (definition) {\n        return definition.includes('PRIMARY KEY');\n      }).length > 1;\n      var attrArray = [];\n\n      for (var attr in attributes) {\n        if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n          var dataType = attributes[attr];\n          var containsAutoIncrement = dataType.includes('AUTOINCREMENT');\n          var dataTypeString = dataType;\n\n          if (dataType.includes('PRIMARY KEY')) {\n            if (dataType.includes('INT')) {\n              // Only INTEGER is allowed for primary key, see https://github.com/sequelize/sequelize/issues/969 (no lenght, unsigned etc)\n              dataTypeString = containsAutoIncrement ? 'INTEGER PRIMARY KEY AUTOINCREMENT' : 'INTEGER PRIMARY KEY';\n\n              if (dataType.includes(' REFERENCES')) {\n                dataTypeString += dataType.substr(dataType.indexOf(' REFERENCES'));\n              }\n            }\n\n            if (needsMultiplePrimaryKeys) {\n              primaryKeys.push(attr);\n\n              if (dataType.includes('NOT NULL')) {\n                dataTypeString = dataType.replace(' PRIMARY KEY', '');\n              } else {\n                dataTypeString = dataType.replace('PRIMARY KEY', 'NOT NULL');\n              }\n            }\n          }\n\n          attrArray.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(dataTypeString));\n        }\n      }\n\n      var table = this.quoteTable(tableName);\n      var attrStr = attrArray.join(', ');\n      var pkString = primaryKeys.map(function (pk) {\n        return _this.quoteIdentifier(pk);\n      }).join(', ');\n\n      if (options.uniqueKeys) {\n        _.each(options.uniqueKeys, function (columns) {\n          if (columns.customIndex) {\n            attrStr += \", UNIQUE (\".concat(columns.fields.map(function (field) {\n              return _this.quoteIdentifier(field);\n            }).join(', '), \")\");\n          }\n        });\n      }\n\n      if (pkString.length > 0) {\n        attrStr += \", PRIMARY KEY (\".concat(pkString, \")\");\n      }\n\n      var sql = \"CREATE TABLE IF NOT EXISTS \".concat(table, \" (\").concat(attrStr, \");\");\n      return this.replaceBooleanDefaults(sql);\n    }\n  }, {\n    key: \"booleanValue\",\n    value: function booleanValue(value) {\n      return value ? 1 : 0;\n    }\n    /**\n     * Check whether the statmement is json function or simple path\n     *\n     * @param   {string}  stmt  The statement to validate\n     * @returns {boolean}       true if the given statement is json function\n     * @throws  {Error}         throw if the statement looks like json function but has invalid token\n     */\n\n  }, {\n    key: \"_checkValidJsonStatement\",\n    value: function _checkValidJsonStatement(stmt) {\n      if (typeof stmt !== 'string') {\n        return false;\n      } // https://sqlite.org/json1.html\n\n\n      var jsonFunctionRegex = /^\\s*(json(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n      var tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n      var currentIndex = 0;\n      var openingBrackets = 0;\n      var closingBrackets = 0;\n      var hasJsonFunction = false;\n      var hasInvalidToken = false;\n\n      while (currentIndex < stmt.length) {\n        var string = stmt.substr(currentIndex);\n        var functionMatches = jsonFunctionRegex.exec(string);\n\n        if (functionMatches) {\n          currentIndex += functionMatches[0].indexOf('(');\n          hasJsonFunction = true;\n          continue;\n        }\n\n        var tokenMatches = tokenCaptureRegex.exec(string);\n\n        if (tokenMatches) {\n          var capturedToken = tokenMatches[1];\n\n          if (capturedToken === '(') {\n            openingBrackets++;\n          } else if (capturedToken === ')') {\n            closingBrackets++;\n          } else if (capturedToken === ';') {\n            hasInvalidToken = true;\n            break;\n          }\n\n          currentIndex += tokenMatches[0].length;\n          continue;\n        }\n\n        break;\n      } // Check invalid json statement\n\n\n      hasInvalidToken |= openingBrackets !== closingBrackets;\n\n      if (hasJsonFunction && hasInvalidToken) {\n        throw new Error(\"Invalid json statement: \".concat(stmt));\n      } // return true if the statement has valid json function\n\n\n      return hasJsonFunction;\n    } //sqlite can't cast to datetime so we need to convert date values to their ISO strings\n\n  }, {\n    key: \"_toJSONValue\",\n    value: function _toJSONValue(value) {\n      if (value instanceof Date) {\n        return value.toISOString();\n      }\n\n      if (Array.isArray(value) && value[0] instanceof Date) {\n        return value.map(function (val) {\n          return val.toISOString();\n        });\n      }\n\n      return value;\n    }\n  }, {\n    key: \"handleSequelizeMethod\",\n    value: function handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n      if (smth instanceof Utils.Json) {\n        return _get(_getPrototypeOf(SQLiteQueryGenerator.prototype), \"handleSequelizeMethod\", this).call(this, smth, tableName, factory, options, prepend);\n      }\n\n      if (smth instanceof Utils.Cast) {\n        if (/timestamp/i.test(smth.type)) {\n          smth.type = 'datetime';\n        }\n      }\n\n      return AbstractQueryGenerator.prototype.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n    }\n  }, {\n    key: \"addColumnQuery\",\n    value: function addColumnQuery(table, key, dataType) {\n      var attributes = {};\n      attributes[key] = dataType;\n      var fields = this.attributesToSQL(attributes, {\n        context: 'addColumn'\n      });\n      var attribute = \"\".concat(this.quoteIdentifier(key), \" \").concat(fields[key]);\n      var sql = \"ALTER TABLE \".concat(this.quoteTable(table), \" ADD \").concat(attribute, \";\");\n      return this.replaceBooleanDefaults(sql);\n    }\n  }, {\n    key: \"showTablesQuery\",\n    value: function showTablesQuery() {\n      return 'SELECT name FROM `sqlite_master` WHERE type=\\'table\\' and name!=\\'sqlite_sequence\\';';\n    }\n  }, {\n    key: \"upsertQuery\",\n    value: function upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n      options.ignoreDuplicates = true;\n      var bind = [];\n      var bindParam = this.bindParam(bind);\n\n      var upsertOptions = _.defaults({\n        bindParam: bindParam\n      }, options);\n\n      var insert = this.insertQuery(tableName, insertValues, model.rawAttributes, upsertOptions);\n      var update = this.updateQuery(tableName, updateValues, where, upsertOptions, model.rawAttributes);\n      var query = \"\".concat(insert.query, \" \").concat(update.query);\n      return {\n        query: query,\n        bind: bind\n      };\n    }\n  }, {\n    key: \"updateQuery\",\n    value: function updateQuery(tableName, attrValueHash, where, options, attributes) {\n      options = options || {};\n\n      _.defaults(options, this.options);\n\n      attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n      var modelAttributeMap = {};\n      var values = [];\n      var bind = [];\n      var bindParam = options.bindParam || this.bindParam(bind);\n\n      if (attributes) {\n        _.each(attributes, function (attribute, key) {\n          modelAttributeMap[key] = attribute;\n\n          if (attribute.field) {\n            modelAttributeMap[attribute.field] = attribute;\n          }\n        });\n      }\n\n      for (var key in attrValueHash) {\n        var value = attrValueHash[key];\n\n        if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n          values.push(\"\".concat(this.quoteIdentifier(key), \"=\").concat(this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, {\n            context: 'UPDATE'\n          })));\n        } else {\n          values.push(\"\".concat(this.quoteIdentifier(key), \"=\").concat(this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, {\n            context: 'UPDATE'\n          }, bindParam)));\n        }\n      }\n\n      var query;\n\n      var whereOptions = _.defaults({\n        bindParam: bindParam\n      }, options);\n\n      if (options.limit) {\n        query = \"UPDATE \".concat(this.quoteTable(tableName), \" SET \").concat(values.join(','), \" WHERE rowid IN (SELECT rowid FROM \").concat(this.quoteTable(tableName), \" \").concat(this.whereQuery(where, whereOptions), \" LIMIT \").concat(this.escape(options.limit), \")\");\n      } else {\n        query = \"UPDATE \".concat(this.quoteTable(tableName), \" SET \").concat(values.join(','), \" \").concat(this.whereQuery(where, whereOptions));\n      }\n\n      return {\n        query: query,\n        bind: bind\n      };\n    }\n  }, {\n    key: \"truncateTableQuery\",\n    value: function truncateTableQuery(tableName) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return [\"DELETE FROM \".concat(this.quoteTable(tableName)), options.restartIdentity ? \"; DELETE FROM \".concat(this.quoteTable('sqlite_sequence'), \" WHERE \").concat(this.quoteIdentifier('name'), \" = \").concat(Utils.addTicks(Utils.removeTicks(this.quoteTable(tableName), '`'), \"'\"), \";\") : ''].join('');\n    }\n  }, {\n    key: \"deleteQuery\",\n    value: function deleteQuery(tableName, where) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var model = arguments.length > 3 ? arguments[3] : undefined;\n\n      _.defaults(options, this.options);\n\n      var whereClause = this.getWhereConditions(where, null, model, options);\n\n      if (whereClause) {\n        whereClause = \"WHERE \".concat(whereClause);\n      }\n\n      if (options.limit) {\n        whereClause = \"WHERE rowid IN (SELECT rowid FROM \".concat(this.quoteTable(tableName), \" \").concat(whereClause, \" LIMIT \").concat(this.escape(options.limit), \")\");\n      }\n\n      return \"DELETE FROM \".concat(this.quoteTable(tableName), \" \").concat(whereClause);\n    }\n  }, {\n    key: \"attributesToSQL\",\n    value: function attributesToSQL(attributes) {\n      var result = {};\n\n      for (var name in attributes) {\n        var dataType = attributes[name];\n        var fieldName = dataType.field || name;\n\n        if (_.isObject(dataType)) {\n          var sql = dataType.type.toString();\n\n          if (Object.prototype.hasOwnProperty.call(dataType, 'allowNull') && !dataType.allowNull) {\n            sql += ' NOT NULL';\n          }\n\n          if (Utils.defaultValueSchemable(dataType.defaultValue)) {\n            // TODO thoroughly check that DataTypes.NOW will properly\n            // get populated on all databases as DEFAULT value\n            // i.e. mysql requires: DEFAULT CURRENT_TIMESTAMP\n            sql += \" DEFAULT \".concat(this.escape(dataType.defaultValue, dataType));\n          }\n\n          if (dataType.unique === true) {\n            sql += ' UNIQUE';\n          }\n\n          if (dataType.primaryKey) {\n            sql += ' PRIMARY KEY';\n\n            if (dataType.autoIncrement) {\n              sql += ' AUTOINCREMENT';\n            }\n          }\n\n          if (dataType.references) {\n            var referencesTable = this.quoteTable(dataType.references.model);\n            var referencesKey = void 0;\n\n            if (dataType.references.key) {\n              referencesKey = this.quoteIdentifier(dataType.references.key);\n            } else {\n              referencesKey = this.quoteIdentifier('id');\n            }\n\n            sql += \" REFERENCES \".concat(referencesTable, \" (\").concat(referencesKey, \")\");\n\n            if (dataType.onDelete) {\n              sql += \" ON DELETE \".concat(dataType.onDelete.toUpperCase());\n            }\n\n            if (dataType.onUpdate) {\n              sql += \" ON UPDATE \".concat(dataType.onUpdate.toUpperCase());\n            }\n          }\n\n          result[fieldName] = sql;\n        } else {\n          result[fieldName] = dataType;\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"showIndexesQuery\",\n    value: function showIndexesQuery(tableName) {\n      return \"PRAGMA INDEX_LIST(\".concat(this.quoteTable(tableName), \")\");\n    }\n  }, {\n    key: \"showConstraintsQuery\",\n    value: function showConstraintsQuery(tableName, constraintName) {\n      var sql = \"SELECT sql FROM sqlite_master WHERE tbl_name='\".concat(tableName, \"'\");\n\n      if (constraintName) {\n        sql += \" AND sql LIKE '%\".concat(constraintName, \"%'\");\n      }\n\n      return \"\".concat(sql, \";\");\n    }\n  }, {\n    key: \"removeIndexQuery\",\n    value: function removeIndexQuery(tableName, indexNameOrAttributes) {\n      var indexName = indexNameOrAttributes;\n\n      if (typeof indexName !== 'string') {\n        indexName = Utils.underscore(\"\".concat(tableName, \"_\").concat(indexNameOrAttributes.join('_')));\n      }\n\n      return \"DROP INDEX IF EXISTS \".concat(this.quoteIdentifier(indexName));\n    }\n  }, {\n    key: \"describeTableQuery\",\n    value: function describeTableQuery(tableName, schema, schemaDelimiter) {\n      var table = {\n        _schema: schema,\n        _schemaDelimiter: schemaDelimiter,\n        tableName: tableName\n      };\n      return \"PRAGMA TABLE_INFO(\".concat(this.quoteTable(this.addSchema(table)), \");\");\n    }\n  }, {\n    key: \"describeCreateTableQuery\",\n    value: function describeCreateTableQuery(tableName) {\n      return \"SELECT sql FROM sqlite_master WHERE tbl_name='\".concat(tableName, \"';\");\n    }\n  }, {\n    key: \"removeColumnQuery\",\n    value: function removeColumnQuery(tableName, attributes) {\n      var _this2 = this;\n\n      attributes = this.attributesToSQL(attributes);\n      var backupTableName;\n\n      if (typeof tableName === 'object') {\n        backupTableName = {\n          tableName: \"\".concat(tableName.tableName, \"_backup\"),\n          schema: tableName.schema\n        };\n      } else {\n        backupTableName = \"\".concat(tableName, \"_backup\");\n      }\n\n      var quotedTableName = this.quoteTable(tableName);\n      var quotedBackupTableName = this.quoteTable(backupTableName);\n      var attributeNames = Object.keys(attributes).map(function (attr) {\n        return _this2.quoteIdentifier(attr);\n      }).join(', '); // Temporary table cannot work for foreign keys.\n\n      return \"\".concat(this.createTableQuery(backupTableName, attributes), \"INSERT INTO \").concat(quotedBackupTableName, \" SELECT \").concat(attributeNames, \" FROM \").concat(quotedTableName, \";\") + \"DROP TABLE \".concat(quotedTableName, \";\").concat(this.createTableQuery(tableName, attributes), \"INSERT INTO \").concat(quotedTableName, \" SELECT \").concat(attributeNames, \" FROM \").concat(quotedBackupTableName, \";\") + \"DROP TABLE \".concat(quotedBackupTableName, \";\");\n    }\n  }, {\n    key: \"_alterConstraintQuery\",\n    value: function _alterConstraintQuery(tableName, attributes, createTableSql) {\n      var _this3 = this;\n\n      var backupTableName;\n      attributes = this.attributesToSQL(attributes);\n\n      if (typeof tableName === 'object') {\n        backupTableName = {\n          tableName: \"\".concat(tableName.tableName, \"_backup\"),\n          schema: tableName.schema\n        };\n      } else {\n        backupTableName = \"\".concat(tableName, \"_backup\");\n      }\n\n      var quotedTableName = this.quoteTable(tableName);\n      var quotedBackupTableName = this.quoteTable(backupTableName);\n      var attributeNames = Object.keys(attributes).map(function (attr) {\n        return _this3.quoteIdentifier(attr);\n      }).join(', ');\n      return \"\".concat(createTableSql.replace(\"CREATE TABLE \".concat(quotedTableName), \"CREATE TABLE \".concat(quotedBackupTableName)).replace(\"CREATE TABLE \".concat(quotedTableName.replace(/`/g, '\"')), \"CREATE TABLE \".concat(quotedBackupTableName)), \"INSERT INTO \").concat(quotedBackupTableName, \" SELECT \").concat(attributeNames, \" FROM \").concat(quotedTableName, \";\") + \"DROP TABLE \".concat(quotedTableName, \";\") + \"ALTER TABLE \".concat(quotedBackupTableName, \" RENAME TO \").concat(quotedTableName, \";\");\n    }\n  }, {\n    key: \"renameColumnQuery\",\n    value: function renameColumnQuery(tableName, attrNameBefore, attrNameAfter, attributes) {\n      var _this4 = this;\n\n      var backupTableName;\n      attributes = this.attributesToSQL(attributes);\n\n      if (typeof tableName === 'object') {\n        backupTableName = {\n          tableName: \"\".concat(tableName.tableName, \"_backup\"),\n          schema: tableName.schema\n        };\n      } else {\n        backupTableName = \"\".concat(tableName, \"_backup\");\n      }\n\n      var quotedTableName = this.quoteTable(tableName);\n      var quotedBackupTableName = this.quoteTable(backupTableName);\n      var attributeNamesImport = Object.keys(attributes).map(function (attr) {\n        return attrNameAfter === attr ? \"\".concat(_this4.quoteIdentifier(attrNameBefore), \" AS \").concat(_this4.quoteIdentifier(attr)) : _this4.quoteIdentifier(attr);\n      }).join(', ');\n      var attributeNamesExport = Object.keys(attributes).map(function (attr) {\n        return _this4.quoteIdentifier(attr);\n      }).join(', '); // Temporary tables don't support foreign keys, so creating a temporary table will not allow foreign keys to be preserved\n\n      return \"\".concat(this.createTableQuery(backupTableName, attributes), \"INSERT INTO \").concat(quotedBackupTableName, \" SELECT \").concat(attributeNamesImport, \" FROM \").concat(quotedTableName, \";\") + \"DROP TABLE \".concat(quotedTableName, \";\").concat(this.createTableQuery(tableName, attributes), \"INSERT INTO \").concat(quotedTableName, \" SELECT \").concat(attributeNamesExport, \" FROM \").concat(quotedBackupTableName, \";\") + \"DROP TABLE \".concat(quotedBackupTableName, \";\");\n    }\n  }, {\n    key: \"startTransactionQuery\",\n    value: function startTransactionQuery(transaction) {\n      if (transaction.parent) {\n        return \"SAVEPOINT \".concat(this.quoteIdentifier(transaction.name), \";\");\n      }\n\n      return \"BEGIN \".concat(transaction.options.type, \" TRANSACTION;\");\n    }\n  }, {\n    key: \"setIsolationLevelQuery\",\n    value: function setIsolationLevelQuery(value) {\n      switch (value) {\n        case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n          return '-- SQLite is not able to choose the isolation level REPEATABLE READ.';\n\n        case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n          return 'PRAGMA read_uncommitted = ON;';\n\n        case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n          return 'PRAGMA read_uncommitted = OFF;';\n\n        case Transaction.ISOLATION_LEVELS.SERIALIZABLE:\n          return '-- SQLite\\'s default isolation level is SERIALIZABLE. Nothing to do.';\n\n        default:\n          throw new Error(\"Unknown isolation level: \".concat(value));\n      }\n    }\n  }, {\n    key: \"replaceBooleanDefaults\",\n    value: function replaceBooleanDefaults(sql) {\n      return sql.replace(/DEFAULT '?false'?/g, 'DEFAULT 0').replace(/DEFAULT '?true'?/g, 'DEFAULT 1');\n    }\n    /**\n     * Generates an SQL query that returns all foreign keys of a table.\n     *\n     * @param  {string} tableName  The name of the table.\n     * @returns {string}            The generated sql query.\n     * @private\n     */\n\n  }, {\n    key: \"getForeignKeysQuery\",\n    value: function getForeignKeysQuery(tableName) {\n      return \"PRAGMA foreign_key_list(\".concat(tableName, \")\");\n    }\n  }]);\n\n  return SQLiteQueryGenerator;\n}(MySqlQueryGenerator);\n\nmodule.exports = SQLiteQueryGenerator;","map":null,"metadata":{},"sourceType":"script"}