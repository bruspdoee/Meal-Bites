{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar Net = require('net');\n\nvar Tls = require('tls');\n\nvar Timers = require('timers');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar Readable = require('stream').Readable;\n\nvar Queue = require('denque');\n\nvar SqlString = require('sqlstring');\n\nvar LRU = require('lru-cache');\n\nvar PacketParser = require('./packet_parser.js');\n\nvar Packets = require('./packets/index.js');\n\nvar Commands = require('./commands/index.js');\n\nvar ConnectionConfig = require('./connection_config.js');\n\nvar CharsetToEncoding = require('./constants/charset_encodings.js');\n\nvar _connectionId = 0;\nvar convertNamedPlaceholders = null;\n\nvar Connection = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Connection, _EventEmitter);\n\n  function Connection(opts) {\n    var _this;\n\n    _classCallCheck(this, Connection);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Connection).call(this));\n    _this.config = opts.config; // TODO: fill defaults\n    // if no params, connect to /var/lib/mysql/mysql.sock ( /tmp/mysql.sock on OSX )\n    // if host is given, connect to host:3306\n    // TODO: use `/usr/local/mysql/bin/mysql_config --socket` output? as default socketPath\n    // if there is no host/port and no socketPath parameters?\n\n    if (!opts.config.stream) {\n      if (opts.config.socketPath) {\n        _this.stream = Net.connect(opts.config.socketPath);\n      } else {\n        _this.stream = Net.connect(opts.config.port, opts.config.host); // Enable keep-alive on the socket.  It's disabled by default, but the\n        // user can enable it and supply an initial delay.\n\n        _this.stream.setKeepAlive(true, _this.config.keepAliveInitialDelay);\n      } // if stream is a function, treat it as \"stream agent / factory\"\n\n    } else if (typeof opts.config.stream === 'function') {\n      _this.stream = opts.config.stream(opts);\n    } else {\n      _this.stream = opts.config.stream;\n    }\n\n    _this._internalId = _connectionId++;\n    _this._commands = new Queue();\n    _this._command = null;\n    _this._paused = false;\n    _this._paused_packets = new Queue();\n    _this._statements = new LRU({\n      max: _this.config.maxPreparedStatements,\n      dispose: function dispose(key, statement) {\n        statement.close();\n      }\n    });\n    _this.serverCapabilityFlags = 0;\n    _this.authorized = false;\n    _this.sequenceId = 0;\n    _this.compressedSequenceId = 0;\n    _this.threadId = null;\n    _this._handshakePacket = null;\n    _this._fatalError = null;\n    _this._protocolError = null;\n    _this._outOfOrderPackets = [];\n    _this.clientEncoding = CharsetToEncoding[_this.config.charsetNumber];\n\n    _this.stream.on('error', _this._handleNetworkError.bind(_assertThisInitialized(_assertThisInitialized(_this)))); // see https://gist.github.com/khoomeister/4985691#use-that-instead-of-bind\n\n\n    _this.packetParser = new PacketParser(function (p) {\n      _this.handlePacket(p);\n    });\n\n    _this.stream.on('data', function (data) {\n      if (_this.connectTimeout) {\n        Timers.clearTimeout(_this.connectTimeout);\n        _this.connectTimeout = null;\n      }\n\n      _this.packetParser.execute(data);\n    });\n\n    _this.stream.on('close', function () {\n      // we need to set this flag everywhere where we want connection to close\n      if (_this._closing) {\n        return;\n      }\n\n      if (!_this._protocolError) {\n        // no particular error message before disconnect\n        _this._protocolError = new Error('Connection lost: The server closed the connection.');\n        _this._protocolError.fatal = true;\n        _this._protocolError.code = 'PROTOCOL_CONNECTION_LOST';\n      }\n\n      _this._notifyError(_this._protocolError);\n    });\n\n    var handshakeCommand;\n\n    if (!_this.config.isServer) {\n      handshakeCommand = new Commands.ClientHandshake(_this.config.clientFlags);\n      handshakeCommand.on('end', function () {\n        // this happens when handshake finishes early and first packet is error\n        // and not server hello ( for example, 'Too many connactions' error)\n        if (!handshakeCommand.handshake) {\n          return;\n        }\n\n        _this._handshakePacket = handshakeCommand.handshake;\n        _this.threadId = handshakeCommand.handshake.connectionId;\n\n        _this.emit('connect', handshakeCommand.handshake);\n      });\n      handshakeCommand.on('error', function (err) {\n        _this._closing = true;\n\n        _this._notifyError(err);\n      });\n\n      _this.addCommand(handshakeCommand);\n    } // in case there was no initiall handshake but we need to read sting, assume it utf-8\n    // most common example: \"Too many connections\" error ( packet is sent immediately on connection attempt, we don't know server encoding yet)\n    // will be overwrittedn with actial encoding value as soon as server handshake packet is received\n\n\n    _this.serverEncoding = 'utf8';\n\n    if (_this.config.connectTimeout) {\n      var timeoutHandler = _this._handleTimeoutError.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n\n      _this.connectTimeout = Timers.setTimeout(timeoutHandler, _this.config.connectTimeout);\n    }\n\n    return _this;\n  }\n\n  _createClass(Connection, [{\n    key: \"promise\",\n    value: function promise(promiseImpl) {\n      var PromiseConnection = require('../promise').PromiseConnection;\n\n      return new PromiseConnection(this, promiseImpl);\n    }\n  }, {\n    key: \"_addCommandClosedState\",\n    value: function _addCommandClosedState(cmd) {\n      var err = new Error(\"Can't add new command when connection is in closed state\");\n      err.fatal = true;\n\n      if (cmd.onResult) {\n        cmd.onResult(err);\n      } else {\n        this.emit('error', err);\n      }\n    }\n  }, {\n    key: \"_handleFatalError\",\n    value: function _handleFatalError(err) {\n      var _this2 = this;\n\n      err.fatal = true; // stop receiving packets\n\n      this.stream.removeAllListeners('data');\n      this.addCommand = this._addCommandClosedState;\n\n      this.write = function () {\n        _this2.emit('error', new Error(\"Can't write in closed state\"));\n      };\n\n      this._notifyError(err);\n\n      this._fatalError = err;\n    }\n  }, {\n    key: \"_handleNetworkError\",\n    value: function _handleNetworkError(err) {\n      if (this.connectTimeout) {\n        Timers.clearTimeout(this.connectTimeout);\n        this.connectTimeout = null;\n      } // Do not throw an error when a connection ends with a RST,ACK packet\n\n\n      if (err.errno === 'ECONNRESET' && this._closing) {\n        return;\n      }\n\n      this._handleFatalError(err);\n    }\n  }, {\n    key: \"_handleTimeoutError\",\n    value: function _handleTimeoutError() {\n      if (this.connectTimeout) {\n        Timers.clearTimeout(this.connectTimeout);\n        this.connectTimeout = null;\n      }\n\n      this.stream.destroy && this.stream.destroy();\n      var err = new Error('connect ETIMEDOUT');\n      err.errorno = 'ETIMEDOUT';\n      err.code = 'ETIMEDOUT';\n      err.syscall = 'connect';\n\n      this._handleNetworkError(err);\n    } // notify all commands in the queue and bubble error as connection \"error\"\n    // called on stream error or unexpected termination\n\n  }, {\n    key: \"_notifyError\",\n    value: function _notifyError(err) {\n      // prevent from emitting 'PROTOCOL_CONNECTION_LOST' after EPIPE or ECONNRESET\n      if (this._fatalError) {\n        return;\n      }\n\n      var command; // if there is no active command, notify connection\n      // if there are commands and all of them have callbacks, pass error via callback\n\n      var bubbleErrorToConnection = !this._command;\n\n      if (this._command && this._command.onResult) {\n        this._command.onResult(err);\n\n        this._command = null; // connection handshake is special because we allow it to be implicit\n        // if error happened during handshake, but there are others commands in queue\n        // then bubble error to other commands and not to connection\n      } else if (!(this._command && this._command.constructor === Commands.ClientHandshake && this._commands.length > 0)) {\n        bubbleErrorToConnection = true;\n      }\n\n      while (command = this._commands.shift()) {\n        if (command.onResult) {\n          command.onResult(err);\n        } else {\n          bubbleErrorToConnection = true;\n        }\n      } // notify connection if some comands in the queue did not have callbacks\n      // or if this is pool connection ( so it can be removed from pool )\n\n\n      if (bubbleErrorToConnection || this._pool) {\n        this.emit('error', err);\n      }\n    }\n  }, {\n    key: \"write\",\n    value: function write(buffer) {\n      var _this3 = this;\n\n      this.stream.write(buffer, function (err) {\n        if (err) {\n          _this3._handleNetworkError(err);\n        }\n      });\n    } // http://dev.mysql.com/doc/internals/en/sequence-id.html\n    //\n    // The sequence-id is incremented with each packet and may wrap around.\n    // It starts at 0 and is reset to 0 when a new command\n    // begins in the Command Phase.\n    // http://dev.mysql.com/doc/internals/en/example-several-mysql-packets.html\n\n  }, {\n    key: \"_resetSequenceId\",\n    value: function _resetSequenceId() {\n      this.sequenceId = 0;\n      this.compressedSequenceId = 0;\n    }\n  }, {\n    key: \"_bumpCompressedSequenceId\",\n    value: function _bumpCompressedSequenceId(numPackets) {\n      this.compressedSequenceId += numPackets;\n      this.compressedSequenceId %= 256;\n    }\n  }, {\n    key: \"_bumpSequenceId\",\n    value: function _bumpSequenceId(numPackets) {\n      this.sequenceId += numPackets;\n      this.sequenceId %= 256;\n    }\n  }, {\n    key: \"writePacket\",\n    value: function writePacket(packet) {\n      var MAX_PACKET_LENGTH = 16777215;\n      var length = packet.length();\n      var chunk, offset, header;\n\n      if (length < MAX_PACKET_LENGTH) {\n        packet.writeHeader(this.sequenceId);\n\n        if (this.config.debug) {\n          // eslint-disable-next-line no-console\n          console.log(\"\".concat(this._internalId, \" \").concat(this.connectionId, \" <== \").concat(this._command._commandName, \"#\").concat(this._command.stateName(), \"(\").concat([this.sequenceId, packet._name, packet.length()].join(','), \")\")); // eslint-disable-next-line no-console\n\n          console.log(\"\".concat(this._internalId, \" \").concat(this.connectionId, \" <== \").concat(packet.buffer.toString('hex')));\n        }\n\n        this._bumpSequenceId(1);\n\n        this.write(packet.buffer);\n      } else {\n        if (this.config.debug) {\n          // eslint-disable-next-line no-console\n          console.log(\"\".concat(this._internalId, \" \").concat(this.connectionId, \" <== Writing large packet, raw content not written:\")); // eslint-disable-next-line no-console\n\n          console.log(\"\".concat(this._internalId, \" \").concat(this.connectionId, \" <== \").concat(this._command._commandName, \"#\").concat(this._command.stateName(), \"(\").concat([this.sequenceId, packet._name, packet.length()].join(','), \")\"));\n        }\n\n        for (offset = 4; offset < 4 + length; offset += MAX_PACKET_LENGTH) {\n          chunk = packet.buffer.slice(offset, offset + MAX_PACKET_LENGTH);\n\n          if (chunk.length === MAX_PACKET_LENGTH) {\n            header = Buffer.from([0xff, 0xff, 0xff, this.sequenceId]);\n          } else {\n            header = Buffer.from([chunk.length & 0xff, chunk.length >> 8 & 0xff, chunk.length >> 16 & 0xff, this.sequenceId]);\n          }\n\n          this._bumpSequenceId(1);\n\n          this.write(header);\n          this.write(chunk);\n        }\n      }\n    } // 0.11+ environment\n\n  }, {\n    key: \"startTLS\",\n    value: function startTLS(onSecure) {\n      var _this4 = this;\n\n      if (this.config.debug) {\n        // eslint-disable-next-line no-console\n        console.log('Upgrading connection to TLS');\n      }\n\n      var secureContext = Tls.createSecureContext({\n        ca: this.config.ssl.ca,\n        cert: this.config.ssl.cert,\n        ciphers: this.config.ssl.ciphers,\n        key: this.config.ssl.key,\n        passphrase: this.config.ssl.passphrase,\n        minVersion: this.config.ssl.minVersion\n      });\n      var rejectUnauthorized = this.config.ssl.rejectUnauthorized;\n      var secureEstablished = false;\n      var secureSocket = new Tls.TLSSocket(this.stream, {\n        rejectUnauthorized: rejectUnauthorized,\n        requestCert: true,\n        secureContext: secureContext,\n        isServer: false\n      }); // error handler for secure socket\n\n      secureSocket.on('_tlsError', function (err) {\n        if (secureEstablished) {\n          _this4._handleNetworkError(err);\n        } else {\n          onSecure(err);\n        }\n      });\n      secureSocket.on('secure', function () {\n        secureEstablished = true;\n        onSecure(rejectUnauthorized ? secureSocket.ssl.verifyError() : null);\n      });\n      secureSocket.on('data', function (data) {\n        _this4.packetParser.execute(data);\n      });\n\n      this.write = function (buffer) {\n        secureSocket.write(buffer);\n      }; // start TLS communications\n\n\n      secureSocket._start();\n    }\n  }, {\n    key: \"pipe\",\n    value: function pipe() {\n      var _this5 = this;\n\n      if (this.stream instanceof Net.Stream) {\n        this.stream.ondata = function (data, start, end) {\n          _this5.packetParser.execute(data, start, end);\n        };\n      } else {\n        this.stream.on('data', function (data) {\n          _this5.packetParser.execute(data.parent, data.offset, data.offset + data.length);\n        });\n      }\n    }\n  }, {\n    key: \"protocolError\",\n    value: function protocolError(message, code) {\n      var err = new Error(message);\n      err.fatal = true;\n      err.code = code || 'PROTOCOL_ERROR';\n      this.emit('error', err);\n    }\n  }, {\n    key: \"handlePacket\",\n    value: function handlePacket(packet) {\n      if (this._paused) {\n        this._paused_packets.push(packet);\n\n        return;\n      }\n\n      if (packet) {\n        if (this.sequenceId !== packet.sequenceId) {\n          var err = new Error(\"Warning: got packets out of order. Expected \".concat(this.sequenceId, \" but received \").concat(packet.sequenceId));\n          err.expected = this.sequenceId;\n          err.received = packet.sequenceId;\n          this.emit('warn', err); // REVIEW\n          // eslint-disable-next-line no-console\n\n          console.error(err.message);\n        }\n\n        this._bumpSequenceId(packet.numPackets);\n      }\n\n      if (this.config.debug) {\n        if (packet) {\n          // eslint-disable-next-line no-console\n          console.log(\" raw: \".concat(packet.buffer.slice(packet.offset, packet.offset + packet.length()).toString('hex'))); // eslint-disable-next-line no-console\n\n          console.trace();\n          var commandName = this._command ? this._command._commandName : '(no command)';\n          var stateName = this._command ? this._command.stateName() : '(no command)'; // eslint-disable-next-line no-console\n\n          console.log(\"\".concat(this._internalId, \" \").concat(this.connectionId, \" ==> \").concat(commandName, \"#\").concat(stateName, \"(\").concat([packet.sequenceId, packet.type(), packet.length()].join(','), \")\"));\n        }\n      }\n\n      if (!this._command) {\n        this.protocolError('Unexpected packet while no commands in the queue', 'PROTOCOL_UNEXPECTED_PACKET');\n        this.close();\n        return;\n      }\n\n      var done = this._command.execute(packet, this);\n\n      if (done) {\n        this._command = this._commands.shift();\n\n        if (this._command) {\n          this.sequenceId = 0;\n          this.compressedSequenceId = 0;\n          this.handlePacket();\n        }\n      }\n    }\n  }, {\n    key: \"addCommand\",\n    value: function addCommand(cmd) {\n      // this.compressedSequenceId = 0;\n      // this.sequenceId = 0;\n      if (this.config.debug) {\n        var commandName = cmd.constructor.name; // eslint-disable-next-line no-console\n\n        console.log(\"Add command: \".concat(commandName));\n        cmd._commandName = commandName;\n      }\n\n      if (!this._command) {\n        this._command = cmd;\n        this.handlePacket();\n      } else {\n        this._commands.push(cmd);\n      }\n\n      return cmd;\n    }\n  }, {\n    key: \"format\",\n    value: function format(sql, values) {\n      if (typeof this.config.queryFormat === 'function') {\n        return this.config.queryFormat.call(this, sql, values, this.config.timezone);\n      }\n\n      var opts = {\n        sql: sql,\n        values: values\n      };\n\n      this._resolveNamedPlaceholders(opts);\n\n      return SqlString.format(opts.sql, opts.values, this.config.stringifyObjects, this.config.timezone);\n    }\n  }, {\n    key: \"escape\",\n    value: function escape(value) {\n      return SqlString.escape(value, false, this.config.timezone);\n    }\n  }, {\n    key: \"escapeId\",\n    value: function escapeId(value) {\n      return SqlString.escapeId(value, false);\n    }\n  }, {\n    key: \"raw\",\n    value: function raw(sql) {\n      return SqlString.raw(sql);\n    }\n  }, {\n    key: \"_resolveNamedPlaceholders\",\n    value: function _resolveNamedPlaceholders(options) {\n      var unnamed;\n\n      if (this.config.namedPlaceholders || options.namedPlaceholders) {\n        if (convertNamedPlaceholders === null) {\n          convertNamedPlaceholders = require('named-placeholders')();\n        }\n\n        unnamed = convertNamedPlaceholders(options.sql, options.values);\n        options.sql = unnamed[0];\n        options.values = unnamed[1];\n      }\n    }\n  }, {\n    key: \"query\",\n    value: function query(sql, values, cb) {\n      var cmdQuery;\n\n      if (sql.constructor === Commands.Query) {\n        cmdQuery = sql;\n      } else {\n        cmdQuery = Connection.createQuery(sql, values, cb, this.config);\n      }\n\n      this._resolveNamedPlaceholders(cmdQuery);\n\n      var rawSql = this.format(cmdQuery.sql, cmdQuery.values || []);\n      cmdQuery.sql = rawSql;\n      return this.addCommand(cmdQuery);\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this._paused = true;\n      this.stream.pause();\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      var packet;\n      this._paused = false;\n\n      while (packet = this._paused_packets.shift()) {\n        this.handlePacket(packet); // don't resume if packet hander paused connection\n\n        if (this._paused) {\n          return;\n        }\n      }\n\n      this.stream.resume();\n    } // TODO: named placeholders support\n\n  }, {\n    key: \"prepare\",\n    value: function prepare(options, cb) {\n      if (typeof options === 'string') {\n        options = {\n          sql: options\n        };\n      }\n\n      return this.addCommand(new Commands.Prepare(options, cb));\n    }\n  }, {\n    key: \"unprepare\",\n    value: function unprepare(sql) {\n      var options = {};\n\n      if (typeof sql === 'object') {\n        options = sql;\n      } else {\n        options.sql = sql;\n      }\n\n      var key = Connection.statementKey(options);\n\n      var stmt = this._statements.get(key);\n\n      if (stmt) {\n        this._statements.del(key);\n\n        stmt.close();\n      }\n\n      return stmt;\n    }\n  }, {\n    key: \"execute\",\n    value: function execute(sql, values, cb) {\n      var options = {};\n\n      if (typeof sql === 'object') {\n        // execute(options, cb)\n        options = sql;\n\n        if (typeof values === 'function') {\n          cb = values;\n        } else {\n          options.values = options.values || values;\n        }\n      } else if (typeof values === 'function') {\n        // execute(sql, cb)\n        cb = values;\n        options.sql = sql;\n        options.values = undefined;\n      } else {\n        // execute(sql, values, cb)\n        options.sql = sql;\n        options.values = values;\n      }\n\n      this._resolveNamedPlaceholders(options); // check for values containing undefined\n\n\n      if (options.values) {\n        //If namedPlaceholder is not enabled and object is passed as bind parameters\n        if (!Array.isArray(options.values)) {\n          throw new TypeError('Bind parameters must be array if namedPlaceholders parameter is not enabled');\n        }\n\n        options.values.forEach(function (val) {\n          //If namedPlaceholder is not enabled and object is passed as bind parameters\n          if (!Array.isArray(options.values)) {\n            throw new TypeError('Bind parameters must be array if namedPlaceholders parameter is not enabled');\n          }\n\n          if (val === undefined) {\n            throw new TypeError('Bind parameters must not contain undefined. To pass SQL NULL specify JS null');\n          }\n\n          if (typeof val === 'function') {\n            throw new TypeError('Bind parameters must not contain function(s). To pass the body of a function as a string call .toString() first');\n          }\n        });\n      }\n\n      var executeCommand = new Commands.Execute(options, cb);\n      var prepareCommand = new Commands.Prepare(options, function (err, stmt) {\n        if (err) {\n          // skip execute command if prepare failed, we have main\n          // combined callback here\n          executeCommand.start = function () {\n            return null;\n          };\n\n          if (cb) {\n            cb(err);\n          } else {\n            executeCommand.emit('error', err);\n          }\n\n          executeCommand.emit('end');\n          return;\n        }\n\n        executeCommand.statement = stmt;\n      });\n      this.addCommand(prepareCommand);\n      this.addCommand(executeCommand);\n      return executeCommand;\n    }\n  }, {\n    key: \"changeUser\",\n    value: function changeUser(options, callback) {\n      if (!callback && typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      var charsetNumber = options.charset ? ConnectionConfig.getCharsetNumber(options.charset) : this.config.charsetNumber;\n      return this.addCommand(new Commands.ChangeUser({\n        user: options.user || this.config.user,\n        password: options.password || this.config.password,\n        passwordSha1: options.passwordSha1 || this.config.passwordSha1,\n        database: options.database || this.config.database,\n        timeout: options.timeout,\n        charsetNumber: charsetNumber,\n        currentConfig: this.config\n      }, function (err) {\n        if (err) {\n          err.fatal = true;\n        }\n\n        if (callback) {\n          callback(err);\n        }\n      }));\n    } // transaction helpers\n\n  }, {\n    key: \"beginTransaction\",\n    value: function beginTransaction(cb) {\n      return this.query('START TRANSACTION', cb);\n    }\n  }, {\n    key: \"commit\",\n    value: function commit(cb) {\n      return this.query('COMMIT', cb);\n    }\n  }, {\n    key: \"rollback\",\n    value: function rollback(cb) {\n      return this.query('ROLLBACK', cb);\n    }\n  }, {\n    key: \"ping\",\n    value: function ping(cb) {\n      return this.addCommand(new Commands.Ping(cb));\n    }\n  }, {\n    key: \"_registerSlave\",\n    value: function _registerSlave(opts, cb) {\n      return this.addCommand(new Commands.RegisterSlave(opts, cb));\n    }\n  }, {\n    key: \"_binlogDump\",\n    value: function _binlogDump(opts, cb) {\n      return this.addCommand(new Commands.BinlogDump(opts, cb));\n    } // currently just alias to close\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.close();\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this.connectTimeout) {\n        Timers.clearTimeout(this.connectTimeout);\n        this.connectTimeout = null;\n      }\n\n      this._closing = true;\n      this.stream.end();\n      this.addCommand = this._addCommandClosedState;\n    }\n  }, {\n    key: \"createBinlogStream\",\n    value: function createBinlogStream(opts) {\n      var _this6 = this;\n\n      // TODO: create proper stream class\n      // TODO: use through2\n      var test = 1;\n      var stream = new Readable({\n        objectMode: true\n      });\n\n      stream._read = function () {\n        return {\n          data: test++\n        };\n      };\n\n      this._registerSlave(opts, function () {\n        var dumpCmd = _this6._binlogDump(opts);\n\n        dumpCmd.on('event', function (ev) {\n          stream.push(ev);\n        });\n        dumpCmd.on('eof', function () {\n          stream.push(null); // if non-blocking, then close stream to prevent errors\n\n          if (opts.flags && opts.flags & 0x01) {\n            _this6.close();\n          }\n        }); // TODO: pipe errors as well\n      });\n\n      return stream;\n    }\n  }, {\n    key: \"connect\",\n    value: function connect(cb) {\n      if (!cb) {\n        return;\n      }\n\n      var connectCalled = 0;\n\n      function callbackOnce(isErrorHandler) {\n        return function (param) {\n          if (!connectCalled) {\n            if (isErrorHandler) {\n              cb(param);\n            } else {\n              cb(null, param);\n            }\n          }\n\n          connectCalled = 1;\n        };\n      }\n\n      this.once('error', callbackOnce(true));\n      this.once('connect', callbackOnce(false));\n    } // ===================================\n    // outgoing server connection methods\n    // ===================================\n\n  }, {\n    key: \"writeColumns\",\n    value: function writeColumns(columns) {\n      var _this7 = this;\n\n      this.writePacket(Packets.ResultSetHeader.toPacket(columns.length));\n      columns.forEach(function (column) {\n        _this7.writePacket(Packets.ColumnDefinition.toPacket(column, _this7.serverConfig.encoding));\n      });\n      this.writeEof();\n    } // row is array of columns, not hash\n\n  }, {\n    key: \"writeTextRow\",\n    value: function writeTextRow(column) {\n      this.writePacket(Packets.TextRow.toPacket(column, this.serverConfig.encoding));\n    }\n  }, {\n    key: \"writeTextResult\",\n    value: function writeTextResult(rows, columns) {\n      var _this8 = this;\n\n      this.writeColumns(columns);\n      rows.forEach(function (row) {\n        var arrayRow = new Array(columns.length);\n        columns.forEach(function (column) {\n          arrayRow.push(row[column.name]);\n        });\n\n        _this8.writeTextRow(arrayRow);\n      });\n      this.writeEof();\n    }\n  }, {\n    key: \"writeEof\",\n    value: function writeEof(warnings, statusFlags) {\n      this.writePacket(Packets.EOF.toPacket(warnings, statusFlags));\n    }\n  }, {\n    key: \"writeOk\",\n    value: function writeOk(args) {\n      if (!args) {\n        args = {\n          affectedRows: 0\n        };\n      }\n\n      this.writePacket(Packets.OK.toPacket(args, this.serverConfig.encoding));\n    }\n  }, {\n    key: \"writeError\",\n    value: function writeError(args) {\n      // if we want to send error before initial hello was sent, use default encoding\n      var encoding = this.serverConfig ? this.serverConfig.encoding : 'cesu8';\n      this.writePacket(Packets.Error.toPacket(args, encoding));\n    }\n  }, {\n    key: \"serverHandshake\",\n    value: function serverHandshake(args) {\n      this.serverConfig = args;\n      this.serverConfig.encoding = CharsetToEncoding[this.serverConfig.characterSet];\n      return this.addCommand(new Commands.ServerHandshake(args));\n    } // ===============================================================\n\n  }, {\n    key: \"end\",\n    value: function end(callback) {\n      var _this9 = this;\n\n      if (this.config.isServer) {\n        this._closing = true;\n\n        var _quitCmd = new EventEmitter();\n\n        setImmediate(function () {\n          _this9.stream.end();\n\n          _quitCmd.emit('end');\n        });\n        return _quitCmd;\n      } // trigger error if more commands enqueued after end command\n\n\n      var quitCmd = this.addCommand(new Commands.Quit(callback));\n      this.addCommand = this._addCommandClosedState;\n      return quitCmd;\n    }\n  }], [{\n    key: \"createQuery\",\n    value: function createQuery(sql, values, cb, config) {\n      var options = {\n        rowsAsArray: config.rowsAsArray\n      };\n\n      if (typeof sql === 'object') {\n        // query(options, cb)\n        options = sql;\n\n        if (typeof values === 'function') {\n          cb = values;\n        } else if (values !== undefined) {\n          options.values = values;\n        }\n      } else if (typeof values === 'function') {\n        // query(sql, cb)\n        cb = values;\n        options.sql = sql;\n        options.values = undefined;\n      } else {\n        // query(sql, values, cb)\n        options.sql = sql;\n        options.values = values;\n      }\n\n      return new Commands.Query(options, cb);\n    }\n  }, {\n    key: \"statementKey\",\n    value: function statementKey(options) {\n      return \"\".concat(typeof options.nestTables, \"/\").concat(options.nestTables, \"/\").concat(options.rowsAsArray).concat(options.sql);\n    }\n  }]);\n\n  return Connection;\n}(EventEmitter);\n\nif (Tls.TLSSocket) {// not supported\n} else {\n  Connection.prototype.startTLS = function _startTLS(onSecure) {\n    var _this10 = this;\n\n    if (this.config.debug) {\n      // eslint-disable-next-line no-console\n      console.log('Upgrading connection to TLS');\n    }\n\n    var crypto = require('crypto');\n\n    var config = this.config;\n    var stream = this.stream;\n    var rejectUnauthorized = this.config.ssl.rejectUnauthorized;\n    var credentials = crypto.createCredentials({\n      key: config.ssl.key,\n      cert: config.ssl.cert,\n      passphrase: config.ssl.passphrase,\n      ca: config.ssl.ca,\n      ciphers: config.ssl.ciphers\n    });\n    var securePair = Tls.createSecurePair(credentials, false, true, rejectUnauthorized);\n\n    if (stream.ondata) {\n      stream.ondata = null;\n    }\n\n    stream.removeAllListeners('data');\n    stream.pipe(securePair.encrypted);\n    securePair.encrypted.pipe(stream);\n    securePair.cleartext.on('data', function (data) {\n      _this10.packetParser.execute(data);\n    });\n\n    this.write = function (buffer) {\n      securePair.cleartext.write(buffer);\n    };\n\n    securePair.on('secure', function () {\n      onSecure(rejectUnauthorized ? securePair.ssl.verifyError() : null);\n    });\n  };\n}\n\nmodule.exports = Connection;","map":null,"metadata":{},"sourceType":"script"}