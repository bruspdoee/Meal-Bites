{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Deferred = require(\"./Deferred\");\n/**\n * Generate an Object pool with a specified `factory`.\n *\n * @class\n * @param {Object} factory\n *   Factory to be used for generating and destroying the items.\n * @param {String} [factory.name]\n *   Name of the factory. Serves only logging purposes.\n * @param {Function} factory.create\n *   Should create the item to be acquired,\n *   and call it's first callback argument with the generated item as it's argument.\n * @param {Function} factory.destroy\n *   Should gently close any resources that the item is using.\n *   Called before the items is destroyed.\n * @param {Function} factory.validate\n *   Should return true if connection is still valid and false\n *   If it should be removed from pool. Called before item is\n *   acquired from pool.\n * @param {Number} factory.max\n *   Maximum number of items that can exist at the same time.\n *   Any further acquire requests will be pushed to the waiting list.\n * @param {Number} factory.min\n *   Minimum number of items in pool (including in-use).\n *   When the pool is created, or a resource destroyed, this minimum will\n *   be checked. If the pool resource count is below the minimum, a new\n *   resource will be created and added to the pool.\n * @param {Number} [factory.idleTimeoutMillis=30000]\n *   Delay in milliseconds after which available resources in the pool will be destroyed.\n *   This does not affects pending acquire requests.\n * @param {Number} [factory.acquireTimeoutMillis=30000]\n *   Delay in milliseconds after which pending acquire request in the pool will be rejected.\n *   Pending acquires are acquire calls which are yet to receive an response from factory.create\n * @param {Number} [factory.reapIntervalMillis=1000]\n *   Clean up is scheduled in every `factory.reapIntervalMillis` milliseconds.\n * @param {Boolean|Function} [factory.log=false]\n *   Whether the pool should log activity. If function is specified,\n *   that will be used instead. The function expects the arguments msg, loglevel\n */\n\n\nvar Pool = /*#__PURE__*/function () {\n  function Pool(factory) {\n    _classCallCheck(this, Pool);\n\n    if (!factory.create) {\n      throw new Error(\"create function is required\");\n    }\n\n    if (!factory.destroy) {\n      throw new Error(\"destroy function is required\");\n    }\n\n    if (!factory.validate) {\n      throw new Error(\"validate function is required\");\n    }\n\n    if (typeof factory.min !== \"number\" || factory.min < 0 || factory.min !== Math.round(factory.min)) {\n      throw new Error(\"min must be an integer >= 0\");\n    }\n\n    if (typeof factory.max !== \"number\" || factory.max <= 0 || factory.max !== Math.round(factory.max)) {\n      throw new Error(\"max must be an integer > 0\");\n    }\n\n    if (factory.min > factory.max) {\n      throw new Error(\"max is smaller than min\");\n    } // defaults\n\n\n    factory.idleTimeoutMillis = factory.idleTimeoutMillis || 30000;\n    factory.acquireTimeoutMillis = factory.acquireTimeoutMillis || 30000;\n    factory.reapInterval = factory.reapIntervalMillis || 1000;\n    factory.max = parseInt(factory.max, 10);\n    factory.min = parseInt(factory.min, 10);\n    factory.log = factory.log || false;\n    this._factory = factory;\n    this._count = 0;\n    this._draining = false; // queues\n\n    this._pendingAcquires = [];\n    this._inUseObjects = [];\n    this._availableObjects = []; // timing controls\n\n    this._removeIdleTimer = null;\n    this._removeIdleScheduled = false;\n  }\n\n  _createClass(Pool, [{\n    key: \"_log\",\n\n    /**\n     * logs to console or user defined log function\n     * @private\n     * @param {string} message\n     * @param {string} level\n     */\n    value: function _log(message, level) {\n      if (typeof this._factory.log === \"function\") {\n        this._factory.log(message, level);\n      } else if (this._factory.log) {\n        console.log(\"\".concat(level.toUpperCase(), \" pool \").concat(this.name, \" - \").concat(message));\n      }\n    }\n    /**\n     * Checks and removes the available (idle) clients that have timed out.\n     * @private\n     */\n\n  }, {\n    key: \"_removeIdle\",\n    value: function _removeIdle() {\n      var toRemove = [];\n      var now = Date.now();\n      var i;\n      var available = this._availableObjects.length;\n      var maxRemovable = this._count - this._factory.min;\n      var timeout;\n      this._removeIdleScheduled = false; // Go through the available (idle) items,\n      // check if they have timed out\n\n      for (i = 0; i < available && maxRemovable > toRemove.length; i++) {\n        timeout = this._availableObjects[i].timeout;\n\n        if (now >= timeout) {\n          // Client timed out, so destroy it.\n          this._log(\"removeIdle() destroying obj - now:\" + now + \" timeout:\" + timeout, \"verbose\");\n\n          toRemove.push(this._availableObjects[i].resource);\n        }\n      }\n\n      toRemove.forEach(this.destroy, this); // NOTE: we are re-calculating this value because it may have changed\n      // after destroying items above\n      // Replace the available items with the ones to keep.\n\n      available = this._availableObjects.length;\n\n      if (available > 0) {\n        this._log(\"this._availableObjects.length=\" + available, \"verbose\");\n\n        this._scheduleRemoveIdle();\n      } else {\n        this._log(\"removeIdle() all objects removed\", \"verbose\");\n      }\n    }\n    /**\n     * Schedule removal of idle items in the pool.\n     *\n     * More schedules cannot run concurrently.\n     */\n\n  }, {\n    key: \"_scheduleRemoveIdle\",\n    value: function _scheduleRemoveIdle() {\n      var _this = this;\n\n      if (!this._removeIdleScheduled) {\n        this._removeIdleScheduled = true;\n        this._removeIdleTimer = setTimeout(function () {\n          _this._removeIdle();\n        }, this._factory.reapInterval);\n      }\n    }\n    /**\n     * Try to get a new client to work, and clean up pool unused (idle) items.\n     *\n     *  - If there are available clients waiting, pop the first one out (LIFO),\n     *    and call its callback.\n     *  - If there are no waiting clients, try to create one if it won't exceed\n     *    the maximum number of clients.\n     *  - If creating a new client would exceed the maximum, add the client to\n     *    the wait list.\n     * @private\n     */\n\n  }, {\n    key: \"_dispense\",\n    value: function _dispense() {\n      var resourceWithTimeout = null;\n      var waitingCount = this._pendingAcquires.length;\n\n      this._log(\"dispense() clients=\".concat(waitingCount, \" available=\").concat(this._availableObjects.length), \"info\");\n\n      if (waitingCount < 1) {\n        return;\n      }\n\n      while (this._availableObjects.length > 0) {\n        this._log(\"dispense() - reusing obj\", \"verbose\");\n\n        resourceWithTimeout = this._availableObjects[this._availableObjects.length - 1];\n\n        if (!this._factory.validate(resourceWithTimeout.resource)) {\n          this.destroy(resourceWithTimeout.resource);\n          continue;\n        }\n\n        this._availableObjects.pop();\n\n        this._inUseObjects.push(resourceWithTimeout.resource);\n\n        var deferred = this._pendingAcquires.shift();\n\n        return deferred.resolve(resourceWithTimeout.resource);\n      }\n\n      if (this._count < this._factory.max) {\n        this._createResource();\n      }\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_createResource\",\n    value: function _createResource() {\n      var _this2 = this;\n\n      this._count += 1;\n\n      this._log(\"createResource() - creating obj - count=\".concat(this._count, \" min=\").concat(this._factory.min, \" max=\").concat(this._factory.max), \"verbose\");\n\n      this._factory.create().then(function (resource) {\n        var deferred = _this2._pendingAcquires.shift();\n\n        _this2._inUseObjects.push(resource);\n\n        if (deferred) {\n          deferred.resolve(resource);\n        } else {\n          _this2._addResourceToAvailableObjects(resource);\n        }\n      }).catch(function (error) {\n        var deferred = _this2._pendingAcquires.shift();\n\n        _this2._count -= 1;\n        if (_this2._count < 0) _this2._count = 0;\n\n        if (deferred) {\n          deferred.reject(error);\n        }\n\n        process.nextTick(function () {\n          _this2._dispense();\n        });\n      });\n    }\n  }, {\n    key: \"_addResourceToAvailableObjects\",\n    value: function _addResourceToAvailableObjects(resource) {\n      var resourceWithTimeout = {\n        resource: resource,\n        timeout: Date.now() + this._factory.idleTimeoutMillis\n      };\n\n      this._availableObjects.push(resourceWithTimeout);\n\n      this._dispense();\n\n      this._scheduleRemoveIdle();\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_ensureMinimum\",\n    value: function _ensureMinimum() {\n      var i, diff;\n\n      if (!this._draining && this._count < this._factory.min) {\n        diff = this._factory.min - this._count;\n\n        for (i = 0; i < diff; i++) {\n          this._createResource();\n        }\n      }\n    }\n    /**\n     * Requests a new resource. This will call factory.create to request new resource.\n     *\n     * It will be rejected with timeout error if `factory.create` didn't respond\n     * back within specified `acquireTimeoutMillis`\n     *\n     * @returns {Promise<Object>}\n     */\n\n  }, {\n    key: \"acquire\",\n    value: function acquire() {\n      var _this3 = this;\n\n      if (this._draining) {\n        return Promise.reject(new Error(\"pool is draining and cannot accept work\"));\n      }\n\n      var deferred = new Deferred();\n      deferred.registerTimeout(this._factory.acquireTimeoutMillis, function () {\n        // timeout triggered, promise will be rejected\n        // remove this object from pending list\n        _this3._pendingAcquires = _this3._pendingAcquires.filter(function (pending) {\n          return pending !== deferred;\n        });\n      });\n\n      this._pendingAcquires.push(deferred);\n\n      this._dispense();\n\n      return deferred.promise();\n    }\n    /**\n     * Return the resource to the pool, in case it is no longer required.\n     *\n     * @param {Object} resource The acquired object to be put back to the pool.\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"release\",\n    value: function release(resource) {\n      // check to see if this object has already been released\n      // (i.e., is back in the pool of this._availableObjects)\n      if (this._availableObjects.some(function (resourceWithTimeout) {\n        return resourceWithTimeout.resource === resource;\n      })) {\n        this._log(\"release called twice for the same resource: \" + new Error().stack, \"error\");\n\n        return;\n      } // check to see if this object exists in the `in use` list and remove it\n\n\n      var index = this._inUseObjects.indexOf(resource);\n\n      if (index < 0) {\n        this._log(\"attempt to release an invalid resource: \" + new Error().stack, \"error\");\n\n        return;\n      }\n\n      this._inUseObjects.splice(index, 1);\n\n      this._addResourceToAvailableObjects(resource);\n    }\n    /**\n     * Request the client to be destroyed. The factory's destroy handler\n     * will also be called.\n     *\n     * This should be called within an acquire() block as an alternative to release().\n     *\n     * @param {Object} resource The acquired item to be destroyed.\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy(resource) {\n      var available = this._availableObjects.length;\n      var using = this._inUseObjects.length;\n      this._availableObjects = this._availableObjects.filter(function (object) {\n        return object.resource !== resource;\n      });\n      this._inUseObjects = this._inUseObjects.filter(function (object) {\n        return object !== resource;\n      }); // resource was not removed, then no need to decrement _count\n\n      if (available === this._availableObjects.length && using === this._inUseObjects.length) {\n        this._ensureMinimum();\n\n        return;\n      }\n\n      this._count -= 1;\n      if (this._count < 0) this._count = 0;\n\n      this._factory.destroy(resource);\n\n      this._ensureMinimum();\n    }\n    /**\n     * Disallow any new requests and let the request backlog dissipate.\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"drain\",\n    value: function drain() {\n      var _this4 = this;\n\n      this._log(\"draining\", \"info\"); // disable the ability to put more work on the queue.\n\n\n      this._draining = true;\n\n      var check = function check(callback) {\n        // wait until all client requests have been satisfied.\n        if (_this4._pendingAcquires.length > 0) {\n          // pool is draining so we wont accept new acquires but\n          // we need to clear pending acquires\n          _this4._dispense();\n\n          return setTimeout(function () {\n            check(callback);\n          }, 100);\n        } // wait until in use object have been released.\n\n\n        if (_this4._availableObjects.length !== _this4._count) {\n          return setTimeout(function () {\n            check(callback);\n          }, 100);\n        }\n\n        callback();\n      }; // No error handling needed here.\n\n\n      return new Promise(function (resolve) {\n        return check(resolve);\n      });\n    }\n    /**\n     * Forcibly destroys all clients regardless of timeout.  Intended to be\n     * invoked as part of a drain.  Does not prevent the creation of new\n     * clients as a result of subsequent calls to acquire.\n     *\n     * Note that if factory.min > 0, the pool will destroy all idle resources\n     * in the pool, but replace them with newly created resources up to the\n     * specified factory.min value.  If this is not desired, set factory.min\n     * to zero before calling destroyAllNow()\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"destroyAllNow\",\n    value: function destroyAllNow() {\n      var _this5 = this;\n\n      this._log(\"force destroying all objects\", \"info\");\n\n      var willDie = this._availableObjects.slice();\n\n      var todo = willDie.length;\n      this._removeIdleScheduled = false;\n      clearTimeout(this._removeIdleTimer);\n      return new Promise(function (resolve) {\n        if (todo === 0) {\n          return resolve();\n        }\n\n        var resource;\n        var done = 0;\n\n        while (resource = willDie.shift()) {\n          _this5.destroy(resource.resource);\n\n          ++done;\n\n          if (done === todo && resolve) {\n            return resolve();\n          }\n        }\n      });\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._count;\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return this._factory.name;\n    }\n  }, {\n    key: \"available\",\n    get: function get() {\n      return this._availableObjects.length;\n    }\n  }, {\n    key: \"using\",\n    get: function get() {\n      return this._inUseObjects.length;\n    }\n  }, {\n    key: \"waiting\",\n    get: function get() {\n      return this._pendingAcquires.length;\n    }\n  }, {\n    key: \"maxSize\",\n    get: function get() {\n      return this._factory.max;\n    }\n  }, {\n    key: \"minSize\",\n    get: function get() {\n      return this._factory.min;\n    }\n  }]);\n\n  return Pool;\n}();\n\nexports.Pool = Pool;\nexports.default = Pool;\nexports.TimeoutError = require(\"./TimeoutError\").TimeoutError;","map":null,"metadata":{},"sourceType":"script"}