{"ast":null,"code":"'use strict'; // https://mysqlserverteam.com/mysql-8-0-4-new-default-authentication-plugin-caching_sha2_password/\n\nvar PLUGIN_NAME = 'caching_sha2_password';\n\nvar crypto = require('crypto');\n\nvar _require = require('../auth_41'),\n    xor = _require.xor,\n    xorRotating = _require.xorRotating;\n\nvar REQUEST_SERVER_KEY_PACKET = Buffer.from([2]);\nvar FAST_AUTH_SUCCESS_PACKET = Buffer.from([3]);\nvar PERFORM_FULL_AUTHENTICATION_PACKET = Buffer.from([4]);\nvar STATE_INITIAL = 0;\nvar STATE_TOKEN_SENT = 1;\nvar STATE_WAIT_SERVER_KEY = 2;\nvar STATE_FINAL = -1;\n\nfunction sha256(msg) {\n  var hash = crypto.createHash('sha256');\n  hash.update(msg, 'binary');\n  return hash.digest('binary');\n}\n\nfunction calculateToken(password, scramble) {\n  if (!password) {\n    return Buffer.alloc(0);\n  }\n\n  var stage1 = sha256(Buffer.from(password, 'utf8').toString('binary'));\n  var stage2 = sha256(stage1);\n  var stage3 = sha256(stage2 + scramble.toString('binary'));\n  return xor(stage1, stage3);\n}\n\nfunction encrypt(password, scramble, key) {\n  var stage1 = xorRotating(Buffer.from(\"\".concat(password, \"\\0\"), 'utf8').toString('binary'), scramble.toString('binary'));\n  return crypto.publicEncrypt(key, stage1);\n}\n\nmodule.exports = function () {\n  var pluginOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return function (_ref) {\n    var connection = _ref.connection;\n    var state = 0;\n    var scramble = null;\n    var password = connection.config.password;\n\n    var authWithKey = function authWithKey(serverKey) {\n      var _password = encrypt(password, scramble, serverKey);\n\n      state = STATE_FINAL;\n      return _password;\n    };\n\n    return function (data) {\n      switch (state) {\n        case STATE_INITIAL:\n          scramble = data.slice(0, 20);\n          state = STATE_TOKEN_SENT;\n          return calculateToken(password, scramble);\n\n        case STATE_TOKEN_SENT:\n          if (FAST_AUTH_SUCCESS_PACKET.equals(data)) {\n            state = STATE_FINAL;\n            return null;\n          }\n\n          if (PERFORM_FULL_AUTHENTICATION_PACKET.equals(data)) {\n            var isSecureConnection = typeof pluginOptions.overrideIsSecure === 'undefined' ? connection.config.ssl || connection.config.socketPath : pluginOptions.overrideIsSecure;\n\n            if (isSecureConnection) {\n              state = STATE_FINAL;\n              return Buffer.from(\"\".concat(password, \"\\0\"), 'utf8');\n            } // if client provides key we can save one extra roundrip on first connection\n\n\n            if (pluginOptions.serverPublicKey) {\n              return authWithKey(pluginOptions.serverPublicKey);\n            }\n\n            state = STATE_WAIT_SERVER_KEY;\n            return REQUEST_SERVER_KEY_PACKET;\n          }\n\n          throw new Error(\"Invalid AuthMoreData packet received by \".concat(PLUGIN_NAME, \" plugin in STATE_TOKEN_SENT state.\"));\n\n        case STATE_WAIT_SERVER_KEY:\n          if (pluginOptions.onServerPublicKey) {\n            pluginOptions.onServerPublicKey(data);\n          }\n\n          return authWithKey(data);\n\n        case STATE_FINAL:\n          throw new Error(\"Unexpected data in AuthMoreData packet received by \".concat(PLUGIN_NAME, \" plugin in STATE_FINAL state.\"));\n      }\n\n      throw new Error(\"Unexpected data in AuthMoreData packet received by \".concat(PLUGIN_NAME, \" plugin in state \").concat(state));\n    };\n  };\n};","map":null,"metadata":{},"sourceType":"script"}