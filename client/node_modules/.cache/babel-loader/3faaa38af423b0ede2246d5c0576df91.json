{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _ = require('lodash');\n\nvar SqlString = require('../../sql-string');\n\nvar QueryTypes = require('../../query-types');\n\nvar Dot = require('dottie');\n\nvar deprecations = require('../../utils/deprecations');\n\nvar uuid = require('uuid/v4');\n\nvar AbstractQuery = /*#__PURE__*/function () {\n  function AbstractQuery(connection, sequelize, options) {\n    _classCallCheck(this, AbstractQuery);\n\n    this.uuid = uuid();\n    this.connection = connection;\n    this.instance = options.instance;\n    this.model = options.model;\n    this.sequelize = sequelize;\n    this.options = Object.assign({\n      plain: false,\n      raw: false,\n      // eslint-disable-next-line no-console\n      logging: console.log\n    }, options || {});\n    this.checkLoggingOption();\n  }\n  /**\n   * rewrite query with parameters\n   *\n   * Examples:\n   *\n   *   query.formatBindParameters('select $1 as foo', ['fooval']);\n   *\n   *   query.formatBindParameters('select $foo as foo', { foo: 'fooval' });\n   *\n   * Options\n   *   skipUnescape: bool, skip unescaping $$\n   *   skipValueReplace: bool, do not replace (but do unescape $$). Check correct syntax and if all values are available\n   *\n   * @param {string} sql\n   * @param {Object|Array} values\n   * @param {string} dialect\n   * @param {Function} [replacementFunc]\n   * @param {Object} [options]\n   * @private\n   */\n\n\n  _createClass(AbstractQuery, [{\n    key: \"run\",\n\n    /**\n     * Execute the passed sql query.\n     *\n     * Examples:\n     *\n     *     query.run('SELECT 1')\n     *\n     * @private\n     */\n    value: function run() {\n      throw new Error('The run method wasn\\'t overwritten!');\n    }\n    /**\n     * Check the logging option of the instance and print deprecation warnings.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"checkLoggingOption\",\n    value: function checkLoggingOption() {\n      if (this.options.logging === true) {\n        deprecations.noTrueLogging(); // eslint-disable-next-line no-console\n\n        this.options.logging = console.log;\n      }\n    }\n    /**\n     * Get the attributes of an insert query, which contains the just inserted id.\n     *\n     * @returns {string} The field name.\n     * @private\n     */\n\n  }, {\n    key: \"getInsertIdField\",\n    value: function getInsertIdField() {\n      return 'insertId';\n    }\n  }, {\n    key: \"getUniqueConstraintErrorMessage\",\n    value: function getUniqueConstraintErrorMessage(field) {\n      var message = field ? \"\".concat(field, \" must be unique\") : 'Must be unique';\n\n      if (field && this.model) {\n        for (var _i = 0, _Object$keys = Object.keys(this.model.uniqueKeys); _i < _Object$keys.length; _i++) {\n          var key = _Object$keys[_i];\n\n          if (this.model.uniqueKeys[key].fields.includes(field.replace(/\"/g, ''))) {\n            if (this.model.uniqueKeys[key].msg) {\n              message = this.model.uniqueKeys[key].msg;\n            }\n          }\n        }\n      }\n\n      return message;\n    }\n  }, {\n    key: \"isRawQuery\",\n    value: function isRawQuery() {\n      return this.options.type === QueryTypes.RAW;\n    }\n  }, {\n    key: \"isVersionQuery\",\n    value: function isVersionQuery() {\n      return this.options.type === QueryTypes.VERSION;\n    }\n  }, {\n    key: \"isUpsertQuery\",\n    value: function isUpsertQuery() {\n      return this.options.type === QueryTypes.UPSERT;\n    }\n  }, {\n    key: \"isInsertQuery\",\n    value: function isInsertQuery(results, metaData) {\n      var result = true;\n\n      if (this.options.type === QueryTypes.INSERT) {\n        return true;\n      } // is insert query if sql contains insert into\n\n\n      result = result && this.sql.toLowerCase().startsWith('insert into'); // is insert query if no results are passed or if the result has the inserted id\n\n      result = result && (!results || Object.prototype.hasOwnProperty.call(results, this.getInsertIdField())); // is insert query if no metadata are passed or if the metadata has the inserted id\n\n      result = result && (!metaData || Object.prototype.hasOwnProperty.call(metaData, this.getInsertIdField()));\n      return result;\n    }\n  }, {\n    key: \"handleInsertQuery\",\n    value: function handleInsertQuery(results, metaData) {\n      if (this.instance) {\n        // add the inserted row id to the instance\n        var autoIncrementAttribute = this.model.autoIncrementAttribute;\n        var id = null;\n        id = id || results && results[this.getInsertIdField()];\n        id = id || metaData && metaData[this.getInsertIdField()];\n        this.instance[autoIncrementAttribute] = id;\n      }\n    }\n  }, {\n    key: \"isShowTablesQuery\",\n    value: function isShowTablesQuery() {\n      return this.options.type === QueryTypes.SHOWTABLES;\n    }\n  }, {\n    key: \"handleShowTablesQuery\",\n    value: function handleShowTablesQuery(results) {\n      return _.flatten(results.map(function (resultSet) {\n        return _.values(resultSet);\n      }));\n    }\n  }, {\n    key: \"isShowIndexesQuery\",\n    value: function isShowIndexesQuery() {\n      return this.options.type === QueryTypes.SHOWINDEXES;\n    }\n  }, {\n    key: \"isShowConstraintsQuery\",\n    value: function isShowConstraintsQuery() {\n      return this.options.type === QueryTypes.SHOWCONSTRAINTS;\n    }\n  }, {\n    key: \"isDescribeQuery\",\n    value: function isDescribeQuery() {\n      return this.options.type === QueryTypes.DESCRIBE;\n    }\n  }, {\n    key: \"isSelectQuery\",\n    value: function isSelectQuery() {\n      return this.options.type === QueryTypes.SELECT;\n    }\n  }, {\n    key: \"isBulkUpdateQuery\",\n    value: function isBulkUpdateQuery() {\n      return this.options.type === QueryTypes.BULKUPDATE;\n    }\n  }, {\n    key: \"isBulkDeleteQuery\",\n    value: function isBulkDeleteQuery() {\n      return this.options.type === QueryTypes.BULKDELETE;\n    }\n  }, {\n    key: \"isForeignKeysQuery\",\n    value: function isForeignKeysQuery() {\n      return this.options.type === QueryTypes.FOREIGNKEYS;\n    }\n  }, {\n    key: \"isUpdateQuery\",\n    value: function isUpdateQuery() {\n      return this.options.type === QueryTypes.UPDATE;\n    }\n  }, {\n    key: \"handleSelectQuery\",\n    value: function handleSelectQuery(results) {\n      var _this = this;\n\n      var result = null; // Map raw fields to names if a mapping is provided\n\n      if (this.options.fieldMap) {\n        var fieldMap = this.options.fieldMap;\n        results = results.map(function (result) {\n          return _.reduce(fieldMap, function (result, name, field) {\n            if (result[field] !== undefined && name !== field) {\n              result[name] = result[field];\n              delete result[field];\n            }\n\n            return result;\n          }, result);\n        });\n      } // Raw queries\n\n\n      if (this.options.raw) {\n        result = results.map(function (result) {\n          var o = {};\n\n          for (var key in result) {\n            if (Object.prototype.hasOwnProperty.call(result, key)) {\n              o[key] = result[key];\n            }\n          }\n\n          if (_this.options.nest) {\n            o = Dot.transform(o);\n          }\n\n          return o;\n        }); // Queries with include\n      } else if (this.options.hasJoin === true) {\n        results = AbstractQuery._groupJoinData(results, {\n          model: this.model,\n          includeMap: this.options.includeMap,\n          includeNames: this.options.includeNames\n        }, {\n          checkExisting: this.options.hasMultiAssociation\n        });\n        result = this.model.bulkBuild(results, {\n          isNewRecord: false,\n          include: this.options.include,\n          includeNames: this.options.includeNames,\n          includeMap: this.options.includeMap,\n          includeValidated: true,\n          attributes: this.options.originalAttributes || this.options.attributes,\n          raw: true\n        }); // Regular queries\n      } else {\n        result = this.model.bulkBuild(results, {\n          isNewRecord: false,\n          raw: true,\n          attributes: this.options.originalAttributes || this.options.attributes\n        });\n      } // return the first real model instance if options.plain is set (e.g. Model.find)\n\n\n      if (this.options.plain) {\n        result = result.length === 0 ? null : result[0];\n      }\n\n      return result;\n    }\n  }, {\n    key: \"isShowOrDescribeQuery\",\n    value: function isShowOrDescribeQuery() {\n      var result = false;\n      result = result || this.sql.toLowerCase().startsWith('show');\n      result = result || this.sql.toLowerCase().startsWith('describe');\n      return result;\n    }\n  }, {\n    key: \"isCallQuery\",\n    value: function isCallQuery() {\n      return this.sql.toLowerCase().startsWith('call');\n    }\n    /**\n     * @param {string} sql\n     * @param {Function} debugContext\n     * @param {Array|Object} parameters\n     * @protected\n     * @returns {Function} A function to call after the query was completed.\n     */\n\n  }, {\n    key: \"_logQuery\",\n    value: function _logQuery(sql, debugContext, parameters) {\n      var _this2 = this;\n\n      var connection = this.connection,\n          options = this.options;\n      var benchmark = this.sequelize.options.benchmark || options.benchmark;\n      var logQueryParameters = this.sequelize.options.logQueryParameters || options.logQueryParameters;\n      var startTime = Date.now();\n      var logParameter = '';\n\n      if (logQueryParameters && parameters) {\n        var delimiter = sql.endsWith(';') ? '' : ';';\n        var paramStr;\n\n        if (Array.isArray(parameters)) {\n          paramStr = parameters.map(function (p) {\n            return JSON.stringify(p);\n          }).join(', ');\n        } else {\n          paramStr = JSON.stringify(parameters);\n        }\n\n        logParameter = \"\".concat(delimiter, \" \").concat(paramStr);\n      }\n\n      var fmt = \"(\".concat(connection.uuid || 'default', \"): \").concat(sql).concat(logParameter);\n      var msg = \"Executing \".concat(fmt);\n      debugContext(msg);\n\n      if (!benchmark) {\n        this.sequelize.log(\"Executing \".concat(fmt), options);\n      }\n\n      return function () {\n        var afterMsg = \"Executed \".concat(fmt);\n        debugContext(afterMsg);\n\n        if (benchmark) {\n          _this2.sequelize.log(afterMsg, Date.now() - startTime, options);\n        }\n      };\n    }\n    /**\n     * The function takes the result of the query execution and groups\n     * the associated data by the callee.\n     *\n     * Example:\n     *   groupJoinData([\n     *     {\n     *       some: 'data',\n     *       id: 1,\n     *       association: { foo: 'bar', id: 1 }\n     *     }, {\n     *       some: 'data',\n     *       id: 1,\n     *       association: { foo: 'bar', id: 2 }\n     *     }, {\n     *       some: 'data',\n     *       id: 1,\n     *       association: { foo: 'bar', id: 3 }\n     *     }\n     *   ])\n     *\n     * Result:\n     *   Something like this:\n     *\n     *   [\n     *     {\n     *       some: 'data',\n     *       id: 1,\n     *       association: [\n     *         { foo: 'bar', id: 1 },\n     *         { foo: 'bar', id: 2 },\n     *         { foo: 'bar', id: 3 }\n     *       ]\n     *     }\n     *   ]\n     *\n     * @param {Array} rows\n     * @param {Object} includeOptions\n     * @param {Object} options\n     * @private\n     */\n\n  }], [{\n    key: \"formatBindParameters\",\n    value: function formatBindParameters(sql, values, dialect, replacementFunc, options) {\n      if (!values) {\n        return [sql, []];\n      }\n\n      options = options || {};\n\n      if (typeof replacementFunc !== 'function') {\n        options = replacementFunc || {};\n        replacementFunc = undefined;\n      }\n\n      if (!replacementFunc) {\n        if (options.skipValueReplace) {\n          replacementFunc = function replacementFunc(match, key, values) {\n            if (values[key] !== undefined) {\n              return match;\n            }\n\n            return undefined;\n          };\n        } else {\n          replacementFunc = function replacementFunc(match, key, values, timeZone, dialect) {\n            if (values[key] !== undefined) {\n              return SqlString.escape(values[key], timeZone, dialect);\n            }\n\n            return undefined;\n          };\n        }\n      } else if (options.skipValueReplace) {\n        var origReplacementFunc = replacementFunc;\n\n        replacementFunc = function replacementFunc(match, key, values, timeZone, dialect, options) {\n          if (origReplacementFunc(match, key, values, timeZone, dialect, options) !== undefined) {\n            return match;\n          }\n\n          return undefined;\n        };\n      }\n\n      var timeZone = null;\n      var list = Array.isArray(values);\n      sql = sql.replace(/\\$(\\$|\\w+)/g, function (match, key) {\n        if ('$' === key) {\n          return options.skipUnescape ? match : key;\n        }\n\n        var replVal;\n\n        if (list) {\n          if (key.match(/^[1-9]\\d*$/)) {\n            key = key - 1;\n            replVal = replacementFunc(match, key, values, timeZone, dialect, options);\n          }\n        } else if (!key.match(/^\\d*$/)) {\n          replVal = replacementFunc(match, key, values, timeZone, dialect, options);\n        }\n\n        if (replVal === undefined) {\n          throw new Error(\"Named bind parameter \\\"\".concat(match, \"\\\" has no value in the given object.\"));\n        }\n\n        return replVal;\n      });\n      return [sql, []];\n    }\n  }, {\n    key: \"_groupJoinData\",\n    value: function _groupJoinData(rows, includeOptions, options) {\n      /*\n       * Assumptions\n       * ID is not necessarily the first field\n       * All fields for a level is grouped in the same set (i.e. Panel.id, Task.id, Panel.title is not possible)\n       * Parent keys will be seen before any include/child keys\n       * Previous set won't necessarily be parent set (one parent could have two children, one child would then be previous set for the other)\n       */\n\n      /*\n       * Author (MH) comment: This code is an unreadable mess, but it's performant.\n       * groupJoinData is a performance critical function so we prioritize perf over readability.\n       */\n      if (!rows.length) {\n        return [];\n      } // Generic looping\n\n\n      var i;\n      var length;\n      var $i;\n      var $length; // Row specific looping\n\n      var rowsI;\n      var row;\n      var rowsLength = rows.length; // Key specific looping\n\n      var keys;\n      var key;\n      var keyI;\n      var keyLength;\n      var prevKey;\n      var values;\n      var topValues;\n      var topExists;\n      var checkExisting = options.checkExisting; // If we don't have to deduplicate we can pre-allocate the resulting array\n\n      var itemHash;\n      var parentHash;\n      var topHash;\n      var results = checkExisting ? [] : new Array(rowsLength);\n      var resultMap = {};\n      var includeMap = {}; // Result variables for the respective functions\n\n      var $keyPrefix;\n      var $keyPrefixString;\n      var $prevKeyPrefixString; // eslint-disable-line\n\n      var $prevKeyPrefix;\n      var $lastKeyPrefix;\n      var $current;\n      var $parent; // Map each key to an include option\n\n      var previousPiece;\n\n      var buildIncludeMap = function buildIncludeMap(piece) {\n        if (Object.prototype.hasOwnProperty.call($current.includeMap, piece)) {\n          includeMap[key] = $current = $current.includeMap[piece];\n\n          if (previousPiece) {\n            previousPiece = \"\".concat(previousPiece, \".\").concat(piece);\n          } else {\n            previousPiece = piece;\n          }\n\n          includeMap[previousPiece] = $current;\n        }\n      }; // Calculate the string prefix of a key ('User.Results' for 'User.Results.id')\n\n\n      var keyPrefixStringMemo = {};\n\n      var keyPrefixString = function keyPrefixString(key, memo) {\n        if (!Object.prototype.hasOwnProperty.call(memo, key)) {\n          memo[key] = key.substr(0, key.lastIndexOf('.'));\n        }\n\n        return memo[key];\n      }; // Removes the prefix from a key ('id' for 'User.Results.id')\n\n\n      var removeKeyPrefixMemo = {};\n\n      var removeKeyPrefix = function removeKeyPrefix(key) {\n        if (!Object.prototype.hasOwnProperty.call(removeKeyPrefixMemo, key)) {\n          var index = key.lastIndexOf('.');\n          removeKeyPrefixMemo[key] = key.substr(index === -1 ? 0 : index + 1);\n        }\n\n        return removeKeyPrefixMemo[key];\n      }; // Calculates the array prefix of a key (['User', 'Results'] for 'User.Results.id')\n\n\n      var keyPrefixMemo = {};\n\n      var keyPrefix = function keyPrefix(key) {\n        // We use a double memo and keyPrefixString so that different keys with the same prefix will receive the same array instead of differnet arrays with equal values\n        if (!Object.prototype.hasOwnProperty.call(keyPrefixMemo, key)) {\n          var prefixString = keyPrefixString(key, keyPrefixStringMemo);\n\n          if (!Object.prototype.hasOwnProperty.call(keyPrefixMemo, prefixString)) {\n            keyPrefixMemo[prefixString] = prefixString ? prefixString.split('.') : [];\n          }\n\n          keyPrefixMemo[key] = keyPrefixMemo[prefixString];\n        }\n\n        return keyPrefixMemo[key];\n      }; // Calcuate the last item in the array prefix ('Results' for 'User.Results.id')\n\n\n      var lastKeyPrefixMemo = {};\n\n      var lastKeyPrefix = function lastKeyPrefix(key) {\n        if (!Object.prototype.hasOwnProperty.call(lastKeyPrefixMemo, key)) {\n          var _prefix = keyPrefix(key);\n\n          var _length = _prefix.length;\n          lastKeyPrefixMemo[key] = !_length ? '' : _prefix[_length - 1];\n        }\n\n        return lastKeyPrefixMemo[key];\n      };\n\n      var getUniqueKeyAttributes = function getUniqueKeyAttributes(model) {\n        var uniqueKeyAttributes = _.chain(model.uniqueKeys);\n\n        uniqueKeyAttributes = uniqueKeyAttributes.result(\"\".concat(uniqueKeyAttributes.findKey(), \".fields\")).map(function (field) {\n          return _.findKey(model.attributes, function (chr) {\n            return chr.field === field;\n          });\n        }).value();\n        return uniqueKeyAttributes;\n      };\n\n      var stringify = function stringify(obj) {\n        return obj instanceof Buffer ? obj.toString('hex') : obj;\n      };\n\n      var primaryKeyAttributes;\n      var uniqueKeyAttributes;\n      var prefix;\n\n      for (rowsI = 0; rowsI < rowsLength; rowsI++) {\n        row = rows[rowsI]; // Keys are the same for all rows, so only need to compute them on the first row\n\n        if (rowsI === 0) {\n          keys = Object.keys(row);\n          keyLength = keys.length;\n        }\n\n        if (checkExisting) {\n          topExists = false; // Compute top level hash key (this is usually just the primary key values)\n\n          $length = includeOptions.model.primaryKeyAttributes.length;\n          topHash = '';\n\n          if ($length === 1) {\n            topHash = stringify(row[includeOptions.model.primaryKeyAttributes[0]]);\n          } else if ($length > 1) {\n            for ($i = 0; $i < $length; $i++) {\n              topHash += stringify(row[includeOptions.model.primaryKeyAttributes[$i]]);\n            }\n          } else if (!_.isEmpty(includeOptions.model.uniqueKeys)) {\n            uniqueKeyAttributes = getUniqueKeyAttributes(includeOptions.model);\n\n            for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {\n              topHash += row[uniqueKeyAttributes[$i]];\n            }\n          }\n        }\n\n        topValues = values = {};\n        $prevKeyPrefix = undefined;\n\n        for (keyI = 0; keyI < keyLength; keyI++) {\n          key = keys[keyI]; // The string prefix isn't actualy needed\n          // We use it so keyPrefix for different keys will resolve to the same array if they have the same prefix\n          // TODO: Find a better way?\n\n          $keyPrefixString = keyPrefixString(key, keyPrefixStringMemo);\n          $keyPrefix = keyPrefix(key); // On the first row we compute the includeMap\n\n          if (rowsI === 0 && !Object.prototype.hasOwnProperty.call(includeMap, key)) {\n            if (!$keyPrefix.length) {\n              includeMap[key] = includeMap[''] = includeOptions;\n            } else {\n              $current = includeOptions;\n              previousPiece = undefined;\n              $keyPrefix.forEach(buildIncludeMap);\n            }\n          } // End of key set\n\n\n          if ($prevKeyPrefix !== undefined && $prevKeyPrefix !== $keyPrefix) {\n            if (checkExisting) {\n              // Compute hash key for this set instance\n              // TODO: Optimize\n              length = $prevKeyPrefix.length;\n              $parent = null;\n              parentHash = null;\n\n              if (length) {\n                for (i = 0; i < length; i++) {\n                  prefix = $parent ? \"\".concat($parent, \".\").concat($prevKeyPrefix[i]) : $prevKeyPrefix[i];\n                  primaryKeyAttributes = includeMap[prefix].model.primaryKeyAttributes;\n                  $length = primaryKeyAttributes.length;\n                  itemHash = prefix;\n\n                  if ($length === 1) {\n                    itemHash += stringify(row[\"\".concat(prefix, \".\").concat(primaryKeyAttributes[0])]);\n                  } else if ($length > 1) {\n                    for ($i = 0; $i < $length; $i++) {\n                      itemHash += stringify(row[\"\".concat(prefix, \".\").concat(primaryKeyAttributes[$i])]);\n                    }\n                  } else if (!_.isEmpty(includeMap[prefix].model.uniqueKeys)) {\n                    uniqueKeyAttributes = getUniqueKeyAttributes(includeMap[prefix].model);\n\n                    for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {\n                      itemHash += row[\"\".concat(prefix, \".\").concat(uniqueKeyAttributes[$i])];\n                    }\n                  }\n\n                  if (!parentHash) {\n                    parentHash = topHash;\n                  }\n\n                  itemHash = parentHash + itemHash;\n                  $parent = prefix;\n\n                  if (i < length - 1) {\n                    parentHash = itemHash;\n                  }\n                }\n              } else {\n                itemHash = topHash;\n              }\n\n              if (itemHash === topHash) {\n                if (!resultMap[itemHash]) {\n                  resultMap[itemHash] = values;\n                } else {\n                  topExists = true;\n                }\n              } else if (!resultMap[itemHash]) {\n                $parent = resultMap[parentHash];\n                $lastKeyPrefix = lastKeyPrefix(prevKey);\n\n                if (includeMap[prevKey].association.isSingleAssociation) {\n                  if ($parent) {\n                    $parent[$lastKeyPrefix] = resultMap[itemHash] = values;\n                  }\n                } else {\n                  if (!$parent[$lastKeyPrefix]) {\n                    $parent[$lastKeyPrefix] = [];\n                  }\n\n                  $parent[$lastKeyPrefix].push(resultMap[itemHash] = values);\n                }\n              } // Reset values\n\n\n              values = {};\n            } else {\n              // If checkExisting is false it's because there's only 1:1 associations in this query\n              // However we still need to map onto the appropriate parent\n              // For 1:1 we map forward, initializing the value object on the parent to be filled in the next iterations of the loop\n              $current = topValues;\n              length = $keyPrefix.length;\n\n              if (length) {\n                for (i = 0; i < length; i++) {\n                  if (i === length - 1) {\n                    values = $current[$keyPrefix[i]] = {};\n                  }\n\n                  $current = $current[$keyPrefix[i]] || {};\n                }\n              }\n            }\n          } // End of iteration, set value and set prev values (for next iteration)\n\n\n          values[removeKeyPrefix(key)] = row[key];\n          prevKey = key;\n          $prevKeyPrefix = $keyPrefix;\n          $prevKeyPrefixString = $keyPrefixString;\n        }\n\n        if (checkExisting) {\n          length = $prevKeyPrefix.length;\n          $parent = null;\n          parentHash = null;\n\n          if (length) {\n            for (i = 0; i < length; i++) {\n              prefix = $parent ? \"\".concat($parent, \".\").concat($prevKeyPrefix[i]) : $prevKeyPrefix[i];\n              primaryKeyAttributes = includeMap[prefix].model.primaryKeyAttributes;\n              $length = primaryKeyAttributes.length;\n              itemHash = prefix;\n\n              if ($length === 1) {\n                itemHash += stringify(row[\"\".concat(prefix, \".\").concat(primaryKeyAttributes[0])]);\n              } else if ($length > 0) {\n                for ($i = 0; $i < $length; $i++) {\n                  itemHash += stringify(row[\"\".concat(prefix, \".\").concat(primaryKeyAttributes[$i])]);\n                }\n              } else if (!_.isEmpty(includeMap[prefix].model.uniqueKeys)) {\n                uniqueKeyAttributes = getUniqueKeyAttributes(includeMap[prefix].model);\n\n                for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {\n                  itemHash += row[\"\".concat(prefix, \".\").concat(uniqueKeyAttributes[$i])];\n                }\n              }\n\n              if (!parentHash) {\n                parentHash = topHash;\n              }\n\n              itemHash = parentHash + itemHash;\n              $parent = prefix;\n\n              if (i < length - 1) {\n                parentHash = itemHash;\n              }\n            }\n          } else {\n            itemHash = topHash;\n          }\n\n          if (itemHash === topHash) {\n            if (!resultMap[itemHash]) {\n              resultMap[itemHash] = values;\n            } else {\n              topExists = true;\n            }\n          } else if (!resultMap[itemHash]) {\n            $parent = resultMap[parentHash];\n            $lastKeyPrefix = lastKeyPrefix(prevKey);\n\n            if (includeMap[prevKey].association.isSingleAssociation) {\n              if ($parent) {\n                $parent[$lastKeyPrefix] = resultMap[itemHash] = values;\n              }\n            } else {\n              if (!$parent[$lastKeyPrefix]) {\n                $parent[$lastKeyPrefix] = [];\n              }\n\n              $parent[$lastKeyPrefix].push(resultMap[itemHash] = values);\n            }\n          }\n\n          if (!topExists) {\n            results.push(topValues);\n          }\n        } else {\n          results[rowsI] = topValues;\n        }\n      }\n\n      return results;\n    }\n  }]);\n\n  return AbstractQuery;\n}();\n\nmodule.exports = AbstractQuery;\nmodule.exports.AbstractQuery = AbstractQuery;\nmodule.exports.default = AbstractQuery;","map":null,"metadata":{},"sourceType":"script"}