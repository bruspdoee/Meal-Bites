{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _get = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar _ = require('lodash');\n\nvar Utils = require('../../utils');\n\nvar DataTypes = require('../../data-types');\n\nvar TableHints = require('../../table-hints');\n\nvar AbstractQueryGenerator = require('../abstract/query-generator');\n\nvar randomBytes = require('crypto').randomBytes;\n\nvar semver = require('semver');\n\nvar Op = require('../../operators');\n/* istanbul ignore next */\n\n\nvar throwMethodUndefined = function throwMethodUndefined(methodName) {\n  throw new Error(\"The method \\\"\".concat(methodName, \"\\\" is not defined! Please add it to your sql dialect.\"));\n};\n\nvar MSSQLQueryGenerator = /*#__PURE__*/function (_AbstractQueryGenerat) {\n  _inherits(MSSQLQueryGenerator, _AbstractQueryGenerat);\n\n  function MSSQLQueryGenerator() {\n    _classCallCheck(this, MSSQLQueryGenerator);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MSSQLQueryGenerator).apply(this, arguments));\n  }\n\n  _createClass(MSSQLQueryGenerator, [{\n    key: \"createDatabaseQuery\",\n    value: function createDatabaseQuery(databaseName, options) {\n      options = Object.assign({\n        collate: null\n      }, options || {});\n      var collation = options.collate ? \"COLLATE \".concat(this.escape(options.collate)) : '';\n      return ['IF NOT EXISTS (SELECT * FROM sys.databases WHERE name =', wrapSingleQuote(databaseName), ')', 'BEGIN', 'CREATE DATABASE', this.quoteIdentifier(databaseName), \"\".concat(collation, \";\"), 'END;'].join(' ');\n    }\n  }, {\n    key: \"dropDatabaseQuery\",\n    value: function dropDatabaseQuery(databaseName) {\n      return ['IF EXISTS (SELECT * FROM sys.databases WHERE name =', wrapSingleQuote(databaseName), ')', 'BEGIN', 'DROP DATABASE', this.quoteIdentifier(databaseName), ';', 'END;'].join(' ');\n    }\n  }, {\n    key: \"createSchema\",\n    value: function createSchema(schema) {\n      return ['IF NOT EXISTS (SELECT schema_name', 'FROM information_schema.schemata', 'WHERE schema_name =', wrapSingleQuote(schema), ')', 'BEGIN', \"EXEC sp_executesql N'CREATE SCHEMA\", this.quoteIdentifier(schema), \";'\", 'END;'].join(' ');\n    }\n  }, {\n    key: \"dropSchema\",\n    value: function dropSchema(schema) {\n      // Mimics Postgres CASCADE, will drop objects belonging to the schema\n      var quotedSchema = wrapSingleQuote(schema);\n      return ['IF EXISTS (SELECT schema_name', 'FROM information_schema.schemata', 'WHERE schema_name =', quotedSchema, ')', 'BEGIN', 'DECLARE @id INT, @ms_sql NVARCHAR(2000);', 'DECLARE @cascade TABLE (', 'id INT NOT NULL IDENTITY PRIMARY KEY,', 'ms_sql NVARCHAR(2000) NOT NULL );', 'INSERT INTO @cascade ( ms_sql )', \"SELECT CASE WHEN o.type IN ('F','PK')\", \"THEN N'ALTER TABLE ['+ s.name + N'].[' + p.name + N'] DROP CONSTRAINT [' + o.name + N']'\", \"ELSE N'DROP TABLE ['+ s.name + N'].[' + o.name + N']' END\", 'FROM sys.objects o', 'JOIN sys.schemas s on o.schema_id = s.schema_id', 'LEFT OUTER JOIN sys.objects p on o.parent_object_id = p.object_id', \"WHERE o.type IN ('F', 'PK', 'U') AND s.name = \", quotedSchema, 'ORDER BY o.type ASC;', 'SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;', 'WHILE @id IS NOT NULL', 'BEGIN', 'BEGIN TRY EXEC sp_executesql @ms_sql; END TRY', 'BEGIN CATCH BREAK; THROW; END CATCH;', 'DELETE FROM @cascade WHERE id = @id;', 'SELECT @id = NULL, @ms_sql = NULL;', 'SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;', 'END', \"EXEC sp_executesql N'DROP SCHEMA\", this.quoteIdentifier(schema), \";'\", 'END;'].join(' ');\n    }\n  }, {\n    key: \"showSchemasQuery\",\n    value: function showSchemasQuery() {\n      return ['SELECT \"name\" as \"schema_name\" FROM sys.schemas as s', 'WHERE \"s\".\"name\" NOT IN (', \"'INFORMATION_SCHEMA', 'dbo', 'guest', 'sys', 'archive'\", ')', 'AND', '\"s\".\"name\" NOT LIKE', \"'db_%'\"].join(' ');\n    }\n  }, {\n    key: \"versionQuery\",\n    value: function versionQuery() {\n      // Uses string manipulation to convert the MS Maj.Min.Patch.Build to semver Maj.Min.Patch\n      return ['DECLARE @ms_ver NVARCHAR(20);', \"SET @ms_ver = REVERSE(CONVERT(NVARCHAR(20), SERVERPROPERTY('ProductVersion')));\", \"SELECT REVERSE(SUBSTRING(@ms_ver, CHARINDEX('.', @ms_ver)+1, 20)) AS 'version'\"].join(' ');\n    }\n  }, {\n    key: \"createTableQuery\",\n    value: function createTableQuery(tableName, attributes, options) {\n      var _this = this;\n\n      var query = function query(table, attrs) {\n        return \"IF OBJECT_ID('\".concat(table, \"', 'U') IS NULL CREATE TABLE \").concat(table, \" (\").concat(attrs, \")\");\n      },\n          primaryKeys = [],\n          foreignKeys = {},\n          attrStr = [];\n\n      var commentStr = '';\n\n      for (var attr in attributes) {\n        if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n          var dataType = attributes[attr];\n          var match = void 0;\n\n          if (dataType.includes('COMMENT ')) {\n            var commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);\n            var commentText = commentMatch[2].replace('COMMENT', '').trim();\n            commentStr += this.commentTemplate(commentText, tableName, attr); // remove comment related substring from dataType\n\n            dataType = commentMatch[1];\n          }\n\n          if (dataType.includes('PRIMARY KEY')) {\n            primaryKeys.push(attr);\n\n            if (dataType.includes('REFERENCES')) {\n              // MSSQL doesn't support inline REFERENCES declarations: move to the end\n              match = dataType.match(/^(.+) (REFERENCES.*)$/);\n              attrStr.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(match[1].replace('PRIMARY KEY', '')));\n              foreignKeys[attr] = match[2];\n            } else {\n              attrStr.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(dataType.replace('PRIMARY KEY', '')));\n            }\n          } else if (dataType.includes('REFERENCES')) {\n            // MSSQL doesn't support inline REFERENCES declarations: move to the end\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attrStr.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(match[1]));\n            foreignKeys[attr] = match[2];\n          } else {\n            attrStr.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(dataType));\n          }\n        }\n      }\n\n      var attributesClause = attrStr.join(', ');\n      var pkString = primaryKeys.map(function (pk) {\n        return _this.quoteIdentifier(pk);\n      }).join(', ');\n\n      if (options.uniqueKeys) {\n        _.each(options.uniqueKeys, function (columns, indexName) {\n          if (columns.customIndex) {\n            if (typeof indexName !== 'string') {\n              indexName = \"uniq_\".concat(tableName, \"_\").concat(columns.fields.join('_'));\n            }\n\n            attributesClause += \", CONSTRAINT \".concat(_this.quoteIdentifier(indexName), \" UNIQUE (\").concat(columns.fields.map(function (field) {\n              return _this.quoteIdentifier(field);\n            }).join(', '), \")\");\n          }\n        });\n      }\n\n      if (pkString.length > 0) {\n        attributesClause += \", PRIMARY KEY (\".concat(pkString, \")\");\n      }\n\n      for (var fkey in foreignKeys) {\n        if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n          attributesClause += \", FOREIGN KEY (\".concat(this.quoteIdentifier(fkey), \") \").concat(foreignKeys[fkey]);\n        }\n      }\n\n      return \"\".concat(query(this.quoteTable(tableName), attributesClause), \";\").concat(commentStr);\n    }\n  }, {\n    key: \"describeTableQuery\",\n    value: function describeTableQuery(tableName, schema) {\n      var sql = ['SELECT', \"c.COLUMN_NAME AS 'Name',\", \"c.DATA_TYPE AS 'Type',\", \"c.CHARACTER_MAXIMUM_LENGTH AS 'Length',\", \"c.IS_NULLABLE as 'IsNull',\", \"COLUMN_DEFAULT AS 'Default',\", \"pk.CONSTRAINT_TYPE AS 'Constraint',\", \"COLUMNPROPERTY(OBJECT_ID(c.TABLE_SCHEMA+'.'+c.TABLE_NAME), c.COLUMN_NAME, 'IsIdentity') as 'IsIdentity',\", \"prop.value AS 'Comment'\", 'FROM', 'INFORMATION_SCHEMA.TABLES t', 'INNER JOIN', 'INFORMATION_SCHEMA.COLUMNS c ON t.TABLE_NAME = c.TABLE_NAME AND t.TABLE_SCHEMA = c.TABLE_SCHEMA', 'LEFT JOIN (SELECT tc.table_schema, tc.table_name, ', 'cu.column_name, tc.CONSTRAINT_TYPE ', 'FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc ', 'JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE  cu ', 'ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name ', 'and tc.constraint_name=cu.constraint_name ', 'and tc.CONSTRAINT_TYPE=\\'PRIMARY KEY\\') pk ', 'ON pk.table_schema=c.table_schema ', 'AND pk.table_name=c.table_name ', 'AND pk.column_name=c.column_name ', 'INNER JOIN sys.columns AS sc', \"ON sc.object_id = object_id(t.table_schema + '.' + t.table_name) AND sc.name = c.column_name\", 'LEFT JOIN sys.extended_properties prop ON prop.major_id = sc.object_id', 'AND prop.minor_id = sc.column_id', \"AND prop.name = 'MS_Description'\", 'WHERE t.TABLE_NAME =', wrapSingleQuote(tableName)].join(' ');\n\n      if (schema) {\n        sql += \"AND t.TABLE_SCHEMA =\".concat(wrapSingleQuote(schema));\n      }\n\n      return sql;\n    }\n  }, {\n    key: \"renameTableQuery\",\n    value: function renameTableQuery(before, after) {\n      return \"EXEC sp_rename \".concat(this.quoteTable(before), \", \").concat(this.quoteTable(after), \";\");\n    }\n  }, {\n    key: \"showTablesQuery\",\n    value: function showTablesQuery() {\n      return \"SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE';\";\n    }\n  }, {\n    key: \"dropTableQuery\",\n    value: function dropTableQuery(tableName) {\n      var qouteTbl = this.quoteTable(tableName);\n      return \"IF OBJECT_ID('\".concat(qouteTbl, \"', 'U') IS NOT NULL DROP TABLE \").concat(qouteTbl, \";\");\n    }\n  }, {\n    key: \"addColumnQuery\",\n    value: function addColumnQuery(table, key, dataType) {\n      // FIXME: attributeToSQL SHOULD be using attributes in addColumnQuery\n      //        but instead we need to pass the key along as the field here\n      dataType.field = key;\n      var commentStr = '';\n\n      if (dataType.comment && _.isString(dataType.comment)) {\n        commentStr = this.commentTemplate(dataType.comment, table, key); // attributeToSQL will try to include `COMMENT 'Comment Text'` when it returns if the comment key\n        // is present. This is needed for createTable statement where that part is extracted with regex.\n        // Here we can intercept the object and remove comment property since we have the original object.\n\n        delete dataType['comment'];\n      }\n\n      var def = this.attributeToSQL(dataType, {\n        context: 'addColumn'\n      });\n      return \"ALTER TABLE \".concat(this.quoteTable(table), \" ADD \").concat(this.quoteIdentifier(key), \" \").concat(def, \";\").concat(commentStr);\n    }\n  }, {\n    key: \"commentTemplate\",\n    value: function commentTemplate(comment, table, column) {\n      return ' EXEC sp_addextendedproperty ' + \"@name = N'MS_Description', @value = \".concat(this.escape(comment), \", \") + '@level0type = N\\'Schema\\', @level0name = \\'dbo\\', ' + \"@level1type = N'Table', @level1name = \".concat(this.quoteIdentifier(table), \", \") + \"@level2type = N'Column', @level2name = \".concat(this.quoteIdentifier(column), \";\");\n    }\n  }, {\n    key: \"removeColumnQuery\",\n    value: function removeColumnQuery(tableName, attributeName) {\n      return \"ALTER TABLE \".concat(this.quoteTable(tableName), \" DROP COLUMN \").concat(this.quoteIdentifier(attributeName), \";\");\n    }\n  }, {\n    key: \"changeColumnQuery\",\n    value: function changeColumnQuery(tableName, attributes) {\n      var attrString = [],\n          constraintString = [];\n      var commentString = '';\n\n      for (var attributeName in attributes) {\n        var quotedAttrName = this.quoteIdentifier(attributeName);\n        var definition = attributes[attributeName];\n\n        if (definition.includes('COMMENT ')) {\n          var commentMatch = definition.match(/^(.+) (COMMENT.*)$/);\n          var commentText = commentMatch[2].replace('COMMENT', '').trim();\n          commentString += this.commentTemplate(commentText, tableName, attributeName); // remove comment related substring from dataType\n\n          definition = commentMatch[1];\n        }\n\n        if (definition.includes('REFERENCES')) {\n          constraintString.push(\"FOREIGN KEY (\".concat(quotedAttrName, \") \").concat(definition.replace(/.+?(?=REFERENCES)/, '')));\n        } else {\n          attrString.push(\"\".concat(quotedAttrName, \" \").concat(definition));\n        }\n      }\n\n      var finalQuery = '';\n\n      if (attrString.length) {\n        finalQuery += \"ALTER COLUMN \".concat(attrString.join(', '));\n        finalQuery += constraintString.length ? ' ' : '';\n      }\n\n      if (constraintString.length) {\n        finalQuery += \"ADD \".concat(constraintString.join(', '));\n      }\n\n      return \"ALTER TABLE \".concat(this.quoteTable(tableName), \" \").concat(finalQuery, \";\").concat(commentString);\n    }\n  }, {\n    key: \"renameColumnQuery\",\n    value: function renameColumnQuery(tableName, attrBefore, attributes) {\n      var newName = Object.keys(attributes)[0];\n      return \"EXEC sp_rename '\".concat(this.quoteTable(tableName), \".\").concat(attrBefore, \"', '\").concat(newName, \"', 'COLUMN';\");\n    }\n  }, {\n    key: \"bulkInsertQuery\",\n    value: function bulkInsertQuery(tableName, attrValueHashes, options, attributes) {\n      var _this2 = this;\n\n      var quotedTable = this.quoteTable(tableName);\n      options = options || {};\n      attributes = attributes || {};\n      var tuples = [];\n      var allAttributes = [];\n      var allQueries = [];\n      var needIdentityInsertWrapper = false,\n          outputFragment = '';\n\n      if (options.returning) {\n        outputFragment = ' OUTPUT INSERTED.*';\n      }\n\n      var emptyQuery = \"INSERT INTO \".concat(quotedTable).concat(outputFragment, \" DEFAULT VALUES\");\n      attrValueHashes.forEach(function (attrValueHash) {\n        // special case for empty objects with primary keys\n        var fields = Object.keys(attrValueHash);\n        var firstAttr = attributes[fields[0]];\n\n        if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {\n          allQueries.push(emptyQuery);\n          return;\n        } // normal case\n\n\n        _.forOwn(attrValueHash, function (value, key) {\n          if (value !== null && attributes[key] && attributes[key].autoIncrement) {\n            needIdentityInsertWrapper = true;\n          }\n\n          if (!allAttributes.includes(key)) {\n            if (value === null && attributes[key] && attributes[key].autoIncrement) return;\n            allAttributes.push(key);\n          }\n        });\n      });\n\n      if (allAttributes.length > 0) {\n        attrValueHashes.forEach(function (attrValueHash) {\n          tuples.push(\"(\".concat(allAttributes.map(function (key) {\n            return _this2.escape(attrValueHash[key]);\n          }).join(','), \")\"));\n        });\n        var quotedAttributes = allAttributes.map(function (attr) {\n          return _this2.quoteIdentifier(attr);\n        }).join(',');\n        allQueries.push(function (tupleStr) {\n          return \"INSERT INTO \".concat(quotedTable, \" (\").concat(quotedAttributes, \")\").concat(outputFragment, \" VALUES \").concat(tupleStr, \";\");\n        });\n      }\n\n      var commands = [];\n      var offset = 0;\n      var batch = Math.floor(250 / (allAttributes.length + 1)) + 1;\n\n      var _loop = function _loop() {\n        var tupleStr = tuples.slice(offset, Math.min(tuples.length, offset + batch));\n        var generatedQuery = allQueries.map(function (v) {\n          return typeof v === 'string' ? v : v(tupleStr);\n        }).join(';');\n\n        if (needIdentityInsertWrapper) {\n          generatedQuery = \"SET IDENTITY_INSERT \".concat(quotedTable, \" ON; \").concat(generatedQuery, \"; SET IDENTITY_INSERT \").concat(quotedTable, \" OFF;\");\n        }\n\n        commands.push(generatedQuery);\n        offset += batch;\n      };\n\n      while (offset < Math.max(tuples.length, 1)) {\n        _loop();\n      }\n\n      return commands.join(';');\n    }\n  }, {\n    key: \"updateQuery\",\n    value: function updateQuery(tableName, attrValueHash, where, options, attributes) {\n      var sql = _get(_getPrototypeOf(MSSQLQueryGenerator.prototype), \"updateQuery\", this).call(this, tableName, attrValueHash, where, options, attributes);\n\n      if (options.limit) {\n        var updateArgs = \"UPDATE TOP(\".concat(this.escape(options.limit), \")\");\n        sql.query = sql.query.replace('UPDATE', updateArgs);\n      }\n\n      return sql;\n    }\n  }, {\n    key: \"upsertQuery\",\n    value: function upsertQuery(tableName, insertValues, updateValues, where, model) {\n      var _this3 = this;\n\n      var targetTableAlias = this.quoteTable(\"\".concat(tableName, \"_target\"));\n      var sourceTableAlias = this.quoteTable(\"\".concat(tableName, \"_source\"));\n      var primaryKeysAttrs = [];\n      var identityAttrs = [];\n      var uniqueAttrs = [];\n      var tableNameQuoted = this.quoteTable(tableName);\n      var needIdentityInsertWrapper = false; //Obtain primaryKeys, uniquekeys and identity attrs from rawAttributes as model is not passed\n\n      for (var key in model.rawAttributes) {\n        if (model.rawAttributes[key].primaryKey) {\n          primaryKeysAttrs.push(model.rawAttributes[key].field || key);\n        }\n\n        if (model.rawAttributes[key].unique) {\n          uniqueAttrs.push(model.rawAttributes[key].field || key);\n        }\n\n        if (model.rawAttributes[key].autoIncrement) {\n          identityAttrs.push(model.rawAttributes[key].field || key);\n        }\n      } //Add unique indexes defined by indexes option to uniqueAttrs\n\n\n      var _iterator = _createForOfIteratorHelper(model._indexes),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var index = _step.value;\n\n          if (index.unique && index.fields) {\n            var _iterator2 = _createForOfIteratorHelper(index.fields),\n                _step2;\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var field = _step2.value;\n                var fieldName = typeof field === 'string' ? field : field.name || field.attribute;\n\n                if (!uniqueAttrs.includes(fieldName) && model.rawAttributes[fieldName]) {\n                  uniqueAttrs.push(fieldName);\n                }\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var updateKeys = Object.keys(updateValues);\n      var insertKeys = Object.keys(insertValues);\n      var insertKeysQuoted = insertKeys.map(function (key) {\n        return _this3.quoteIdentifier(key);\n      }).join(', ');\n      var insertValuesEscaped = insertKeys.map(function (key) {\n        return _this3.escape(insertValues[key]);\n      }).join(', ');\n      var sourceTableQuery = \"VALUES(\".concat(insertValuesEscaped, \")\"); //Virtual Table\n\n      var joinCondition; //IDENTITY_INSERT Condition\n\n      identityAttrs.forEach(function (key) {\n        if (updateValues[key] && updateValues[key] !== null) {\n          needIdentityInsertWrapper = true;\n          /*\n           * IDENTITY_INSERT Column Cannot be updated, only inserted\n           * http://stackoverflow.com/a/30176254/2254360\n           */\n        }\n      }); //Filter NULL Clauses\n\n      var clauses = where[Op.or].filter(function (clause) {\n        var valid = true;\n        /*\n         * Exclude NULL Composite PK/UK. Partial Composite clauses should also be excluded as it doesn't guarantee a single row\n         */\n\n        for (var _key in clause) {\n          if (!clause[_key]) {\n            valid = false;\n            break;\n          }\n        }\n\n        return valid;\n      });\n      /*\n       * Generate ON condition using PK(s).\n       * If not, generate using UK(s). Else throw error\n       */\n\n      var getJoinSnippet = function getJoinSnippet(array) {\n        return array.map(function (key) {\n          key = _this3.quoteIdentifier(key);\n          return \"\".concat(targetTableAlias, \".\").concat(key, \" = \").concat(sourceTableAlias, \".\").concat(key);\n        });\n      };\n\n      if (clauses.length === 0) {\n        throw new Error('Primary Key or Unique key should be passed to upsert query');\n      } else {\n        // Search for primary key attribute in clauses -- Model can have two separate unique keys\n        for (var _key2 in clauses) {\n          var keys = Object.keys(clauses[_key2]);\n\n          if (primaryKeysAttrs.includes(keys[0])) {\n            joinCondition = getJoinSnippet(primaryKeysAttrs).join(' AND ');\n            break;\n          }\n        }\n\n        if (!joinCondition) {\n          joinCondition = getJoinSnippet(uniqueAttrs).join(' AND ');\n        }\n      } // Remove the IDENTITY_INSERT Column from update\n\n\n      var updateSnippet = updateKeys.filter(function (key) {\n        return !identityAttrs.includes(key);\n      }).map(function (key) {\n        var value = _this3.escape(updateValues[key]);\n\n        key = _this3.quoteIdentifier(key);\n        return \"\".concat(targetTableAlias, \".\").concat(key, \" = \").concat(value);\n      }).join(', ');\n      var insertSnippet = \"(\".concat(insertKeysQuoted, \") VALUES(\").concat(insertValuesEscaped, \")\");\n      var query = \"MERGE INTO \".concat(tableNameQuoted, \" WITH(HOLDLOCK) AS \").concat(targetTableAlias, \" USING (\").concat(sourceTableQuery, \") AS \").concat(sourceTableAlias, \"(\").concat(insertKeysQuoted, \") ON \").concat(joinCondition);\n      query += \" WHEN MATCHED THEN UPDATE SET \".concat(updateSnippet, \" WHEN NOT MATCHED THEN INSERT \").concat(insertSnippet, \" OUTPUT $action, INSERTED.*;\");\n\n      if (needIdentityInsertWrapper) {\n        query = \"SET IDENTITY_INSERT \".concat(tableNameQuoted, \" ON; \").concat(query, \" SET IDENTITY_INSERT \").concat(tableNameQuoted, \" OFF;\");\n      }\n\n      return query;\n    }\n  }, {\n    key: \"truncateTableQuery\",\n    value: function truncateTableQuery(tableName) {\n      return \"TRUNCATE TABLE \".concat(this.quoteTable(tableName));\n    }\n  }, {\n    key: \"deleteQuery\",\n    value: function deleteQuery(tableName, where) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var model = arguments.length > 3 ? arguments[3] : undefined;\n      var table = this.quoteTable(tableName);\n      var whereClause = this.getWhereConditions(where, null, model, options);\n      var limit = '';\n\n      if (options.limit) {\n        limit = \" TOP(\".concat(this.escape(options.limit), \")\");\n      }\n\n      if (whereClause) {\n        whereClause = \" WHERE \".concat(whereClause);\n      }\n\n      return \"DELETE\".concat(limit, \" FROM \").concat(table).concat(whereClause, \"; SELECT @@ROWCOUNT AS AFFECTEDROWS;\");\n    }\n  }, {\n    key: \"showIndexesQuery\",\n    value: function showIndexesQuery(tableName) {\n      return \"EXEC sys.sp_helpindex @objname = N'\".concat(this.quoteTable(tableName), \"';\");\n    }\n  }, {\n    key: \"showConstraintsQuery\",\n    value: function showConstraintsQuery(tableName) {\n      return \"EXEC sp_helpconstraint @objname = \".concat(this.escape(this.quoteTable(tableName)), \";\");\n    }\n  }, {\n    key: \"removeIndexQuery\",\n    value: function removeIndexQuery(tableName, indexNameOrAttributes) {\n      var indexName = indexNameOrAttributes;\n\n      if (typeof indexName !== 'string') {\n        indexName = Utils.underscore(\"\".concat(tableName, \"_\").concat(indexNameOrAttributes.join('_')));\n      }\n\n      return \"DROP INDEX \".concat(this.quoteIdentifiers(indexName), \" ON \").concat(this.quoteIdentifiers(tableName));\n    }\n  }, {\n    key: \"attributeToSQL\",\n    value: function attributeToSQL(attribute) {\n      var _this4 = this;\n\n      if (!_.isPlainObject(attribute)) {\n        attribute = {\n          type: attribute\n        };\n      } // handle self referential constraints\n\n\n      if (attribute.references) {\n        if (attribute.Model && attribute.Model.tableName === attribute.references.model) {\n          this.sequelize.log('MSSQL does not support self referencial constraints, ' + 'we will remove it but we recommend restructuring your query');\n          attribute.onDelete = '';\n          attribute.onUpdate = '';\n        }\n      }\n\n      var template;\n\n      if (attribute.type instanceof DataTypes.ENUM) {\n        if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values; // enums are a special case\n\n        template = attribute.type.toSql();\n        template += \" CHECK (\".concat(this.quoteIdentifier(attribute.field), \" IN(\").concat(attribute.values.map(function (value) {\n          return _this4.escape(value);\n        }).join(', '), \"))\");\n        return template;\n      }\n\n      template = attribute.type.toString();\n\n      if (attribute.allowNull === false) {\n        template += ' NOT NULL';\n      } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {\n        template += ' NULL';\n      }\n\n      if (attribute.autoIncrement) {\n        template += ' IDENTITY(1,1)';\n      } // Blobs/texts cannot have a defaultValue\n\n\n      if (attribute.type !== 'TEXT' && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n        template += \" DEFAULT \".concat(this.escape(attribute.defaultValue));\n      }\n\n      if (attribute.unique === true) {\n        template += ' UNIQUE';\n      }\n\n      if (attribute.primaryKey) {\n        template += ' PRIMARY KEY';\n      }\n\n      if (attribute.references) {\n        template += \" REFERENCES \".concat(this.quoteTable(attribute.references.model));\n\n        if (attribute.references.key) {\n          template += \" (\".concat(this.quoteIdentifier(attribute.references.key), \")\");\n        } else {\n          template += \" (\".concat(this.quoteIdentifier('id'), \")\");\n        }\n\n        if (attribute.onDelete) {\n          template += \" ON DELETE \".concat(attribute.onDelete.toUpperCase());\n        }\n\n        if (attribute.onUpdate) {\n          template += \" ON UPDATE \".concat(attribute.onUpdate.toUpperCase());\n        }\n      }\n\n      if (attribute.comment && typeof attribute.comment === 'string') {\n        template += \" COMMENT \".concat(attribute.comment);\n      }\n\n      return template;\n    }\n  }, {\n    key: \"attributesToSQL\",\n    value: function attributesToSQL(attributes, options) {\n      var result = {},\n          existingConstraints = [];\n      var key, attribute;\n\n      for (key in attributes) {\n        attribute = attributes[key];\n\n        if (attribute.references) {\n          if (existingConstraints.includes(attribute.references.model.toString())) {\n            // no cascading constraints to a table more than once\n            attribute.onDelete = '';\n            attribute.onUpdate = '';\n          } else {\n            existingConstraints.push(attribute.references.model.toString()); // NOTE: this really just disables cascading updates for all\n            //       definitions. Can be made more robust to support the\n            //       few cases where MSSQL actually supports them\n\n            attribute.onUpdate = '';\n          }\n        }\n\n        if (key && !attribute.field) attribute.field = key;\n        result[attribute.field || key] = this.attributeToSQL(attribute, options);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"createTrigger\",\n    value: function createTrigger() {\n      throwMethodUndefined('createTrigger');\n    }\n  }, {\n    key: \"dropTrigger\",\n    value: function dropTrigger() {\n      throwMethodUndefined('dropTrigger');\n    }\n  }, {\n    key: \"renameTrigger\",\n    value: function renameTrigger() {\n      throwMethodUndefined('renameTrigger');\n    }\n  }, {\n    key: \"createFunction\",\n    value: function createFunction() {\n      throwMethodUndefined('createFunction');\n    }\n  }, {\n    key: \"dropFunction\",\n    value: function dropFunction() {\n      throwMethodUndefined('dropFunction');\n    }\n  }, {\n    key: \"renameFunction\",\n    value: function renameFunction() {\n      throwMethodUndefined('renameFunction');\n    }\n    /**\n     * Generate common SQL prefix for ForeignKeysQuery.\n     *\n     * @param {string} catalogName\n     * @returns {string}\n     */\n\n  }, {\n    key: \"_getForeignKeysQueryPrefix\",\n    value: function _getForeignKeysQueryPrefix(catalogName) {\n      return \"\".concat('SELECT ' + 'constraint_name = OBJ.NAME, ' + 'constraintName = OBJ.NAME, ').concat(catalogName ? \"constraintCatalog = '\".concat(catalogName, \"', \") : '', \"constraintSchema = SCHEMA_NAME(OBJ.SCHEMA_ID), \") + 'tableName = TB.NAME, ' + \"tableSchema = SCHEMA_NAME(TB.SCHEMA_ID), \".concat(catalogName ? \"tableCatalog = '\".concat(catalogName, \"', \") : '', \"columnName = COL.NAME, \") + \"referencedTableSchema = SCHEMA_NAME(RTB.SCHEMA_ID), \".concat(catalogName ? \"referencedCatalog = '\".concat(catalogName, \"', \") : '', \"referencedTableName = RTB.NAME, \") + 'referencedColumnName = RCOL.NAME ' + 'FROM sys.foreign_key_columns FKC ' + 'INNER JOIN sys.objects OBJ ON OBJ.OBJECT_ID = FKC.CONSTRAINT_OBJECT_ID ' + 'INNER JOIN sys.tables TB ON TB.OBJECT_ID = FKC.PARENT_OBJECT_ID ' + 'INNER JOIN sys.columns COL ON COL.COLUMN_ID = PARENT_COLUMN_ID AND COL.OBJECT_ID = TB.OBJECT_ID ' + 'INNER JOIN sys.tables RTB ON RTB.OBJECT_ID = FKC.REFERENCED_OBJECT_ID ' + 'INNER JOIN sys.columns RCOL ON RCOL.COLUMN_ID = REFERENCED_COLUMN_ID AND RCOL.OBJECT_ID = RTB.OBJECT_ID';\n    }\n    /**\n     * Generates an SQL query that returns all foreign keys details of a table.\n     *\n     * @param {string|Object} table\n     * @param {string} catalogName database name\n     * @returns {string}\n     */\n\n  }, {\n    key: \"getForeignKeysQuery\",\n    value: function getForeignKeysQuery(table, catalogName) {\n      var tableName = table.tableName || table;\n      var sql = \"\".concat(this._getForeignKeysQueryPrefix(catalogName), \" WHERE TB.NAME =\").concat(wrapSingleQuote(tableName));\n\n      if (table.schema) {\n        sql += \" AND SCHEMA_NAME(TB.SCHEMA_ID) =\".concat(wrapSingleQuote(table.schema));\n      }\n\n      return sql;\n    }\n  }, {\n    key: \"getForeignKeyQuery\",\n    value: function getForeignKeyQuery(table, attributeName) {\n      var tableName = table.tableName || table;\n      var sql = \"\".concat(this._getForeignKeysQueryPrefix(), \" WHERE TB.NAME =\").concat(wrapSingleQuote(tableName), \" AND COL.NAME =\").concat(wrapSingleQuote(attributeName));\n\n      if (table.schema) {\n        sql += \" AND SCHEMA_NAME(TB.SCHEMA_ID) =\".concat(wrapSingleQuote(table.schema));\n      }\n\n      return sql;\n    }\n  }, {\n    key: \"getPrimaryKeyConstraintQuery\",\n    value: function getPrimaryKeyConstraintQuery(table, attributeName) {\n      var tableName = wrapSingleQuote(table.tableName || table);\n      return ['SELECT K.TABLE_NAME AS tableName,', 'K.COLUMN_NAME AS columnName,', 'K.CONSTRAINT_NAME AS constraintName', 'FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS C', 'JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS K', 'ON C.TABLE_NAME = K.TABLE_NAME', 'AND C.CONSTRAINT_CATALOG = K.CONSTRAINT_CATALOG', 'AND C.CONSTRAINT_SCHEMA = K.CONSTRAINT_SCHEMA', 'AND C.CONSTRAINT_NAME = K.CONSTRAINT_NAME', 'WHERE C.CONSTRAINT_TYPE = \\'PRIMARY KEY\\'', \"AND K.COLUMN_NAME = \".concat(wrapSingleQuote(attributeName)), \"AND K.TABLE_NAME = \".concat(tableName, \";\")].join(' ');\n    }\n  }, {\n    key: \"dropForeignKeyQuery\",\n    value: function dropForeignKeyQuery(tableName, foreignKey) {\n      return \"ALTER TABLE \".concat(this.quoteTable(tableName), \" DROP \").concat(this.quoteIdentifier(foreignKey));\n    }\n  }, {\n    key: \"getDefaultConstraintQuery\",\n    value: function getDefaultConstraintQuery(tableName, attributeName) {\n      var quotedTable = this.quoteTable(tableName);\n      return 'SELECT name FROM sys.default_constraints ' + \"WHERE PARENT_OBJECT_ID = OBJECT_ID('\".concat(quotedTable, \"', 'U') \") + \"AND PARENT_COLUMN_ID = (SELECT column_id FROM sys.columns WHERE NAME = ('\".concat(attributeName, \"') \") + \"AND object_id = OBJECT_ID('\".concat(quotedTable, \"', 'U'));\");\n    }\n  }, {\n    key: \"dropConstraintQuery\",\n    value: function dropConstraintQuery(tableName, constraintName) {\n      return \"ALTER TABLE \".concat(this.quoteTable(tableName), \" DROP CONSTRAINT \").concat(this.quoteIdentifier(constraintName), \";\");\n    }\n  }, {\n    key: \"setIsolationLevelQuery\",\n    value: function setIsolationLevelQuery() {}\n  }, {\n    key: \"generateTransactionId\",\n    value: function generateTransactionId() {\n      return randomBytes(10).toString('hex');\n    }\n  }, {\n    key: \"startTransactionQuery\",\n    value: function startTransactionQuery(transaction) {\n      if (transaction.parent) {\n        return \"SAVE TRANSACTION \".concat(this.quoteIdentifier(transaction.name), \";\");\n      }\n\n      return 'BEGIN TRANSACTION;';\n    }\n  }, {\n    key: \"commitTransactionQuery\",\n    value: function commitTransactionQuery(transaction) {\n      if (transaction.parent) {\n        return;\n      }\n\n      return 'COMMIT TRANSACTION;';\n    }\n  }, {\n    key: \"rollbackTransactionQuery\",\n    value: function rollbackTransactionQuery(transaction) {\n      if (transaction.parent) {\n        return \"ROLLBACK TRANSACTION \".concat(this.quoteIdentifier(transaction.name), \";\");\n      }\n\n      return 'ROLLBACK TRANSACTION;';\n    }\n  }, {\n    key: \"selectFromTableFragment\",\n    value: function selectFromTableFragment(options, model, attributes, tables, mainTableAs, where) {\n      var topFragment = '';\n      var mainFragment = \"SELECT \".concat(attributes.join(', '), \" FROM \").concat(tables); // Handle SQL Server 2008 with TOP instead of LIMIT\n\n      if (semver.valid(this.sequelize.options.databaseVersion) && semver.lt(this.sequelize.options.databaseVersion, '11.0.0')) {\n        if (options.limit) {\n          topFragment = \"TOP \".concat(options.limit, \" \");\n        }\n\n        if (options.offset) {\n          var offset = options.offset || 0,\n              isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n          var orders = {\n            mainQueryOrder: []\n          };\n\n          if (options.order) {\n            orders = this.getQueryOrders(options, model, isSubQuery);\n          }\n\n          if (!orders.mainQueryOrder.length) {\n            orders.mainQueryOrder.push(this.quoteIdentifier(model.primaryKeyField));\n          }\n\n          var tmpTable = mainTableAs ? mainTableAs : 'OffsetTable';\n          var whereFragment = where ? \" WHERE \".concat(where) : '';\n          /*\n           * For earlier versions of SQL server, we need to nest several queries\n           * in order to emulate the OFFSET behavior.\n           *\n           * 1. The outermost query selects all items from the inner query block.\n           *    This is due to a limitation in SQL server with the use of computed\n           *    columns (e.g. SELECT ROW_NUMBER()...AS x) in WHERE clauses.\n           * 2. The next query handles the LIMIT and OFFSET behavior by getting\n           *    the TOP N rows of the query where the row number is > OFFSET\n           * 3. The innermost query is the actual set we want information from\n           */\n\n          var fragment = \"SELECT TOP 100 PERCENT \".concat(attributes.join(', '), \" FROM \") + \"(SELECT \".concat(topFragment, \"*\") + \" FROM (SELECT ROW_NUMBER() OVER (ORDER BY \".concat(orders.mainQueryOrder.join(', '), \") as row_num, * \") + \" FROM \".concat(tables, \" AS \").concat(tmpTable).concat(whereFragment, \")\") + \" AS \".concat(tmpTable, \" WHERE row_num > \").concat(offset, \")\") + \" AS \".concat(tmpTable);\n          return fragment;\n        }\n\n        mainFragment = \"SELECT \".concat(topFragment).concat(attributes.join(', '), \" FROM \").concat(tables);\n      }\n\n      if (mainTableAs) {\n        mainFragment += \" AS \".concat(mainTableAs);\n      }\n\n      if (options.tableHint && TableHints[options.tableHint]) {\n        mainFragment += \" WITH (\".concat(TableHints[options.tableHint], \")\");\n      }\n\n      return mainFragment;\n    }\n  }, {\n    key: \"addLimitAndOffset\",\n    value: function addLimitAndOffset(options, model) {\n      // Skip handling of limit and offset as postfixes for older SQL Server versions\n      if (semver.valid(this.sequelize.options.databaseVersion) && semver.lt(this.sequelize.options.databaseVersion, '11.0.0')) {\n        return '';\n      }\n\n      var offset = options.offset || 0;\n      var isSubQuery = options.subQuery === undefined ? options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation : options.subQuery;\n      var fragment = '';\n      var orders = {};\n\n      if (options.order) {\n        orders = this.getQueryOrders(options, model, isSubQuery);\n      }\n\n      if (options.limit || options.offset) {\n        if (!options.order || options.include && !orders.subQueryOrder.length) {\n          fragment += options.order && !isSubQuery ? ', ' : ' ORDER BY ';\n          fragment += \"\".concat(this.quoteTable(options.tableAs || model.name), \".\").concat(this.quoteIdentifier(model.primaryKeyField));\n        }\n\n        if (options.offset || options.limit) {\n          fragment += \" OFFSET \".concat(this.escape(offset), \" ROWS\");\n        }\n\n        if (options.limit) {\n          fragment += \" FETCH NEXT \".concat(this.escape(options.limit), \" ROWS ONLY\");\n        }\n      }\n\n      return fragment;\n    }\n  }, {\n    key: \"booleanValue\",\n    value: function booleanValue(value) {\n      return value ? 1 : 0;\n    }\n  }]);\n\n  return MSSQLQueryGenerator;\n}(AbstractQueryGenerator); // private methods\n\n\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(Utils.removeTicks(identifier, \"'\"), \"'\");\n}\n\nmodule.exports = MSSQLQueryGenerator;","map":null,"metadata":{},"sourceType":"script"}