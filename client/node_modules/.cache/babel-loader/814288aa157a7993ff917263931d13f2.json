{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar AbstractQuery = require('../abstract/query');\n\nvar QueryTypes = require('../../query-types');\n\nvar Promise = require('../../promise');\n\nvar sequelizeErrors = require('../../errors');\n\nvar _ = require('lodash');\n\nvar _require = require('../../utils/logger'),\n    logger = _require.logger;\n\nvar debug = logger.debugContext('sql:pg');\n\nvar Query = /*#__PURE__*/function (_AbstractQuery) {\n  _inherits(Query, _AbstractQuery);\n\n  function Query() {\n    _classCallCheck(this, Query);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Query).apply(this, arguments));\n  }\n\n  _createClass(Query, [{\n    key: \"run\",\n    value: function run(sql, parameters) {\n      var _this = this;\n\n      var connection = this.connection;\n\n      if (!_.isEmpty(this.options.searchPath)) {\n        sql = this.sequelize.getQueryInterface().QueryGenerator.setSearchPath(this.options.searchPath) + sql;\n      }\n\n      this.sql = sql;\n      var query = parameters && parameters.length ? new Promise(function (resolve, reject) {\n        return connection.query(sql, parameters, function (error, result) {\n          return error ? reject(error) : resolve(result);\n        });\n      }) : new Promise(function (resolve, reject) {\n        return connection.query(sql, function (error, result) {\n          return error ? reject(error) : resolve(result);\n        });\n      });\n\n      var complete = this._logQuery(sql, debug, parameters);\n\n      return query.catch(function (err) {\n        // set the client so that it will be reaped if the connection resets while executing\n        if (err.code === 'ECONNRESET') {\n          connection._invalid = true;\n        }\n\n        err.sql = sql;\n        err.parameters = parameters;\n        throw _this.formatError(err);\n      }).then(function (queryResult) {\n        complete();\n        var rows = Array.isArray(queryResult) ? queryResult.reduce(function (allRows, r) {\n          return allRows.concat(r.rows || []);\n        }, []) : queryResult.rows;\n        var rowCount = Array.isArray(queryResult) ? queryResult.reduce(function (count, r) {\n          return Number.isFinite(r.rowCount) ? count + r.rowCount : count;\n        }, 0) : queryResult.rowCount;\n\n        if (_this.sequelize.options.minifyAliases && _this.options.aliasesMapping) {\n          rows = rows.map(function (row) {\n            return _.toPairs(row).reduce(function (acc, _ref) {\n              var _ref2 = _slicedToArray(_ref, 2),\n                  key = _ref2[0],\n                  value = _ref2[1];\n\n              var mapping = _this.options.aliasesMapping.get(key);\n\n              acc[mapping || key] = value;\n              return acc;\n            }, {});\n          });\n        }\n\n        var isTableNameQuery = sql.startsWith('SELECT table_name FROM information_schema.tables');\n        var isRelNameQuery = sql.startsWith('SELECT relname FROM pg_class WHERE oid IN');\n\n        if (isRelNameQuery) {\n          return rows.map(function (row) {\n            return {\n              name: row.relname,\n              tableName: row.relname.split('_')[0]\n            };\n          });\n        }\n\n        if (isTableNameQuery) {\n          return rows.map(function (row) {\n            return _.values(row);\n          });\n        }\n\n        if (rows[0] && rows[0].sequelize_caught_exception !== undefined) {\n          if (rows[0].sequelize_caught_exception !== null) {\n            throw _this.formatError({\n              code: '23505',\n              detail: rows[0].sequelize_caught_exception\n            });\n          }\n\n          var _iterator = _createForOfIteratorHelper(rows),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var row = _step.value;\n              delete row.sequelize_caught_exception;\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n\n        if (_this.isShowIndexesQuery()) {\n          var _iterator2 = _createForOfIteratorHelper(rows),\n              _step2;\n\n          try {\n            var _loop = function _loop() {\n              var row = _step2.value;\n              var attributes = /ON .*? (?:USING .*?\\s)?\\(([^]*)\\)/gi.exec(row.definition)[1].split(','); // Map column index in table to column name\n\n              var columns = _.zipObject(row.column_indexes, _this.sequelize.getQueryInterface().QueryGenerator.fromArray(row.column_names));\n\n              delete row.column_indexes;\n              delete row.column_names;\n              var field = void 0;\n              var attribute = void 0; // Indkey is the order of attributes in the index, specified by a string of attribute indexes\n\n              row.fields = row.indkey.split(' ').map(function (indKey, index) {\n                field = columns[indKey]; // for functional indices indKey = 0\n\n                if (!field) {\n                  return null;\n                }\n\n                attribute = attributes[index];\n                return {\n                  attribute: field,\n                  collate: attribute.match(/COLLATE \"(.*?)\"/) ? /COLLATE \"(.*?)\"/.exec(attribute)[1] : undefined,\n                  order: attribute.includes('DESC') ? 'DESC' : attribute.includes('ASC') ? 'ASC' : undefined,\n                  length: undefined\n                };\n              }).filter(function (n) {\n                return n !== null;\n              });\n              delete row.columns;\n            };\n\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              _loop();\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n\n          return rows;\n        }\n\n        if (_this.isForeignKeysQuery()) {\n          var result = [];\n\n          var _iterator3 = _createForOfIteratorHelper(rows),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _row = _step3.value;\n              var defParts = void 0;\n\n              if (_row.condef !== undefined && (defParts = _row.condef.match(/FOREIGN KEY \\((.+)\\) REFERENCES (.+)\\((.+)\\)( ON (UPDATE|DELETE) (CASCADE|RESTRICT))?( ON (UPDATE|DELETE) (CASCADE|RESTRICT))?/))) {\n                _row.id = _row.constraint_name;\n                _row.table = defParts[2];\n                _row.from = defParts[1];\n                _row.to = defParts[3];\n                var i = void 0;\n\n                for (i = 5; i <= 8; i += 3) {\n                  if (/(UPDATE|DELETE)/.test(defParts[i])) {\n                    _row[\"on_\".concat(defParts[i].toLowerCase())] = defParts[i + 1];\n                  }\n                }\n              }\n\n              result.push(_row);\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n\n          return result;\n        }\n\n        if (_this.isSelectQuery()) {\n          var _result = rows; // Postgres will treat tables as case-insensitive, so fix the case\n          // of the returned values to match attributes\n\n          if (_this.options.raw === false && _this.sequelize.options.quoteIdentifiers === false) {\n            var attrsMap = _.reduce(_this.model.rawAttributes, function (m, v, k) {\n              m[k.toLowerCase()] = k;\n              return m;\n            }, {});\n\n            _result = rows.map(function (row) {\n              return _.mapKeys(row, function (value, key) {\n                var targetAttr = attrsMap[key];\n\n                if (typeof targetAttr === 'string' && targetAttr !== key) {\n                  return targetAttr;\n                }\n\n                return key;\n              });\n            });\n          }\n\n          return _this.handleSelectQuery(_result);\n        }\n\n        if (QueryTypes.DESCRIBE === _this.options.type) {\n          var _result2 = {};\n\n          var _iterator4 = _createForOfIteratorHelper(rows),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _row2 = _step4.value;\n              _result2[_row2.Field] = {\n                type: _row2.Type.toUpperCase(),\n                allowNull: _row2.Null === 'YES',\n                defaultValue: _row2.Default,\n                comment: _row2.Comment,\n                special: _row2.special ? _this.sequelize.getQueryInterface().QueryGenerator.fromArray(_row2.special) : [],\n                primaryKey: _row2.Constraint === 'PRIMARY KEY'\n              };\n\n              if (_result2[_row2.Field].type === 'BOOLEAN') {\n                _result2[_row2.Field].defaultValue = {\n                  'false': false,\n                  'true': true\n                }[_result2[_row2.Field].defaultValue];\n\n                if (_result2[_row2.Field].defaultValue === undefined) {\n                  _result2[_row2.Field].defaultValue = null;\n                }\n              }\n\n              if (typeof _result2[_row2.Field].defaultValue === 'string') {\n                _result2[_row2.Field].defaultValue = _result2[_row2.Field].defaultValue.replace(/'/g, '');\n\n                if (_result2[_row2.Field].defaultValue.includes('::')) {\n                  var split = _result2[_row2.Field].defaultValue.split('::');\n\n                  if (split[1].toLowerCase() !== 'regclass)') {\n                    _result2[_row2.Field].defaultValue = split[0];\n                  }\n                }\n              }\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n\n          return _result2;\n        }\n\n        if (_this.isVersionQuery()) {\n          return rows[0].server_version;\n        }\n\n        if (_this.isShowOrDescribeQuery()) {\n          return rows;\n        }\n\n        if (QueryTypes.BULKUPDATE === _this.options.type) {\n          if (!_this.options.returning) {\n            return parseInt(rowCount, 10);\n          }\n\n          return _this.handleSelectQuery(rows);\n        }\n\n        if (QueryTypes.BULKDELETE === _this.options.type) {\n          return parseInt(rowCount, 10);\n        }\n\n        if (_this.isUpsertQuery()) {\n          return rows[0];\n        }\n\n        if (_this.isInsertQuery() || _this.isUpdateQuery()) {\n          if (_this.instance && _this.instance.dataValues) {\n            var _loop2 = function _loop2(key) {\n              if (Object.prototype.hasOwnProperty.call(rows[0], key)) {\n                var record = rows[0][key];\n\n                var attr = _.find(_this.model.rawAttributes, function (attribute) {\n                  return attribute.fieldName === key || attribute.field === key;\n                });\n\n                _this.instance.dataValues[attr && attr.fieldName || key] = record;\n              }\n            };\n\n            for (var key in rows[0]) {\n              _loop2(key);\n            }\n          }\n\n          return [_this.instance || rows && (_this.options.plain && rows[0] || rows) || undefined, rowCount];\n        }\n\n        if (_this.isRawQuery()) {\n          return [rows, queryResult];\n        }\n\n        return rows;\n      });\n    }\n  }, {\n    key: \"formatError\",\n    value: function formatError(err) {\n      var _this2 = this;\n\n      var match;\n      var table;\n      var index;\n      var fields;\n      var errors;\n      var message;\n      var code = err.code || err.sqlState;\n      var errMessage = err.message || err.messagePrimary;\n      var errDetail = err.detail || err.messageDetail;\n\n      switch (code) {\n        case '23503':\n          index = errMessage.match(/violates foreign key constraint \"(.+?)\"/);\n          index = index ? index[1] : undefined;\n          table = errMessage.match(/on table \"(.+?)\"/);\n          table = table ? table[1] : undefined;\n          return new sequelizeErrors.ForeignKeyConstraintError({\n            message: errMessage,\n            fields: null,\n            index: index,\n            table: table,\n            parent: err\n          });\n\n        case '23505':\n          // there are multiple different formats of error messages for this error code\n          // this regex should check at least two\n          if (errDetail && (match = errDetail.replace(/\"/g, '').match(/Key \\((.*?)\\)=\\((.*?)\\)/))) {\n            fields = _.zipObject(match[1].split(', '), match[2].split(', '));\n            errors = [];\n            message = 'Validation error';\n\n            _.forOwn(fields, function (value, field) {\n              errors.push(new sequelizeErrors.ValidationErrorItem(_this2.getUniqueConstraintErrorMessage(field), 'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,\n              field, value, _this2.instance, 'not_unique'));\n            });\n\n            if (this.model && this.model.uniqueKeys) {\n              _.forOwn(this.model.uniqueKeys, function (constraint) {\n                if (_.isEqual(constraint.fields, Object.keys(fields)) && !!constraint.msg) {\n                  message = constraint.msg;\n                  return false;\n                }\n              });\n            }\n\n            return new sequelizeErrors.UniqueConstraintError({\n              message: message,\n              errors: errors,\n              parent: err,\n              fields: fields\n            });\n          }\n\n          return new sequelizeErrors.UniqueConstraintError({\n            message: errMessage,\n            parent: err\n          });\n\n        case '23P01':\n          match = errDetail.match(/Key \\((.*?)\\)=\\((.*?)\\)/);\n\n          if (match) {\n            fields = _.zipObject(match[1].split(', '), match[2].split(', '));\n          }\n\n          message = 'Exclusion constraint error';\n          return new sequelizeErrors.ExclusionConstraintError({\n            message: message,\n            constraint: err.constraint,\n            fields: fields,\n            table: err.table,\n            parent: err\n          });\n\n        case '42704':\n          if (err.sql && /(CONSTRAINT|INDEX)/gi.test(err.sql)) {\n            message = 'Unknown constraint error';\n            index = errMessage.match(/(?:constraint|index) \"(.+?)\"/i);\n            index = index ? index[1] : undefined;\n            table = errMessage.match(/relation \"(.+?)\"/i);\n            table = table ? table[1] : undefined;\n            throw new sequelizeErrors.UnknownConstraintError({\n              message: message,\n              constraint: index,\n              fields: fields,\n              table: table,\n              parent: err\n            });\n          }\n\n        // falls through\n\n        default:\n          return new sequelizeErrors.DatabaseError(err);\n      }\n    }\n  }, {\n    key: \"isForeignKeysQuery\",\n    value: function isForeignKeysQuery() {\n      return /SELECT conname as constraint_name, pg_catalog\\.pg_get_constraintdef\\(r\\.oid, true\\) as condef FROM pg_catalog\\.pg_constraint r WHERE r\\.conrelid = \\(SELECT oid FROM pg_class WHERE relname = '.*' LIMIT 1\\) AND r\\.contype = 'f' ORDER BY 1;/.test(this.sql);\n    }\n  }, {\n    key: \"getInsertIdField\",\n    value: function getInsertIdField() {\n      return 'id';\n    }\n  }], [{\n    key: \"formatBindParameters\",\n\n    /**\n     * Rewrite query with parameters.\n     *\n     * @param {string} sql\n     * @param {Array|Object} values\n     * @param {string} dialect\n     * @private\n     */\n    value: function formatBindParameters(sql, values, dialect) {\n      var stringReplaceFunc = function stringReplaceFunc(value) {\n        return typeof value === 'string' ? value.replace(/\\0/g, '\\\\0') : value;\n      };\n\n      var bindParam;\n\n      if (Array.isArray(values)) {\n        bindParam = values.map(stringReplaceFunc);\n        sql = AbstractQuery.formatBindParameters(sql, values, dialect, {\n          skipValueReplace: true\n        })[0];\n      } else {\n        bindParam = [];\n        var i = 0;\n        var seen = {};\n\n        var replacementFunc = function replacementFunc(match, key, values) {\n          if (seen[key] !== undefined) {\n            return seen[key];\n          }\n\n          if (values[key] !== undefined) {\n            i = i + 1;\n            bindParam.push(stringReplaceFunc(values[key]));\n            seen[key] = \"$\".concat(i);\n            return \"$\".concat(i);\n          }\n\n          return undefined;\n        };\n\n        sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n      }\n\n      return [sql, bindParam];\n    }\n  }]);\n\n  return Query;\n}(AbstractQuery);\n\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;","map":null,"metadata":{},"sourceType":"script"}