{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _possibleConstructorReturn = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar util = require('util');\n\nvar _ = require('lodash');\n\nvar wkx = require('wkx');\n\nvar sequelizeErrors = require('./errors');\n\nvar Validator = require('./utils/validator-extras').validator;\n\nvar momentTz = require('moment-timezone');\n\nvar moment = require('moment');\n\nvar _require = require('./utils/logger'),\n    logger = _require.logger;\n\nvar warnings = {};\n\nvar _require2 = require('./utils/classToInvokable'),\n    classToInvokable = _require2.classToInvokable;\n\nvar ABSTRACT = /*#__PURE__*/function () {\n  function ABSTRACT() {\n    _classCallCheck(this, ABSTRACT);\n  }\n\n  _createClass(ABSTRACT, [{\n    key: \"toString\",\n    value: function toString(options) {\n      return this.toSql(options);\n    }\n  }, {\n    key: \"toSql\",\n    value: function toSql() {\n      return this.key;\n    }\n  }, {\n    key: \"stringify\",\n    value: function stringify(value, options) {\n      if (this._stringify) {\n        return this._stringify(value, options);\n      }\n\n      return value;\n    }\n  }, {\n    key: \"bindParam\",\n    value: function bindParam(value, options) {\n      if (this._bindParam) {\n        return this._bindParam(value, options);\n      }\n\n      return options.bindParam(this.stringify(value, options));\n    }\n  }], [{\n    key: \"toString\",\n    value: function toString() {\n      return this.name;\n    }\n  }, {\n    key: \"warn\",\n    value: function warn(link, text) {\n      if (!warnings[text]) {\n        warnings[text] = true;\n        logger.warn(\"\".concat(text, \" \\n>> Check: \").concat(link));\n      }\n    }\n  }, {\n    key: \"extend\",\n    value: function extend(oldType) {\n      return new this(oldType.options);\n    }\n  }]);\n\n  return ABSTRACT;\n}();\n\nABSTRACT.prototype.dialectTypes = '';\n/**\n * STRING A variable length string\n */\n\nvar STRING = /*#__PURE__*/function (_ABSTRACT) {\n  _inherits(STRING, _ABSTRACT);\n\n  /**\n   * @param {number} [length=255] length of string\n   * @param {boolean} [binary=false] Is this binary?\n   */\n  function STRING(length, binary) {\n    var _this;\n\n    _classCallCheck(this, STRING);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(STRING).call(this));\n    var options = typeof length === 'object' && length || {\n      length: length,\n      binary: binary\n    };\n    _this.options = options;\n    _this._binary = options.binary;\n    _this._length = options.length || 255;\n    return _this;\n  }\n\n  _createClass(STRING, [{\n    key: \"toSql\",\n    value: function toSql() {\n      return \"VARCHAR(\".concat(this._length, \")\").concat(this._binary ? ' BINARY' : '');\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(value) {\n      if (Object.prototype.toString.call(value) !== '[object String]') {\n        if (this.options.binary && Buffer.isBuffer(value) || typeof value === 'number') {\n          return true;\n        }\n\n        throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));\n      }\n\n      return true;\n    }\n  }, {\n    key: \"BINARY\",\n    get: function get() {\n      this._binary = true;\n      this.options.binary = true;\n      return this;\n    }\n  }], [{\n    key: \"BINARY\",\n    get: function get() {\n      return new this().BINARY;\n    }\n  }]);\n\n  return STRING;\n}(ABSTRACT);\n/**\n * CHAR A fixed length string\n */\n\n\nvar CHAR = /*#__PURE__*/function (_STRING) {\n  _inherits(CHAR, _STRING);\n\n  /**\n   * @param {number} [length=255] length of string\n   * @param {boolean} [binary=false] Is this binary?\n   */\n  function CHAR(length, binary) {\n    _classCallCheck(this, CHAR);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(CHAR).call(this, typeof length === 'object' && length || {\n      length: length,\n      binary: binary\n    }));\n  }\n\n  _createClass(CHAR, [{\n    key: \"toSql\",\n    value: function toSql() {\n      return \"CHAR(\".concat(this._length, \")\").concat(this._binary ? ' BINARY' : '');\n    }\n  }]);\n\n  return CHAR;\n}(STRING);\n/**\n * Unlimited length TEXT column\n */\n\n\nvar TEXT = /*#__PURE__*/function (_ABSTRACT2) {\n  _inherits(TEXT, _ABSTRACT2);\n\n  /**\n   * @param {string} [length=''] could be tiny, medium, long.\n   */\n  function TEXT(length) {\n    var _this2;\n\n    _classCallCheck(this, TEXT);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(TEXT).call(this));\n    var options = typeof length === 'object' && length || {\n      length: length\n    };\n    _this2.options = options;\n    _this2._length = options.length || '';\n    return _this2;\n  }\n\n  _createClass(TEXT, [{\n    key: \"toSql\",\n    value: function toSql() {\n      switch (this._length.toLowerCase()) {\n        case 'tiny':\n          return 'TINYTEXT';\n\n        case 'medium':\n          return 'MEDIUMTEXT';\n\n        case 'long':\n          return 'LONGTEXT';\n\n        default:\n          return this.key;\n      }\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(value) {\n      if (typeof value !== 'string') {\n        throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));\n      }\n\n      return true;\n    }\n  }]);\n\n  return TEXT;\n}(ABSTRACT);\n/**\n * An unlimited length case-insensitive text column.\n * Original case is preserved but acts case-insensitive when comparing values (such as when finding or unique constraints).\n * Only available in Postgres and SQLite.\n *\n */\n\n\nvar CITEXT = /*#__PURE__*/function (_ABSTRACT3) {\n  _inherits(CITEXT, _ABSTRACT3);\n\n  function CITEXT() {\n    _classCallCheck(this, CITEXT);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(CITEXT).apply(this, arguments));\n  }\n\n  _createClass(CITEXT, [{\n    key: \"toSql\",\n    value: function toSql() {\n      return 'CITEXT';\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(value) {\n      if (typeof value !== 'string') {\n        throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));\n      }\n\n      return true;\n    }\n  }]);\n\n  return CITEXT;\n}(ABSTRACT);\n/**\n * Base number type which is used to build other types\n */\n\n\nvar NUMBER = /*#__PURE__*/function (_ABSTRACT4) {\n  _inherits(NUMBER, _ABSTRACT4);\n\n  /**\n   * @param {Object} options type options\n   * @param {string|number} [options.length] length of type, like `INT(4)`\n   * @param {boolean} [options.zerofill] Is zero filled?\n   * @param {boolean} [options.unsigned] Is unsigned?\n   * @param {string|number} [options.decimals] number of decimal points, used with length `FLOAT(5, 4)`\n   * @param {string|number} [options.precision] defines precision for decimal type\n   * @param {string|number} [options.scale] defines scale for decimal type\n   */\n  function NUMBER() {\n    var _this3;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, NUMBER);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(NUMBER).call(this));\n\n    if (typeof options === 'number') {\n      options = {\n        length: options\n      };\n    }\n\n    _this3.options = options;\n    _this3._length = options.length;\n    _this3._zerofill = options.zerofill;\n    _this3._decimals = options.decimals;\n    _this3._precision = options.precision;\n    _this3._scale = options.scale;\n    _this3._unsigned = options.unsigned;\n    return _this3;\n  }\n\n  _createClass(NUMBER, [{\n    key: \"toSql\",\n    value: function toSql() {\n      var result = this.key;\n\n      if (this._length) {\n        result += \"(\".concat(this._length);\n\n        if (typeof this._decimals === 'number') {\n          result += \",\".concat(this._decimals);\n        }\n\n        result += ')';\n      }\n\n      if (this._unsigned) {\n        result += ' UNSIGNED';\n      }\n\n      if (this._zerofill) {\n        result += ' ZEROFILL';\n      }\n\n      return result;\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(value) {\n      if (!Validator.isFloat(String(value))) {\n        throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid \".concat(this.key.toLowerCase()), value));\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_stringify\",\n    value: function _stringify(number) {\n      if (typeof number === 'number' || typeof number === 'boolean' || number === null || number === undefined) {\n        return number;\n      }\n\n      if (typeof number.toString === 'function') {\n        return number.toString();\n      }\n\n      return number;\n    }\n  }, {\n    key: \"UNSIGNED\",\n    get: function get() {\n      this._unsigned = true;\n      this.options.unsigned = true;\n      return this;\n    }\n  }, {\n    key: \"ZEROFILL\",\n    get: function get() {\n      this._zerofill = true;\n      this.options.zerofill = true;\n      return this;\n    }\n  }], [{\n    key: \"UNSIGNED\",\n    get: function get() {\n      return new this().UNSIGNED;\n    }\n  }, {\n    key: \"ZEROFILL\",\n    get: function get() {\n      return new this().ZEROFILL;\n    }\n  }]);\n\n  return NUMBER;\n}(ABSTRACT);\n/**\n * A 32 bit integer\n */\n\n\nvar INTEGER = /*#__PURE__*/function (_NUMBER) {\n  _inherits(INTEGER, _NUMBER);\n\n  function INTEGER() {\n    _classCallCheck(this, INTEGER);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(INTEGER).apply(this, arguments));\n  }\n\n  _createClass(INTEGER, [{\n    key: \"validate\",\n    value: function validate(value) {\n      if (!Validator.isInt(String(value))) {\n        throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid \".concat(this.key.toLowerCase()), value));\n      }\n\n      return true;\n    }\n  }]);\n\n  return INTEGER;\n}(NUMBER);\n/**\n * A 8 bit integer\n */\n\n\nvar TINYINT = /*#__PURE__*/function (_INTEGER) {\n  _inherits(TINYINT, _INTEGER);\n\n  function TINYINT() {\n    _classCallCheck(this, TINYINT);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(TINYINT).apply(this, arguments));\n  }\n\n  return TINYINT;\n}(INTEGER);\n/**\n * A 16 bit integer\n */\n\n\nvar SMALLINT = /*#__PURE__*/function (_INTEGER2) {\n  _inherits(SMALLINT, _INTEGER2);\n\n  function SMALLINT() {\n    _classCallCheck(this, SMALLINT);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(SMALLINT).apply(this, arguments));\n  }\n\n  return SMALLINT;\n}(INTEGER);\n/**\n * A 24 bit integer\n */\n\n\nvar MEDIUMINT = /*#__PURE__*/function (_INTEGER3) {\n  _inherits(MEDIUMINT, _INTEGER3);\n\n  function MEDIUMINT() {\n    _classCallCheck(this, MEDIUMINT);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MEDIUMINT).apply(this, arguments));\n  }\n\n  return MEDIUMINT;\n}(INTEGER);\n/**\n * A 64 bit integer\n */\n\n\nvar BIGINT = /*#__PURE__*/function (_INTEGER4) {\n  _inherits(BIGINT, _INTEGER4);\n\n  function BIGINT() {\n    _classCallCheck(this, BIGINT);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(BIGINT).apply(this, arguments));\n  }\n\n  return BIGINT;\n}(INTEGER);\n/**\n * Floating point number (4-byte precision).\n */\n\n\nvar FLOAT = /*#__PURE__*/function (_NUMBER2) {\n  _inherits(FLOAT, _NUMBER2);\n\n  /**\n   * @param {string|number} [length] length of type, like `FLOAT(4)`\n   * @param {string|number} [decimals] number of decimal points, used with length `FLOAT(5, 4)`\n   */\n  function FLOAT(length, decimals) {\n    _classCallCheck(this, FLOAT);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(FLOAT).call(this, typeof length === 'object' && length || {\n      length: length,\n      decimals: decimals\n    }));\n  }\n\n  _createClass(FLOAT, [{\n    key: \"validate\",\n    value: function validate(value) {\n      if (!Validator.isFloat(String(value))) {\n        throw new sequelizeErrors.ValidationError(util.format('%j is not a valid float', value));\n      }\n\n      return true;\n    }\n  }]);\n\n  return FLOAT;\n}(NUMBER);\n/**\n * Floating point number (4-byte precision).\n */\n\n\nvar REAL = /*#__PURE__*/function (_NUMBER3) {\n  _inherits(REAL, _NUMBER3);\n\n  /**\n   * @param {string|number} [length] length of type, like `REAL(4)`\n   * @param {string|number} [decimals] number of decimal points, used with length `REAL(5, 4)`\n   */\n  function REAL(length, decimals) {\n    _classCallCheck(this, REAL);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(REAL).call(this, typeof length === 'object' && length || {\n      length: length,\n      decimals: decimals\n    }));\n  }\n\n  return REAL;\n}(NUMBER);\n/**\n * Floating point number (8-byte precision).\n */\n\n\nvar DOUBLE = /*#__PURE__*/function (_NUMBER4) {\n  _inherits(DOUBLE, _NUMBER4);\n\n  /**\n   * @param {string|number} [length] length of type, like `DOUBLE PRECISION(25)`\n   * @param {string|number} [decimals] number of decimal points, used with length `DOUBLE PRECISION(25, 10)`\n   */\n  function DOUBLE(length, decimals) {\n    _classCallCheck(this, DOUBLE);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(DOUBLE).call(this, typeof length === 'object' && length || {\n      length: length,\n      decimals: decimals\n    }));\n  }\n\n  return DOUBLE;\n}(NUMBER);\n/**\n * Decimal type, variable precision, take length as specified by user\n */\n\n\nvar DECIMAL = /*#__PURE__*/function (_NUMBER5) {\n  _inherits(DECIMAL, _NUMBER5);\n\n  /**\n   * @param {string|number} [precision] defines precision\n   * @param {string|number} [scale] defines scale\n   */\n  function DECIMAL(precision, scale) {\n    _classCallCheck(this, DECIMAL);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(DECIMAL).call(this, typeof precision === 'object' && precision || {\n      precision: precision,\n      scale: scale\n    }));\n  }\n\n  _createClass(DECIMAL, [{\n    key: \"toSql\",\n    value: function toSql() {\n      if (this._precision || this._scale) {\n        return \"DECIMAL(\".concat([this._precision, this._scale].filter(_.identity).join(','), \")\");\n      }\n\n      return 'DECIMAL';\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(value) {\n      if (!Validator.isDecimal(String(value))) {\n        throw new sequelizeErrors.ValidationError(util.format('%j is not a valid decimal', value));\n      }\n\n      return true;\n    }\n  }]);\n\n  return DECIMAL;\n}(NUMBER); // TODO: Create intermediate class\n\n\nvar protoExtensions = {\n  escape: false,\n  _value: function _value(value) {\n    if (isNaN(value)) {\n      return 'NaN';\n    }\n\n    if (!isFinite(value)) {\n      var sign = value < 0 ? '-' : '';\n      return \"\".concat(sign, \"Infinity\");\n    }\n\n    return value;\n  },\n  _stringify: function _stringify(value) {\n    return \"'\".concat(this._value(value), \"'\");\n  },\n  _bindParam: function _bindParam(value, options) {\n    return options.bindParam(this._value(value));\n  }\n};\n\nfor (var _i = 0, _arr = [FLOAT, DOUBLE, REAL]; _i < _arr.length; _i++) {\n  var floating = _arr[_i];\n  Object.assign(floating.prototype, protoExtensions);\n}\n/**\n * A boolean / tinyint column, depending on dialect\n */\n\n\nvar BOOLEAN = /*#__PURE__*/function (_ABSTRACT5) {\n  _inherits(BOOLEAN, _ABSTRACT5);\n\n  function BOOLEAN() {\n    _classCallCheck(this, BOOLEAN);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(BOOLEAN).apply(this, arguments));\n  }\n\n  _createClass(BOOLEAN, [{\n    key: \"toSql\",\n    value: function toSql() {\n      return 'TINYINT(1)';\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(value) {\n      if (!Validator.isBoolean(String(value))) {\n        throw new sequelizeErrors.ValidationError(util.format('%j is not a valid boolean', value));\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_sanitize\",\n    value: function _sanitize(value) {\n      if (value !== null && value !== undefined) {\n        if (Buffer.isBuffer(value) && value.length === 1) {\n          // Bit fields are returned as buffers\n          value = value[0];\n        }\n\n        var type = typeof value;\n\n        if (type === 'string') {\n          // Only take action on valid boolean strings.\n          return value === 'true' ? true : value === 'false' ? false : value;\n        }\n\n        if (type === 'number') {\n          // Only take action on valid boolean integers.\n          return value === 1 ? true : value === 0 ? false : value;\n        }\n      }\n\n      return value;\n    }\n  }]);\n\n  return BOOLEAN;\n}(ABSTRACT);\n\nBOOLEAN.parse = BOOLEAN.prototype._sanitize;\n/**\n * A time column\n *\n */\n\nvar TIME = /*#__PURE__*/function (_ABSTRACT6) {\n  _inherits(TIME, _ABSTRACT6);\n\n  function TIME() {\n    _classCallCheck(this, TIME);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(TIME).apply(this, arguments));\n  }\n\n  _createClass(TIME, [{\n    key: \"toSql\",\n    value: function toSql() {\n      return 'TIME';\n    }\n  }]);\n\n  return TIME;\n}(ABSTRACT);\n/**\n * Date column with timezone, default is UTC\n */\n\n\nvar DATE = /*#__PURE__*/function (_ABSTRACT7) {\n  _inherits(DATE, _ABSTRACT7);\n\n  /**\n   * @param {string|number} [length] precision to allow storing milliseconds\n   */\n  function DATE(length) {\n    var _this4;\n\n    _classCallCheck(this, DATE);\n\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(DATE).call(this));\n    var options = typeof length === 'object' && length || {\n      length: length\n    };\n    _this4.options = options;\n    _this4._length = options.length || '';\n    return _this4;\n  }\n\n  _createClass(DATE, [{\n    key: \"toSql\",\n    value: function toSql() {\n      return 'DATETIME';\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(value) {\n      if (!Validator.isDate(String(value))) {\n        throw new sequelizeErrors.ValidationError(util.format('%j is not a valid date', value));\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_sanitize\",\n    value: function _sanitize(value, options) {\n      if ((!options || options && !options.raw) && !(value instanceof Date) && !!value) {\n        return new Date(value);\n      }\n\n      return value;\n    }\n  }, {\n    key: \"_isChanged\",\n    value: function _isChanged(value, originalValue) {\n      if (originalValue && !!value && (value === originalValue || value instanceof Date && originalValue instanceof Date && value.getTime() === originalValue.getTime())) {\n        return false;\n      } // not changed when set to same empty value\n\n\n      if (!originalValue && !value && originalValue === value) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_applyTimezone\",\n    value: function _applyTimezone(date, options) {\n      if (options.timezone) {\n        if (momentTz.tz.zone(options.timezone)) {\n          return momentTz(date).tz(options.timezone);\n        }\n\n        return date = moment(date).utcOffset(options.timezone);\n      }\n\n      return momentTz(date);\n    }\n  }, {\n    key: \"_stringify\",\n    value: function _stringify(date, options) {\n      date = this._applyTimezone(date, options); // Z here means current timezone, _not_ UTC\n\n      return date.format('YYYY-MM-DD HH:mm:ss.SSS Z');\n    }\n  }]);\n\n  return DATE;\n}(ABSTRACT);\n/**\n * A date only column (no timestamp)\n */\n\n\nvar DATEONLY = /*#__PURE__*/function (_ABSTRACT8) {\n  _inherits(DATEONLY, _ABSTRACT8);\n\n  function DATEONLY() {\n    _classCallCheck(this, DATEONLY);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(DATEONLY).apply(this, arguments));\n  }\n\n  _createClass(DATEONLY, [{\n    key: \"toSql\",\n    value: function toSql() {\n      return 'DATE';\n    }\n  }, {\n    key: \"_stringify\",\n    value: function _stringify(date) {\n      return moment(date).format('YYYY-MM-DD');\n    }\n  }, {\n    key: \"_sanitize\",\n    value: function _sanitize(value, options) {\n      if ((!options || options && !options.raw) && !!value) {\n        return moment(value).format('YYYY-MM-DD');\n      }\n\n      return value;\n    }\n  }, {\n    key: \"_isChanged\",\n    value: function _isChanged(value, originalValue) {\n      if (originalValue && !!value && originalValue === value) {\n        return false;\n      } // not changed when set to same empty value\n\n\n      if (!originalValue && !value && originalValue === value) {\n        return false;\n      }\n\n      return true;\n    }\n  }]);\n\n  return DATEONLY;\n}(ABSTRACT);\n/**\n * A key / value store column. Only available in Postgres.\n */\n\n\nvar HSTORE = /*#__PURE__*/function (_ABSTRACT9) {\n  _inherits(HSTORE, _ABSTRACT9);\n\n  function HSTORE() {\n    _classCallCheck(this, HSTORE);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(HSTORE).apply(this, arguments));\n  }\n\n  _createClass(HSTORE, [{\n    key: \"validate\",\n    value: function validate(value) {\n      if (!_.isPlainObject(value)) {\n        throw new sequelizeErrors.ValidationError(util.format('%j is not a valid hstore', value));\n      }\n\n      return true;\n    }\n  }]);\n\n  return HSTORE;\n}(ABSTRACT);\n/**\n * A JSON string column. Available in MySQL, Postgres and SQLite\n */\n\n\nvar JSONTYPE = /*#__PURE__*/function (_ABSTRACT10) {\n  _inherits(JSONTYPE, _ABSTRACT10);\n\n  function JSONTYPE() {\n    _classCallCheck(this, JSONTYPE);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(JSONTYPE).apply(this, arguments));\n  }\n\n  _createClass(JSONTYPE, [{\n    key: \"validate\",\n    value: function validate() {\n      return true;\n    }\n  }, {\n    key: \"_stringify\",\n    value: function _stringify(value) {\n      return JSON.stringify(value);\n    }\n  }]);\n\n  return JSONTYPE;\n}(ABSTRACT);\n/**\n * A binary storage JSON column. Only available in Postgres.\n */\n\n\nvar JSONB = /*#__PURE__*/function (_JSONTYPE) {\n  _inherits(JSONB, _JSONTYPE);\n\n  function JSONB() {\n    _classCallCheck(this, JSONB);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(JSONB).apply(this, arguments));\n  }\n\n  return JSONB;\n}(JSONTYPE);\n/**\n * A default value of the current timestamp\n */\n\n\nvar NOW = /*#__PURE__*/function (_ABSTRACT11) {\n  _inherits(NOW, _ABSTRACT11);\n\n  function NOW() {\n    _classCallCheck(this, NOW);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(NOW).apply(this, arguments));\n  }\n\n  return NOW;\n}(ABSTRACT);\n/**\n * Binary storage\n */\n\n\nvar BLOB = /*#__PURE__*/function (_ABSTRACT12) {\n  _inherits(BLOB, _ABSTRACT12);\n\n  /**\n   * @param {string} [length=''] could be tiny, medium, long.\n   */\n  function BLOB(length) {\n    var _this5;\n\n    _classCallCheck(this, BLOB);\n\n    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(BLOB).call(this));\n    var options = typeof length === 'object' && length || {\n      length: length\n    };\n    _this5.options = options;\n    _this5._length = options.length || '';\n    return _this5;\n  }\n\n  _createClass(BLOB, [{\n    key: \"toSql\",\n    value: function toSql() {\n      switch (this._length.toLowerCase()) {\n        case 'tiny':\n          return 'TINYBLOB';\n\n        case 'medium':\n          return 'MEDIUMBLOB';\n\n        case 'long':\n          return 'LONGBLOB';\n\n        default:\n          return this.key;\n      }\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(value) {\n      if (typeof value !== 'string' && !Buffer.isBuffer(value)) {\n        throw new sequelizeErrors.ValidationError(util.format('%j is not a valid blob', value));\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_stringify\",\n    value: function _stringify(value) {\n      if (!Buffer.isBuffer(value)) {\n        if (Array.isArray(value)) {\n          value = Buffer.from(value);\n        } else {\n          value = Buffer.from(value.toString());\n        }\n      }\n\n      var hex = value.toString('hex');\n      return this._hexify(hex);\n    }\n  }, {\n    key: \"_hexify\",\n    value: function _hexify(hex) {\n      return \"X'\".concat(hex, \"'\");\n    }\n  }, {\n    key: \"_bindParam\",\n    value: function _bindParam(value, options) {\n      if (!Buffer.isBuffer(value)) {\n        if (Array.isArray(value)) {\n          value = Buffer.from(value);\n        } else {\n          value = Buffer.from(value.toString());\n        }\n      }\n\n      return options.bindParam(value);\n    }\n  }]);\n\n  return BLOB;\n}(ABSTRACT);\n\nBLOB.prototype.escape = false;\n/**\n * Range types are data types representing a range of values of some element type (called the range's subtype).\n * Only available in Postgres. See [the Postgres documentation](http://www.postgresql.org/docs/9.4/static/rangetypes.html) for more details\n */\n\nvar RANGE = /*#__PURE__*/function (_ABSTRACT13) {\n  _inherits(RANGE, _ABSTRACT13);\n\n  /**\n   * @param {ABSTRACT} subtype A subtype for range, like RANGE(DATE)\n   */\n  function RANGE(subtype) {\n    var _this6;\n\n    _classCallCheck(this, RANGE);\n\n    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(RANGE).call(this));\n    var options = _.isPlainObject(subtype) ? subtype : {\n      subtype: subtype\n    };\n    if (!options.subtype) options.subtype = new INTEGER();\n\n    if (typeof options.subtype === 'function') {\n      options.subtype = new options.subtype();\n    }\n\n    _this6._subtype = options.subtype.key;\n    _this6.options = options;\n    return _this6;\n  }\n\n  _createClass(RANGE, [{\n    key: \"validate\",\n    value: function validate(value) {\n      if (!Array.isArray(value)) {\n        throw new sequelizeErrors.ValidationError(util.format('%j is not a valid range', value));\n      }\n\n      if (value.length !== 2) {\n        throw new sequelizeErrors.ValidationError('A range must be an array with two elements');\n      }\n\n      return true;\n    }\n  }]);\n\n  return RANGE;\n}(ABSTRACT);\n/**\n * A column storing a unique universal identifier.\n * Use with `UUIDV1` or `UUIDV4` for default values.\n */\n\n\nvar UUID = /*#__PURE__*/function (_ABSTRACT14) {\n  _inherits(UUID, _ABSTRACT14);\n\n  function UUID() {\n    _classCallCheck(this, UUID);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(UUID).apply(this, arguments));\n  }\n\n  _createClass(UUID, [{\n    key: \"validate\",\n    value: function validate(value, options) {\n      if (typeof value !== 'string' || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {\n        throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuid', value));\n      }\n\n      return true;\n    }\n  }]);\n\n  return UUID;\n}(ABSTRACT);\n/**\n * A default unique universal identifier generated following the UUID v1 standard\n */\n\n\nvar UUIDV1 = /*#__PURE__*/function (_ABSTRACT15) {\n  _inherits(UUIDV1, _ABSTRACT15);\n\n  function UUIDV1() {\n    _classCallCheck(this, UUIDV1);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(UUIDV1).apply(this, arguments));\n  }\n\n  _createClass(UUIDV1, [{\n    key: \"validate\",\n    value: function validate(value, options) {\n      if (typeof value !== 'string' || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {\n        throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuid', value));\n      }\n\n      return true;\n    }\n  }]);\n\n  return UUIDV1;\n}(ABSTRACT);\n/**\n * A default unique universal identifier generated following the UUID v4 standard\n */\n\n\nvar UUIDV4 = /*#__PURE__*/function (_ABSTRACT16) {\n  _inherits(UUIDV4, _ABSTRACT16);\n\n  function UUIDV4() {\n    _classCallCheck(this, UUIDV4);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(UUIDV4).apply(this, arguments));\n  }\n\n  _createClass(UUIDV4, [{\n    key: \"validate\",\n    value: function validate(value, options) {\n      if (typeof value !== 'string' || !Validator.isUUID(value, 4) && (!options || !options.acceptStrings)) {\n        throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuidv4', value));\n      }\n\n      return true;\n    }\n  }]);\n\n  return UUIDV4;\n}(ABSTRACT);\n/**\n * A virtual value that is not stored in the DB. This could for example be useful if you want to provide a default value in your model that is returned to the user but not stored in the DB.\n *\n * You could also use it to validate a value before permuting and storing it. VIRTUAL also takes a return type and dependency fields as arguments\n * If a virtual attribute is present in `attributes` it will automatically pull in the extra fields as well.\n * Return type is mostly useful for setups that rely on types like GraphQL.\n *\n * @example <caption>Checking password length before hashing it</caption>\n * sequelize.define('user', {\n *   password_hash: DataTypes.STRING,\n *   password: {\n *     type: DataTypes.VIRTUAL,\n *     set: function (val) {\n *        // Remember to set the data value, otherwise it won't be validated\n *        this.setDataValue('password', val);\n *        this.setDataValue('password_hash', this.salt + val);\n *      },\n *      validate: {\n *         isLongEnough: function (val) {\n *           if (val.length < 7) {\n *             throw new Error(\"Please choose a longer password\")\n *          }\n *       }\n *     }\n *   }\n * })\n *\n * # In the above code the password is stored plainly in the password field so it can be validated, but is never stored in the DB.\n *\n * @example <caption>Virtual with dependency fields</caption>\n * {\n *   active: {\n *     type: new DataTypes.VIRTUAL(DataTypes.BOOLEAN, ['createdAt']),\n *     get: function() {\n *       return this.get('createdAt') > Date.now() - (7 * 24 * 60 * 60 * 1000)\n *     }\n *   }\n * }\n *\n */\n\n\nvar VIRTUAL = /*#__PURE__*/function (_ABSTRACT17) {\n  _inherits(VIRTUAL, _ABSTRACT17);\n\n  /**\n   * @param {ABSTRACT} [ReturnType] return type for virtual type\n   * @param {Array} [fields] array of fields this virtual type is dependent on\n   */\n  function VIRTUAL(ReturnType, fields) {\n    var _this7;\n\n    _classCallCheck(this, VIRTUAL);\n\n    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(VIRTUAL).call(this));\n    if (typeof ReturnType === 'function') ReturnType = new ReturnType();\n    _this7.returnType = ReturnType;\n    _this7.fields = fields;\n    return _this7;\n  }\n\n  return VIRTUAL;\n}(ABSTRACT);\n/**\n * An enumeration, Postgres Only\n *\n * @example\n * DataTypes.ENUM('value', 'another value')\n * DataTypes.ENUM(['value', 'another value'])\n * DataTypes.ENUM({\n *   values: ['value', 'another value']\n * })\n */\n\n\nvar ENUM = /*#__PURE__*/function (_ABSTRACT18) {\n  _inherits(ENUM, _ABSTRACT18);\n\n  /**\n   * @param {...any|{ values: any[] }|any[]} args either array of values or options object with values array. It also supports variadic values\n   */\n  function ENUM() {\n    var _this8;\n\n    _classCallCheck(this, ENUM);\n\n    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(ENUM).call(this));\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var value = args[0];\n    var options = typeof value === 'object' && !Array.isArray(value) && value || {\n      values: args.reduce(function (result, element) {\n        return result.concat(Array.isArray(element) ? element : [element]);\n      }, [])\n    };\n    _this8.values = options.values;\n    _this8.options = options;\n    return _this8;\n  }\n\n  _createClass(ENUM, [{\n    key: \"validate\",\n    value: function validate(value) {\n      if (!this.values.includes(value)) {\n        throw new sequelizeErrors.ValidationError(util.format('%j is not a valid choice in %j', value, this.values));\n      }\n\n      return true;\n    }\n  }]);\n\n  return ENUM;\n}(ABSTRACT);\n/**\n * An array of `type`. Only available in Postgres.\n *\n * @example\n * DataTypes.ARRAY(DataTypes.DECIMAL)\n */\n\n\nvar ARRAY = /*#__PURE__*/function (_ABSTRACT19) {\n  _inherits(ARRAY, _ABSTRACT19);\n\n  /**\n   * @param {ABSTRACT} type type of array values\n   */\n  function ARRAY(type) {\n    var _this9;\n\n    _classCallCheck(this, ARRAY);\n\n    _this9 = _possibleConstructorReturn(this, _getPrototypeOf(ARRAY).call(this));\n    var options = _.isPlainObject(type) ? type : {\n      type: type\n    };\n    _this9.options = options;\n    _this9.type = typeof options.type === 'function' ? new options.type() : options.type;\n    return _this9;\n  }\n\n  _createClass(ARRAY, [{\n    key: \"toSql\",\n    value: function toSql() {\n      return \"\".concat(this.type.toSql(), \"[]\");\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(value) {\n      if (!Array.isArray(value)) {\n        throw new sequelizeErrors.ValidationError(util.format('%j is not a valid array', value));\n      }\n\n      return true;\n    }\n  }], [{\n    key: \"is\",\n    value: function is(obj, type) {\n      return obj instanceof ARRAY && obj.type instanceof type;\n    }\n  }]);\n\n  return ARRAY;\n}(ABSTRACT);\n/**\n * A column storing Geometry information.\n * It is only available in PostgreSQL (with PostGIS), MariaDB or MySQL.\n *\n * GeoJSON is accepted as input and returned as output.\n *\n * In PostGIS, the GeoJSON is parsed using the PostGIS function `ST_GeomFromGeoJSON`.\n * In MySQL it is parsed using the function `GeomFromText`.\n *\n * Therefore, one can just follow the [GeoJSON spec](http://geojson.org/geojson-spec.html) for handling geometry objects.  See the following examples:\n *\n * @example <caption>Defining a Geometry type attribute</caption>\n * DataTypes.GEOMETRY\n * DataTypes.GEOMETRY('POINT')\n * DataTypes.GEOMETRY('POINT', 4326)\n *\n * @example <caption>Create a new point</caption>\n * const point = { type: 'Point', coordinates: [39.807222,-76.984722]};\n *\n * User.create({username: 'username', geometry: point });\n *\n * @example <caption>Create a new linestring</caption>\n * const line = { type: 'LineString', 'coordinates': [ [100.0, 0.0], [101.0, 1.0] ] };\n *\n * User.create({username: 'username', geometry: line });\n *\n * @example <caption>Create a new polygon</caption>\n * const polygon = { type: 'Polygon', coordinates: [\n *                 [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],\n *                   [100.0, 1.0], [100.0, 0.0] ]\n *                 ]};\n *\n * User.create({username: 'username', geometry: polygon });\n *\n * @example <caption>Create a new point with a custom SRID</caption>\n * const point = {\n *   type: 'Point',\n *   coordinates: [39.807222,-76.984722],\n *   crs: { type: 'name', properties: { name: 'EPSG:4326'} }\n * };\n *\n * User.create({username: 'username', geometry: point })\n *\n *\n * @see {@link DataTypes.GEOGRAPHY}\n */\n\n\nvar GEOMETRY = /*#__PURE__*/function (_ABSTRACT20) {\n  _inherits(GEOMETRY, _ABSTRACT20);\n\n  /**\n   * @param {string} [type] Type of geometry data\n   * @param {string} [srid] SRID of type\n   */\n  function GEOMETRY(type, srid) {\n    var _this10;\n\n    _classCallCheck(this, GEOMETRY);\n\n    _this10 = _possibleConstructorReturn(this, _getPrototypeOf(GEOMETRY).call(this));\n    var options = _.isPlainObject(type) ? type : {\n      type: type,\n      srid: srid\n    };\n    _this10.options = options;\n    _this10.type = options.type;\n    _this10.srid = options.srid;\n    return _this10;\n  }\n\n  _createClass(GEOMETRY, [{\n    key: \"_stringify\",\n    value: function _stringify(value, options) {\n      return \"GeomFromText(\".concat(options.escape(wkx.Geometry.parseGeoJSON(value).toWkt()), \")\");\n    }\n  }, {\n    key: \"_bindParam\",\n    value: function _bindParam(value, options) {\n      return \"GeomFromText(\".concat(options.bindParam(wkx.Geometry.parseGeoJSON(value).toWkt()), \")\");\n    }\n  }]);\n\n  return GEOMETRY;\n}(ABSTRACT);\n\nGEOMETRY.prototype.escape = false;\n/**\n * A geography datatype represents two dimensional spacial objects in an elliptic coord system.\n *\n * __The difference from geometry and geography type:__\n *\n * PostGIS 1.5 introduced a new spatial type called geography, which uses geodetic measurement instead of Cartesian measurement.\n * Coordinate points in the geography type are always represented in WGS 84 lon lat degrees (SRID 4326),\n * but measurement functions and relationships ST_Distance, ST_DWithin, ST_Length, and ST_Area always return answers in meters or assume inputs in meters.\n *\n * __What is best to use? It depends:__\n *\n * When choosing between the geometry and geography type for data storage, you should consider what you’ll be using it for.\n * If all you do are simple measurements and relationship checks on your data, and your data covers a fairly large area, then most likely you’ll be better off storing your data using the new geography type.\n * Although the new geography data type can cover the globe, the geometry type is far from obsolete.\n * The geometry type has a much richer set of functions than geography, relationship checks are generally faster, and it has wider support currently across desktop and web-mapping tools\n *\n * @example <caption>Defining a Geography type attribute</caption>\n * DataTypes.GEOGRAPHY\n * DataTypes.GEOGRAPHY('POINT')\n * DataTypes.GEOGRAPHY('POINT', 4326)\n */\n\nvar GEOGRAPHY = /*#__PURE__*/function (_ABSTRACT21) {\n  _inherits(GEOGRAPHY, _ABSTRACT21);\n\n  /**\n   * @param {string} [type] Type of geography data\n   * @param {string} [srid] SRID of type\n   */\n  function GEOGRAPHY(type, srid) {\n    var _this11;\n\n    _classCallCheck(this, GEOGRAPHY);\n\n    _this11 = _possibleConstructorReturn(this, _getPrototypeOf(GEOGRAPHY).call(this));\n    var options = _.isPlainObject(type) ? type : {\n      type: type,\n      srid: srid\n    };\n    _this11.options = options;\n    _this11.type = options.type;\n    _this11.srid = options.srid;\n    return _this11;\n  }\n\n  _createClass(GEOGRAPHY, [{\n    key: \"_stringify\",\n    value: function _stringify(value, options) {\n      return \"GeomFromText(\".concat(options.escape(wkx.Geometry.parseGeoJSON(value).toWkt()), \")\");\n    }\n  }, {\n    key: \"_bindParam\",\n    value: function _bindParam(value, options) {\n      return \"GeomFromText(\".concat(options.bindParam(wkx.Geometry.parseGeoJSON(value).toWkt()), \")\");\n    }\n  }]);\n\n  return GEOGRAPHY;\n}(ABSTRACT);\n\nGEOGRAPHY.prototype.escape = false;\n/**\n * The cidr type holds an IPv4 or IPv6 network specification. Takes 7 or 19 bytes.\n *\n * Only available for Postgres\n */\n\nvar CIDR = /*#__PURE__*/function (_ABSTRACT22) {\n  _inherits(CIDR, _ABSTRACT22);\n\n  function CIDR() {\n    _classCallCheck(this, CIDR);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(CIDR).apply(this, arguments));\n  }\n\n  _createClass(CIDR, [{\n    key: \"validate\",\n    value: function validate(value) {\n      if (typeof value !== 'string' || !Validator.isIPRange(value)) {\n        throw new sequelizeErrors.ValidationError(util.format('%j is not a valid CIDR', value));\n      }\n\n      return true;\n    }\n  }]);\n\n  return CIDR;\n}(ABSTRACT);\n/**\n * The INET type holds an IPv4 or IPv6 host address, and optionally its subnet. Takes 7 or 19 bytes\n *\n * Only available for Postgres\n */\n\n\nvar INET = /*#__PURE__*/function (_ABSTRACT23) {\n  _inherits(INET, _ABSTRACT23);\n\n  function INET() {\n    _classCallCheck(this, INET);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(INET).apply(this, arguments));\n  }\n\n  _createClass(INET, [{\n    key: \"validate\",\n    value: function validate(value) {\n      if (typeof value !== 'string' || !Validator.isIP(value)) {\n        throw new sequelizeErrors.ValidationError(util.format('%j is not a valid INET', value));\n      }\n\n      return true;\n    }\n  }]);\n\n  return INET;\n}(ABSTRACT);\n/**\n * The MACADDR type stores MAC addresses. Takes 6 bytes\n *\n * Only available for Postgres\n *\n */\n\n\nvar MACADDR = /*#__PURE__*/function (_ABSTRACT24) {\n  _inherits(MACADDR, _ABSTRACT24);\n\n  function MACADDR() {\n    _classCallCheck(this, MACADDR);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MACADDR).apply(this, arguments));\n  }\n\n  _createClass(MACADDR, [{\n    key: \"validate\",\n    value: function validate(value) {\n      if (typeof value !== 'string' || !Validator.isMACAddress(value)) {\n        throw new sequelizeErrors.ValidationError(util.format('%j is not a valid MACADDR', value));\n      }\n\n      return true;\n    }\n  }]);\n\n  return MACADDR;\n}(ABSTRACT);\n/**\n * A convenience class holding commonly used data types. The data types are used when defining a new model using `Sequelize.define`, like this:\n * ```js\n * sequelize.define('model', {\n *   column: DataTypes.INTEGER\n * })\n * ```\n * When defining a model you can just as easily pass a string as type, but often using the types defined here is beneficial. For example, using `DataTypes.BLOB`, mean\n * that that column will be returned as an instance of `Buffer` when being fetched by sequelize.\n *\n * To provide a length for the data type, you can invoke it like a function: `INTEGER(2)`\n *\n * Some data types have special properties that can be accessed in order to change the data type.\n * For example, to get an unsigned integer with zerofill you can do `DataTypes.INTEGER.UNSIGNED.ZEROFILL`.\n * The order you access the properties in do not matter, so `DataTypes.INTEGER.ZEROFILL.UNSIGNED` is fine as well.\n *\n * * All number types (`INTEGER`, `BIGINT`, `FLOAT`, `DOUBLE`, `REAL`, `DECIMAL`) expose the properties `UNSIGNED` and `ZEROFILL`\n * * The `CHAR` and `STRING` types expose the `BINARY` property\n *\n * Three of the values provided here (`NOW`, `UUIDV1` and `UUIDV4`) are special default values, that should not be used to define types. Instead they are used as shorthands for\n * defining default values. For example, to get a uuid field with a default value generated following v1 of the UUID standard:\n * ```js\n * sequelize.define('model', {\n *   uuid: {\n *     type: DataTypes.UUID,\n *     defaultValue: DataTypes.UUIDV1,\n *     primaryKey: true\n *   }\n * })\n * ```\n * There may be times when you want to generate your own UUID conforming to some other algorithm. This is accomplished\n * using the defaultValue property as well, but instead of specifying one of the supplied UUID types, you return a value\n * from a function.\n * ```js\n * sequelize.define('model', {\n *   uuid: {\n *     type: DataTypes.UUID,\n *     defaultValue: function() {\n *       return generateMyId()\n *     },\n *     primaryKey: true\n *   }\n * })\n * ```\n */\n\n\nvar DataTypes = module.exports = {\n  ABSTRACT: ABSTRACT,\n  STRING: STRING,\n  CHAR: CHAR,\n  TEXT: TEXT,\n  NUMBER: NUMBER,\n  TINYINT: TINYINT,\n  SMALLINT: SMALLINT,\n  MEDIUMINT: MEDIUMINT,\n  INTEGER: INTEGER,\n  BIGINT: BIGINT,\n  FLOAT: FLOAT,\n  TIME: TIME,\n  DATE: DATE,\n  DATEONLY: DATEONLY,\n  BOOLEAN: BOOLEAN,\n  NOW: NOW,\n  BLOB: BLOB,\n  DECIMAL: DECIMAL,\n  NUMERIC: DECIMAL,\n  UUID: UUID,\n  UUIDV1: UUIDV1,\n  UUIDV4: UUIDV4,\n  HSTORE: HSTORE,\n  JSON: JSONTYPE,\n  JSONB: JSONB,\n  VIRTUAL: VIRTUAL,\n  ARRAY: ARRAY,\n  ENUM: ENUM,\n  RANGE: RANGE,\n  REAL: REAL,\n  'DOUBLE PRECISION': DOUBLE,\n  DOUBLE: DOUBLE,\n  GEOMETRY: GEOMETRY,\n  GEOGRAPHY: GEOGRAPHY,\n  CIDR: CIDR,\n  INET: INET,\n  MACADDR: MACADDR,\n  CITEXT: CITEXT\n};\n\n_.each(DataTypes, function (dataType, name) {\n  // guard for aliases\n  if (!Object.prototype.hasOwnProperty.call(dataType, 'key')) {\n    dataType.types = {};\n    dataType.key = dataType.prototype.key = name;\n  }\n});\n\nvar dialectMap = {};\ndialectMap.postgres = require('./dialects/postgres/data-types')(DataTypes);\ndialectMap.mysql = require('./dialects/mysql/data-types')(DataTypes);\ndialectMap.mariadb = require('./dialects/mariadb/data-types')(DataTypes);\ndialectMap.sqlite = require('./dialects/sqlite/data-types')(DataTypes);\ndialectMap.mssql = require('./dialects/mssql/data-types')(DataTypes);\n\nvar dialectList = _.values(dialectMap);\n\nvar _iterator = _createForOfIteratorHelper(dialectList),\n    _step;\n\ntry {\n  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n    var dataTypes = _step.value;\n\n    _.each(dataTypes, function (DataType, key) {\n      if (!DataType.key) {\n        DataType.key = DataType.prototype.key = key;\n      }\n    });\n  } // Wrap all data types to not require `new`\n\n} catch (err) {\n  _iterator.e(err);\n} finally {\n  _iterator.f();\n}\n\nvar _loop = function _loop() {\n  var dataTypes = _arr2[_i2];\n\n  _.each(dataTypes, function (DataType, key) {\n    dataTypes[key] = classToInvokable(DataType);\n  });\n};\n\nfor (var _i2 = 0, _arr2 = [DataTypes].concat(_toConsumableArray(dialectList)); _i2 < _arr2.length; _i2++) {\n  _loop();\n}\n\nObject.assign(DataTypes, dialectMap);","map":null,"metadata":{},"sourceType":"script"}