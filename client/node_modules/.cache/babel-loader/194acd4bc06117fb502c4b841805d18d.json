{"ast":null,"code":"'use strict';\n\nvar _assertThisInitialized = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _get = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nmodule.exports = function (BaseTypes) {\n  var warn = BaseTypes.ABSTRACT.warn.bind(undefined, 'https://www.sqlite.org/datatype3.html');\n  /**\n   * Removes unsupported SQLite options, i.e., UNSIGNED and ZEROFILL, for the integer data types.\n   *\n   * @param {object} dataType The base integer data type.\n   * @private\n   */\n\n  function removeUnsupportedIntegerOptions(dataType) {\n    if (dataType._zerofill || dataType._unsigned) {\n      warn(\"SQLite does not support '\".concat(dataType.key, \"' with UNSIGNED or ZEROFILL. Plain '\").concat(dataType.key, \"' will be used instead.\"));\n      dataType._unsigned = undefined;\n      dataType._zerofill = undefined;\n    }\n  }\n  /**\n   * @see https://sqlite.org/datatype3.html\n   */\n\n\n  BaseTypes.DATE.types.sqlite = ['DATETIME'];\n  BaseTypes.STRING.types.sqlite = ['VARCHAR', 'VARCHAR BINARY'];\n  BaseTypes.CHAR.types.sqlite = ['CHAR', 'CHAR BINARY'];\n  BaseTypes.TEXT.types.sqlite = ['TEXT'];\n  BaseTypes.TINYINT.types.sqlite = ['TINYINT'];\n  BaseTypes.SMALLINT.types.sqlite = ['SMALLINT'];\n  BaseTypes.MEDIUMINT.types.sqlite = ['MEDIUMINT'];\n  BaseTypes.INTEGER.types.sqlite = ['INTEGER'];\n  BaseTypes.BIGINT.types.sqlite = ['BIGINT'];\n  BaseTypes.FLOAT.types.sqlite = ['FLOAT'];\n  BaseTypes.TIME.types.sqlite = ['TIME'];\n  BaseTypes.DATEONLY.types.sqlite = ['DATE'];\n  BaseTypes.BOOLEAN.types.sqlite = ['TINYINT'];\n  BaseTypes.BLOB.types.sqlite = ['TINYBLOB', 'BLOB', 'LONGBLOB'];\n  BaseTypes.DECIMAL.types.sqlite = ['DECIMAL'];\n  BaseTypes.UUID.types.sqlite = ['UUID'];\n  BaseTypes.ENUM.types.sqlite = false;\n  BaseTypes.REAL.types.sqlite = ['REAL'];\n  BaseTypes.DOUBLE.types.sqlite = ['DOUBLE PRECISION'];\n  BaseTypes.GEOMETRY.types.sqlite = false;\n  BaseTypes.JSON.types.sqlite = ['JSON', 'JSONB'];\n\n  var JSONTYPE = /*#__PURE__*/function (_BaseTypes$JSON) {\n    _inherits(JSONTYPE, _BaseTypes$JSON);\n\n    function JSONTYPE() {\n      _classCallCheck(this, JSONTYPE);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(JSONTYPE).apply(this, arguments));\n    }\n\n    _createClass(JSONTYPE, null, [{\n      key: \"parse\",\n      value: function parse(data) {\n        return JSON.parse(data);\n      }\n    }]);\n\n    return JSONTYPE;\n  }(BaseTypes.JSON);\n\n  var DATE = /*#__PURE__*/function (_BaseTypes$DATE) {\n    _inherits(DATE, _BaseTypes$DATE);\n\n    function DATE() {\n      _classCallCheck(this, DATE);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(DATE).apply(this, arguments));\n    }\n\n    _createClass(DATE, null, [{\n      key: \"parse\",\n      value: function parse(date, options) {\n        if (!date.includes('+')) {\n          // For backwards compat. Dates inserted by sequelize < 2.0dev12 will not have a timestamp set\n          return new Date(date + options.timezone);\n        }\n\n        return new Date(date); // We already have a timezone stored in the string\n      }\n    }]);\n\n    return DATE;\n  }(BaseTypes.DATE);\n\n  var DATEONLY = /*#__PURE__*/function (_BaseTypes$DATEONLY) {\n    _inherits(DATEONLY, _BaseTypes$DATEONLY);\n\n    function DATEONLY() {\n      _classCallCheck(this, DATEONLY);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(DATEONLY).apply(this, arguments));\n    }\n\n    _createClass(DATEONLY, null, [{\n      key: \"parse\",\n      value: function parse(date) {\n        return date;\n      }\n    }]);\n\n    return DATEONLY;\n  }(BaseTypes.DATEONLY);\n\n  var STRING = /*#__PURE__*/function (_BaseTypes$STRING) {\n    _inherits(STRING, _BaseTypes$STRING);\n\n    function STRING() {\n      _classCallCheck(this, STRING);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(STRING).apply(this, arguments));\n    }\n\n    _createClass(STRING, [{\n      key: \"toSql\",\n      value: function toSql() {\n        if (this._binary) {\n          return \"VARCHAR BINARY(\".concat(this._length, \")\");\n        }\n\n        return _get(_getPrototypeOf(STRING.prototype), \"toSql\", this).call(this, this);\n      }\n    }]);\n\n    return STRING;\n  }(BaseTypes.STRING);\n\n  var TEXT = /*#__PURE__*/function (_BaseTypes$TEXT) {\n    _inherits(TEXT, _BaseTypes$TEXT);\n\n    function TEXT() {\n      _classCallCheck(this, TEXT);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(TEXT).apply(this, arguments));\n    }\n\n    _createClass(TEXT, [{\n      key: \"toSql\",\n      value: function toSql() {\n        if (this._length) {\n          warn('SQLite does not support TEXT with options. Plain `TEXT` will be used instead.');\n          this._length = undefined;\n        }\n\n        return 'TEXT';\n      }\n    }]);\n\n    return TEXT;\n  }(BaseTypes.TEXT);\n\n  var CITEXT = /*#__PURE__*/function (_BaseTypes$CITEXT) {\n    _inherits(CITEXT, _BaseTypes$CITEXT);\n\n    function CITEXT() {\n      _classCallCheck(this, CITEXT);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(CITEXT).apply(this, arguments));\n    }\n\n    _createClass(CITEXT, [{\n      key: \"toSql\",\n      value: function toSql() {\n        return 'TEXT COLLATE NOCASE';\n      }\n    }]);\n\n    return CITEXT;\n  }(BaseTypes.CITEXT);\n\n  var CHAR = /*#__PURE__*/function (_BaseTypes$CHAR) {\n    _inherits(CHAR, _BaseTypes$CHAR);\n\n    function CHAR() {\n      _classCallCheck(this, CHAR);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(CHAR).apply(this, arguments));\n    }\n\n    _createClass(CHAR, [{\n      key: \"toSql\",\n      value: function toSql() {\n        if (this._binary) {\n          return \"CHAR BINARY(\".concat(this._length, \")\");\n        }\n\n        return _get(_getPrototypeOf(CHAR.prototype), \"toSql\", this).call(this);\n      }\n    }]);\n\n    return CHAR;\n  }(BaseTypes.CHAR);\n\n  var NUMBER = /*#__PURE__*/function (_BaseTypes$NUMBER) {\n    _inherits(NUMBER, _BaseTypes$NUMBER);\n\n    function NUMBER() {\n      _classCallCheck(this, NUMBER);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(NUMBER).apply(this, arguments));\n    }\n\n    _createClass(NUMBER, [{\n      key: \"toSql\",\n      value: function toSql() {\n        var result = this.key;\n\n        if (this._unsigned) {\n          result += ' UNSIGNED';\n        }\n\n        if (this._zerofill) {\n          result += ' ZEROFILL';\n        }\n\n        if (this._length) {\n          result += \"(\".concat(this._length);\n\n          if (typeof this._decimals === 'number') {\n            result += \",\".concat(this._decimals);\n          }\n\n          result += ')';\n        }\n\n        return result;\n      }\n    }]);\n\n    return NUMBER;\n  }(BaseTypes.NUMBER);\n\n  var TINYINT = /*#__PURE__*/function (_BaseTypes$TINYINT) {\n    _inherits(TINYINT, _BaseTypes$TINYINT);\n\n    function TINYINT(length) {\n      var _this;\n\n      _classCallCheck(this, TINYINT);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(TINYINT).call(this, length));\n      removeUnsupportedIntegerOptions(_assertThisInitialized(_assertThisInitialized(_this)));\n      return _this;\n    }\n\n    return TINYINT;\n  }(BaseTypes.TINYINT);\n\n  var SMALLINT = /*#__PURE__*/function (_BaseTypes$SMALLINT) {\n    _inherits(SMALLINT, _BaseTypes$SMALLINT);\n\n    function SMALLINT(length) {\n      var _this2;\n\n      _classCallCheck(this, SMALLINT);\n\n      _this2 = _possibleConstructorReturn(this, _getPrototypeOf(SMALLINT).call(this, length));\n      removeUnsupportedIntegerOptions(_assertThisInitialized(_assertThisInitialized(_this2)));\n      return _this2;\n    }\n\n    return SMALLINT;\n  }(BaseTypes.SMALLINT);\n\n  var MEDIUMINT = /*#__PURE__*/function (_BaseTypes$MEDIUMINT) {\n    _inherits(MEDIUMINT, _BaseTypes$MEDIUMINT);\n\n    function MEDIUMINT(length) {\n      var _this3;\n\n      _classCallCheck(this, MEDIUMINT);\n\n      _this3 = _possibleConstructorReturn(this, _getPrototypeOf(MEDIUMINT).call(this, length));\n      removeUnsupportedIntegerOptions(_assertThisInitialized(_assertThisInitialized(_this3)));\n      return _this3;\n    }\n\n    return MEDIUMINT;\n  }(BaseTypes.MEDIUMINT);\n\n  var INTEGER = /*#__PURE__*/function (_BaseTypes$INTEGER) {\n    _inherits(INTEGER, _BaseTypes$INTEGER);\n\n    function INTEGER(length) {\n      var _this4;\n\n      _classCallCheck(this, INTEGER);\n\n      _this4 = _possibleConstructorReturn(this, _getPrototypeOf(INTEGER).call(this, length));\n      removeUnsupportedIntegerOptions(_assertThisInitialized(_assertThisInitialized(_this4)));\n      return _this4;\n    }\n\n    return INTEGER;\n  }(BaseTypes.INTEGER);\n\n  var BIGINT = /*#__PURE__*/function (_BaseTypes$BIGINT) {\n    _inherits(BIGINT, _BaseTypes$BIGINT);\n\n    function BIGINT(length) {\n      var _this5;\n\n      _classCallCheck(this, BIGINT);\n\n      _this5 = _possibleConstructorReturn(this, _getPrototypeOf(BIGINT).call(this, length));\n      removeUnsupportedIntegerOptions(_assertThisInitialized(_assertThisInitialized(_this5)));\n      return _this5;\n    }\n\n    return BIGINT;\n  }(BaseTypes.BIGINT);\n\n  var FLOAT = /*#__PURE__*/function (_BaseTypes$FLOAT) {\n    _inherits(FLOAT, _BaseTypes$FLOAT);\n\n    function FLOAT() {\n      _classCallCheck(this, FLOAT);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(FLOAT).apply(this, arguments));\n    }\n\n    return FLOAT;\n  }(BaseTypes.FLOAT);\n\n  var DOUBLE = /*#__PURE__*/function (_BaseTypes$DOUBLE) {\n    _inherits(DOUBLE, _BaseTypes$DOUBLE);\n\n    function DOUBLE() {\n      _classCallCheck(this, DOUBLE);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(DOUBLE).apply(this, arguments));\n    }\n\n    return DOUBLE;\n  }(BaseTypes.DOUBLE);\n\n  var REAL = /*#__PURE__*/function (_BaseTypes$REAL) {\n    _inherits(REAL, _BaseTypes$REAL);\n\n    function REAL() {\n      _classCallCheck(this, REAL);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(REAL).apply(this, arguments));\n    }\n\n    return REAL;\n  }(BaseTypes.REAL);\n\n  function parseFloating(value) {\n    if (typeof value !== 'string') {\n      return value;\n    }\n\n    if (value === 'NaN') {\n      return NaN;\n    }\n\n    if (value === 'Infinity') {\n      return Infinity;\n    }\n\n    if (value === '-Infinity') {\n      return -Infinity;\n    }\n  }\n\n  for (var _i = 0, _arr = [FLOAT, DOUBLE, REAL]; _i < _arr.length; _i++) {\n    var floating = _arr[_i];\n    floating.parse = parseFloating;\n  }\n\n  for (var _i2 = 0, _arr2 = [FLOAT, DOUBLE, REAL, TINYINT, SMALLINT, MEDIUMINT, INTEGER, BIGINT]; _i2 < _arr2.length; _i2++) {\n    var num = _arr2[_i2];\n    num.prototype.toSql = NUMBER.prototype.toSql;\n  }\n\n  var ENUM = /*#__PURE__*/function (_BaseTypes$ENUM) {\n    _inherits(ENUM, _BaseTypes$ENUM);\n\n    function ENUM() {\n      _classCallCheck(this, ENUM);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(ENUM).apply(this, arguments));\n    }\n\n    _createClass(ENUM, [{\n      key: \"toSql\",\n      value: function toSql() {\n        return 'TEXT';\n      }\n    }]);\n\n    return ENUM;\n  }(BaseTypes.ENUM);\n\n  return {\n    DATE: DATE,\n    DATEONLY: DATEONLY,\n    STRING: STRING,\n    CHAR: CHAR,\n    NUMBER: NUMBER,\n    FLOAT: FLOAT,\n    REAL: REAL,\n    'DOUBLE PRECISION': DOUBLE,\n    TINYINT: TINYINT,\n    SMALLINT: SMALLINT,\n    MEDIUMINT: MEDIUMINT,\n    INTEGER: INTEGER,\n    BIGINT: BIGINT,\n    TEXT: TEXT,\n    ENUM: ENUM,\n    JSON: JSONTYPE,\n    CITEXT: CITEXT\n  };\n};","map":null,"metadata":{},"sourceType":"script"}