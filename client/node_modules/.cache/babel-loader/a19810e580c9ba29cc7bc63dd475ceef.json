{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar validator = _.cloneDeep(require('validator'));\n\nvar moment = require('moment');\n\nvar extensions = {\n  extend: function extend(name, fn) {\n    this[name] = fn;\n    return this;\n  },\n  notEmpty: function notEmpty(str) {\n    return !str.match(/^[\\s\\t\\r\\n]*$/);\n  },\n  len: function len(str, min, max) {\n    return this.isLength(str, min, max);\n  },\n  isUrl: function isUrl(str) {\n    return this.isURL(str);\n  },\n  isIPv6: function isIPv6(str) {\n    return this.isIP(str, 6);\n  },\n  isIPv4: function isIPv4(str) {\n    return this.isIP(str, 4);\n  },\n  notIn: function notIn(str, values) {\n    return !this.isIn(str, values);\n  },\n  regex: function regex(str, pattern, modifiers) {\n    str += '';\n\n    if (Object.prototype.toString.call(pattern).slice(8, -1) !== 'RegExp') {\n      pattern = new RegExp(pattern, modifiers);\n    }\n\n    return str.match(pattern);\n  },\n  notRegex: function notRegex(str, pattern, modifiers) {\n    return !this.regex(str, pattern, modifiers);\n  },\n  isDecimal: function isDecimal(str) {\n    return str !== '' && !!str.match(/^(?:-?(?:[0-9]+))?(?:\\.[0-9]*)?(?:[eE][+-]?(?:[0-9]+))?$/);\n  },\n  min: function min(str, val) {\n    var number = parseFloat(str);\n    return isNaN(number) || number >= val;\n  },\n  max: function max(str, val) {\n    var number = parseFloat(str);\n    return isNaN(number) || number <= val;\n  },\n  not: function not(str, pattern, modifiers) {\n    return this.notRegex(str, pattern, modifiers);\n  },\n  contains: function contains(str, elem) {\n    return !!elem && str.includes(elem);\n  },\n  notContains: function notContains(str, elem) {\n    return !this.contains(str, elem);\n  },\n  is: function is(str, pattern, modifiers) {\n    return this.regex(str, pattern, modifiers);\n  }\n};\nexports.extensions = extensions; // instance based validators\n\nvalidator.isImmutable = function (value, validatorArgs, field, modelInstance) {\n  return modelInstance.isNewRecord || modelInstance.dataValues[field] === modelInstance._previousDataValues[field];\n}; // extra validators\n\n\nvalidator.notNull = function (val) {\n  return val !== null && val !== undefined;\n}; // https://github.com/chriso/validator.js/blob/6.2.0/validator.js\n\n\n_.forEach(extensions, function (extend, key) {\n  validator[key] = extend;\n}); // map isNull to isEmpty\n// https://github.com/chriso/validator.js/commit/e33d38a26ee2f9666b319adb67c7fc0d3dea7125\n\n\nvalidator.isNull = validator.isEmpty; // isDate removed in 7.0.0\n// https://github.com/chriso/validator.js/commit/095509fc707a4dc0e99f85131df1176ad6389fc9\n\nvalidator.isDate = function (dateString) {\n  // avoid http://momentjs.com/guides/#/warnings/js-date/\n  // by doing a preliminary check on `dateString`\n  var parsed = Date.parse(dateString);\n\n  if (isNaN(parsed)) {\n    // fail if we can't parse it\n    return false;\n  } // otherwise convert to ISO 8601 as moment prefers\n  // http://momentjs.com/docs/#/parsing/string/\n\n\n  var date = new Date(parsed);\n  return moment(date.toISOString()).isValid();\n};\n\nexports.validator = validator;","map":null,"metadata":{},"sourceType":"script"}