{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar HasOne = require('./has-one');\n\nvar HasMany = require('./has-many');\n\nvar BelongsToMany = require('./belongs-to-many');\n\nvar BelongsTo = require('./belongs-to');\n\nfunction isModel(model, sequelize) {\n  return model && model.prototype && model.prototype instanceof sequelize.Sequelize.Model;\n}\n\nvar Mixin = {\n  hasMany: function hasMany(target) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!isModel(target, this.sequelize)) {\n      throw new Error(\"\".concat(this.name, \".hasMany called with something that's not a subclass of Sequelize.Model\"));\n    }\n\n    var source = this; // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n    Object.assign(options, _.omit(source.options, ['hooks']));\n\n    if (options.useHooks) {\n      this.runHooks('beforeAssociate', {\n        source: source,\n        target: target,\n        type: HasMany\n      }, options);\n    } // the id is in the foreign table or in a connecting table\n\n\n    var association = new HasMany(source, target, options);\n    source.associations[association.associationAccessor] = association;\n\n    association._injectAttributes();\n\n    association.mixin(source.prototype);\n\n    if (options.useHooks) {\n      this.runHooks('afterAssociate', {\n        source: source,\n        target: target,\n        type: HasMany,\n        association: association\n      }, options);\n    }\n\n    return association;\n  },\n  belongsToMany: function belongsToMany(target) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!isModel(target, this.sequelize)) {\n      throw new Error(\"\".concat(this.name, \".belongsToMany called with something that's not a subclass of Sequelize.Model\"));\n    }\n\n    var source = this; // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n    options.timestamps = options.timestamps === undefined ? this.sequelize.options.timestamps : options.timestamps;\n    Object.assign(options, _.omit(source.options, ['hooks', 'timestamps', 'scopes', 'defaultScope']));\n\n    if (options.useHooks) {\n      this.runHooks('beforeAssociate', {\n        source: source,\n        target: target,\n        type: BelongsToMany\n      }, options);\n    } // the id is in the foreign table or in a connecting table\n\n\n    var association = new BelongsToMany(source, target, options);\n    source.associations[association.associationAccessor] = association;\n\n    association._injectAttributes();\n\n    association.mixin(source.prototype);\n\n    if (options.useHooks) {\n      this.runHooks('afterAssociate', {\n        source: source,\n        target: target,\n        type: BelongsToMany,\n        association: association\n      }, options);\n    }\n\n    return association;\n  },\n  getAssociations: function getAssociations(target) {\n    return Object.values(this.associations).filter(function (association) {\n      return association.target.name === target.name;\n    });\n  },\n  getAssociationForAlias: function getAssociationForAlias(target, alias) {\n    // Two associations cannot have the same alias, so we can use find instead of filter\n    return this.getAssociations(target).find(function (association) {\n      return association.verifyAssociationAlias(alias);\n    }) || null;\n  }\n}; // The logic for hasOne and belongsTo is exactly the same\n\nfunction singleLinked(Type) {\n  return function (target) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // eslint-disable-next-line no-invalid-this\n    var source = this;\n\n    if (!isModel(target, source.sequelize)) {\n      throw new Error(\"\".concat(source.name, \".\").concat(_.lowerFirst(Type.name), \" called with something that's not a subclass of Sequelize.Model\"));\n    } // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n\n\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n\n    if (options.useHooks) {\n      source.runHooks('beforeAssociate', {\n        source: source,\n        target: target,\n        type: Type\n      }, options);\n    } // the id is in the foreign table\n\n\n    var association = new Type(source, target, Object.assign(options, source.options));\n    source.associations[association.associationAccessor] = association;\n\n    association._injectAttributes();\n\n    association.mixin(source.prototype);\n\n    if (options.useHooks) {\n      source.runHooks('afterAssociate', {\n        source: source,\n        target: target,\n        type: Type,\n        association: association\n      }, options);\n    }\n\n    return association;\n  };\n}\n\nMixin.hasOne = singleLinked(HasOne);\nMixin.belongsTo = singleLinked(BelongsTo);\nmodule.exports = Mixin;\nmodule.exports.Mixin = Mixin;\nmodule.exports.default = Mixin;","map":null,"metadata":{},"sourceType":"script"}