{"ast":null,"code":"'use strict';\n\nvar Combine = require('ordered-read-streams');\n\nvar unique = require('unique-stream');\n\nvar pumpify = require('pumpify');\n\nvar isNegatedGlob = require('is-negated-glob');\n\nvar extend = require('extend');\n\nvar GlobStream = require('./readable');\n\nfunction globStream(globs, opt) {\n  if (!opt) {\n    opt = {};\n  }\n\n  var ourOpt = extend({}, opt);\n  var ignore = ourOpt.ignore;\n  ourOpt.cwd = typeof ourOpt.cwd === 'string' ? ourOpt.cwd : process.cwd();\n  ourOpt.dot = typeof ourOpt.dot === 'boolean' ? ourOpt.dot : false;\n  ourOpt.silent = typeof ourOpt.silent === 'boolean' ? ourOpt.silent : true;\n  ourOpt.cwdbase = typeof ourOpt.cwdbase === 'boolean' ? ourOpt.cwdbase : false;\n  ourOpt.uniqueBy = typeof ourOpt.uniqueBy === 'string' || typeof ourOpt.uniqueBy === 'function' ? ourOpt.uniqueBy : 'path';\n\n  if (ourOpt.cwdbase) {\n    ourOpt.base = ourOpt.cwd;\n  } // Normalize string `ignore` to array\n\n\n  if (typeof ignore === 'string') {\n    ignore = [ignore];\n  } // Ensure `ignore` is an array\n\n\n  if (!Array.isArray(ignore)) {\n    ignore = [];\n  } // Only one glob no need to aggregate\n\n\n  if (!Array.isArray(globs)) {\n    globs = [globs];\n  }\n\n  var positives = [];\n  var negatives = [];\n  globs.forEach(sortGlobs);\n\n  function sortGlobs(globString, index) {\n    if (typeof globString !== 'string') {\n      throw new Error('Invalid glob at index ' + index);\n    }\n\n    var glob = isNegatedGlob(globString);\n    var globArray = glob.negated ? negatives : positives;\n    globArray.push({\n      index: index,\n      glob: glob.pattern\n    });\n  }\n\n  if (positives.length === 0) {\n    throw new Error('Missing positive glob');\n  } // Create all individual streams\n\n\n  var streams = positives.map(streamFromPositive); // Then just pipe them to a single unique stream and return it\n\n  var aggregate = new Combine(streams);\n  var uniqueStream = unique(ourOpt.uniqueBy);\n  return pumpify.obj(aggregate, uniqueStream);\n\n  function streamFromPositive(positive) {\n    var negativeGlobs = negatives.filter(indexGreaterThan(positive.index)).map(toGlob).concat(ignore);\n    return new GlobStream(positive.glob, negativeGlobs, ourOpt);\n  }\n}\n\nfunction indexGreaterThan(index) {\n  return function (obj) {\n    return obj.index > index;\n  };\n}\n\nfunction toGlob(obj) {\n  return obj.glob;\n}\n\nmodule.exports = globStream;","map":null,"metadata":{},"sourceType":"script"}