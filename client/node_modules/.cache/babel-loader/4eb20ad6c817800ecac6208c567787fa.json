{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Packet = require('./packets/packet.js');\n\nvar MAX_PACKET_LENGTH = 16777215;\n\nfunction readPacketLength(b, off) {\n  var b0 = b[off];\n  var b1 = b[off + 1];\n  var b2 = b[off + 2];\n\n  if (b1 + b2 === 0) {\n    return b0;\n  }\n\n  return b0 + (b1 << 8) + (b2 << 16);\n}\n\nvar PacketParser = /*#__PURE__*/function () {\n  function PacketParser(onPacket, packetHeaderLength) {\n    _classCallCheck(this, PacketParser);\n\n    // 4 for normal packets, 7 for comprssed protocol packets\n    if (typeof packetHeaderLength === 'undefined') {\n      packetHeaderLength = 4;\n    } // array of last payload chunks\n    // only used when current payload is not complete\n\n\n    this.buffer = []; // total length of chunks on buffer\n\n    this.bufferLength = 0;\n    this.packetHeaderLength = packetHeaderLength; // incomplete header state: number of header bytes received\n\n    this.headerLen = 0; // expected payload length\n\n    this.length = 0;\n    this.largePacketParts = [];\n    this.firstPacketSequenceId = 0;\n    this.onPacket = onPacket;\n    this.execute = PacketParser.prototype.executeStart;\n    this._flushLargePacket = packetHeaderLength === 7 ? this._flushLargePacket7 : this._flushLargePacket4;\n  }\n\n  _createClass(PacketParser, [{\n    key: \"_flushLargePacket4\",\n    value: function _flushLargePacket4() {\n      var numPackets = this.largePacketParts.length;\n      this.largePacketParts.unshift(Buffer.from([0, 0, 0, 0])); // insert header\n\n      var body = Buffer.concat(this.largePacketParts);\n      var packet = new Packet(this.firstPacketSequenceId, body, 0, body.length);\n      this.largePacketParts.length = 0;\n      packet.numPackets = numPackets;\n      this.onPacket(packet);\n    }\n  }, {\n    key: \"_flushLargePacket7\",\n    value: function _flushLargePacket7() {\n      var numPackets = this.largePacketParts.length;\n      this.largePacketParts.unshift(Buffer.from([0, 0, 0, 0, 0, 0, 0])); // insert header\n\n      var body = Buffer.concat(this.largePacketParts);\n      this.largePacketParts.length = 0;\n      var packet = new Packet(this.firstPacketSequenceId, body, 0, body.length);\n      packet.numPackets = numPackets;\n      this.onPacket(packet);\n    }\n  }, {\n    key: \"executeStart\",\n    value: function executeStart(chunk) {\n      var start = 0;\n      var end = chunk.length;\n\n      while (end - start >= 3) {\n        this.length = readPacketLength(chunk, start);\n\n        if (end - start >= this.length + this.packetHeaderLength) {\n          // at least one full packet\n          var sequenceId = chunk[start + 3];\n\n          if (this.length < MAX_PACKET_LENGTH && this.largePacketParts.length === 0) {\n            this.onPacket(new Packet(sequenceId, chunk, start, start + this.packetHeaderLength + this.length));\n          } else {\n            // first large packet - remember it's id\n            if (this.largePacketParts.length === 0) {\n              this.firstPacketSequenceId = sequenceId;\n            }\n\n            this.largePacketParts.push(chunk.slice(start + this.packetHeaderLength, start + this.packetHeaderLength + this.length));\n\n            if (this.length < MAX_PACKET_LENGTH) {\n              this._flushLargePacket();\n            }\n          }\n\n          start += this.packetHeaderLength + this.length;\n        } else {\n          // payload is incomplete\n          this.buffer = [chunk.slice(start + 3, end)];\n          this.bufferLength = end - start - 3;\n          this.execute = PacketParser.prototype.executePayload;\n          return;\n        }\n      }\n\n      if (end - start > 0) {\n        // there is start of length header, but it's not full 3 bytes\n        this.headerLen = end - start; // 1 or 2 bytes\n\n        this.length = chunk[start];\n\n        if (this.headerLen === 2) {\n          this.length = chunk[start] + (chunk[start + 1] << 8);\n          this.execute = PacketParser.prototype.executeHeader3;\n        } else {\n          this.execute = PacketParser.prototype.executeHeader2;\n        }\n      }\n    }\n  }, {\n    key: \"executePayload\",\n    value: function executePayload(chunk) {\n      var start = 0;\n      var end = chunk.length;\n      var remainingPayload = this.length - this.bufferLength + this.packetHeaderLength - 3;\n\n      if (end - start >= remainingPayload) {\n        // last chunk for payload\n        var payload = Buffer.allocUnsafe(this.length + this.packetHeaderLength);\n        var offset = 3;\n\n        for (var i = 0; i < this.buffer.length; ++i) {\n          this.buffer[i].copy(payload, offset);\n          offset += this.buffer[i].length;\n        }\n\n        chunk.copy(payload, offset, start, start + remainingPayload);\n        var sequenceId = payload[3];\n\n        if (this.length < MAX_PACKET_LENGTH && this.largePacketParts.length === 0) {\n          this.onPacket(new Packet(sequenceId, payload, 0, this.length + this.packetHeaderLength));\n        } else {\n          // first large packet - remember it's id\n          if (this.largePacketParts.length === 0) {\n            this.firstPacketSequenceId = sequenceId;\n          }\n\n          this.largePacketParts.push(payload.slice(this.packetHeaderLength, this.packetHeaderLength + this.length));\n\n          if (this.length < MAX_PACKET_LENGTH) {\n            this._flushLargePacket();\n          }\n        }\n\n        this.buffer = [];\n        this.bufferLength = 0;\n        this.execute = PacketParser.prototype.executeStart;\n        start += remainingPayload;\n\n        if (end - start > 0) {\n          return this.execute(chunk.slice(start, end));\n        }\n      } else {\n        this.buffer.push(chunk);\n        this.bufferLength += chunk.length;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"executeHeader2\",\n    value: function executeHeader2(chunk) {\n      this.length += chunk[0] << 8;\n\n      if (chunk.length > 1) {\n        this.length += chunk[1] << 16;\n        this.execute = PacketParser.prototype.executePayload;\n        return this.executePayload(chunk.slice(2));\n      }\n\n      this.execute = PacketParser.prototype.executeHeader3;\n      return null;\n    }\n  }, {\n    key: \"executeHeader3\",\n    value: function executeHeader3(chunk) {\n      this.length += chunk[0] << 16;\n      this.execute = PacketParser.prototype.executePayload;\n      return this.executePayload(chunk.slice(1));\n    }\n  }]);\n\n  return PacketParser;\n}();\n\nmodule.exports = PacketParser;","map":null,"metadata":{},"sourceType":"script"}