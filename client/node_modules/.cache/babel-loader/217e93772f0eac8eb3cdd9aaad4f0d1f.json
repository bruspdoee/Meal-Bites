{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _objectSpread = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _ = require('lodash');\n\nvar Utils = require('./utils');\n\nvar sequelizeError = require('./errors');\n\nvar DataTypes = require('./data-types');\n\nvar BelongsTo = require('./associations/belongs-to');\n\nvar validator = require('./utils/validator-extras').validator;\n\nvar _require = require('util'),\n    promisify = _require.promisify;\n/**\n * Instance Validator.\n *\n * @param {Instance} modelInstance The model instance.\n * @param {object} options A dictionary with options.\n *\n * @private\n */\n\n\nvar InstanceValidator = /*#__PURE__*/function () {\n  function InstanceValidator(modelInstance, options) {\n    _classCallCheck(this, InstanceValidator);\n\n    options = _objectSpread({\n      // assign defined and default options\n      hooks: true\n    }, options);\n\n    if (options.fields && !options.skip) {\n      options.skip = _.difference(Object.keys(modelInstance.constructor.rawAttributes), options.fields);\n    } else {\n      options.skip = options.skip || [];\n    }\n\n    this.options = options;\n    this.modelInstance = modelInstance;\n    /**\n     * Exposes a reference to validator.js. This allows you to add custom validations using `validator.extend`\n     *\n     * @name validator\n     * @private\n     */\n\n    this.validator = validator;\n    /**\n     *  All errors will be stored here from the validations.\n     *\n     * @type {Array} Will contain keys that correspond to attributes which will\n     *   be Arrays of Errors.\n     * @private\n     */\n\n    this.errors = [];\n    /**\n     * @type {boolean} Indicates if validations are in progress\n     * @private\n     */\n\n    this.inProgress = false;\n  }\n  /**\n   * The main entry point for the Validation module, invoke to start the dance.\n   *\n   * @returns {Promise}\n   * @private\n   */\n\n\n  _createClass(InstanceValidator, [{\n    key: \"_validate\",\n    value: function () {\n      var _validate2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.inProgress) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new Error('Validations already in progress.');\n\n              case 2:\n                this.inProgress = true;\n                _context.next = 5;\n                return Promise.all([this._perAttributeValidators(), this._customValidators()]);\n\n              case 5:\n                if (!this.errors.length) {\n                  _context.next = 7;\n                  break;\n                }\n\n                throw new sequelizeError.ValidationError(null, this.errors);\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _validate() {\n        return _validate2.apply(this, arguments);\n      }\n\n      return _validate;\n    }()\n    /**\n     * Invoke the Validation sequence and run validation hooks if defined\n     *   - Before Validation Model Hooks\n     *   - Validation\n     *   - On validation success: After Validation Model Hooks\n     *   - On validation failure: Validation Failed Model Hooks\n     *\n     * @returns {Promise}\n     * @private\n     */\n\n  }, {\n    key: \"validate\",\n    value: function () {\n      var _validate3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.options.hooks ? this._validateAndRunHooks() : this._validate();\n\n              case 2:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function validate() {\n        return _validate3.apply(this, arguments);\n      }\n\n      return validate;\n    }()\n    /**\n     * Invoke the Validation sequence and run hooks\n     *   - Before Validation Model Hooks\n     *   - Validation\n     *   - On validation success: After Validation Model Hooks\n     *   - On validation failure: Validation Failed Model Hooks\n     *\n     * @returns {Promise}\n     * @private\n     */\n\n  }, {\n    key: \"_validateAndRunHooks\",\n    value: function () {\n      var _validateAndRunHooks2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var runHooks, newError;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                runHooks = this.modelInstance.constructor.runHooks.bind(this.modelInstance.constructor);\n                _context3.next = 3;\n                return runHooks('beforeValidate', this.modelInstance, this.options);\n\n              case 3:\n                _context3.prev = 3;\n                _context3.next = 6;\n                return this._validate();\n\n              case 6:\n                _context3.next = 14;\n                break;\n\n              case 8:\n                _context3.prev = 8;\n                _context3.t0 = _context3[\"catch\"](3);\n                _context3.next = 12;\n                return runHooks('validationFailed', this.modelInstance, this.options, _context3.t0);\n\n              case 12:\n                newError = _context3.sent;\n                throw newError || _context3.t0;\n\n              case 14:\n                _context3.next = 16;\n                return runHooks('afterValidate', this.modelInstance, this.options);\n\n              case 16:\n                return _context3.abrupt(\"return\", this.modelInstance);\n\n              case 17:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[3, 8]]);\n      }));\n\n      function _validateAndRunHooks() {\n        return _validateAndRunHooks2.apply(this, arguments);\n      }\n\n      return _validateAndRunHooks;\n    }()\n    /**\n     * Will run all the validators defined per attribute (built-in validators and custom validators)\n     *\n     * @returns {Promise<Array>}\n     * @private\n     */\n\n  }, {\n    key: \"_perAttributeValidators\",\n    value: function () {\n      var _perAttributeValidators2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _this = this;\n\n        var validators;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                // promisify all attribute invocations\n                validators = [];\n\n                _.forIn(this.modelInstance.rawAttributes, function (rawAttribute, field) {\n                  if (_this.options.skip.includes(field)) {\n                    return;\n                  }\n\n                  var value = _this.modelInstance.dataValues[field];\n\n                  if (value instanceof Utils.SequelizeMethod) {\n                    return;\n                  }\n\n                  if (!rawAttribute._autoGenerated && !rawAttribute.autoIncrement) {\n                    // perform validations based on schema\n                    _this._validateSchema(rawAttribute, field, value);\n                  }\n\n                  if (Object.prototype.hasOwnProperty.call(_this.modelInstance.validators, field)) {\n                    validators.push(_this._singleAttrValidate(value, field, rawAttribute.allowNull));\n                  }\n                });\n\n                _context4.next = 4;\n                return Promise.all(validators);\n\n              case 4:\n                return _context4.abrupt(\"return\", _context4.sent);\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _perAttributeValidators() {\n        return _perAttributeValidators2.apply(this, arguments);\n      }\n\n      return _perAttributeValidators;\n    }()\n    /**\n     * Will run all the custom validators defined in the model's options.\n     *\n     * @returns {Promise<Array>}\n     * @private\n     */\n\n  }, {\n    key: \"_customValidators\",\n    value: function () {\n      var _customValidators2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var _this2 = this;\n\n        var validators;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                validators = [];\n\n                _.each(this.modelInstance.constructor.options.validate, function (validator, validatorType) {\n                  if (_this2.options.skip.includes(validatorType)) {\n                    return;\n                  }\n\n                  var valprom = _this2._invokeCustomValidator(validator, validatorType) // errors are handled in settling, stub this\n                  .catch(function () {});\n\n                  validators.push(valprom);\n                });\n\n                _context5.next = 4;\n                return Promise.all(validators);\n\n              case 4:\n                return _context5.abrupt(\"return\", _context5.sent);\n\n              case 5:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function _customValidators() {\n        return _customValidators2.apply(this, arguments);\n      }\n\n      return _customValidators;\n    }()\n    /**\n     * Validate a single attribute with all the defined built-in validators and custom validators.\n     *\n     * @private\n     *\n     * @param {*} value Anything.\n     * @param {string} field The field name.\n     * @param {boolean} allowNull Whether or not the schema allows null values\n     *\n     * @returns {Promise} A promise, will always resolve, auto populates error on this.error local object.\n     */\n\n  }, {\n    key: \"_singleAttrValidate\",\n    value: function () {\n      var _singleAttrValidate2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(value, field, allowNull) {\n        var _this3 = this;\n\n        var validators;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!((value === null || value === undefined) && !allowNull)) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\");\n\n              case 2:\n                // Promisify each validator\n                validators = [];\n\n                _.forIn(this.modelInstance.validators[field], function (test, validatorType) {\n                  if (validatorType === 'isUrl' || validatorType === 'isURL' || validatorType === 'isEmail') {\n                    // Preserve backwards compat. Validator.js now expects the second param to isURL and isEmail to be an object\n                    if (typeof test === 'object' && test !== null && test.msg) {\n                      test = {\n                        msg: test.msg\n                      };\n                    } else if (test === true) {\n                      test = {};\n                    }\n                  } // Custom validators should always run, except if value is null and allowNull is false (see #9143)\n\n\n                  if (typeof test === 'function') {\n                    validators.push(_this3._invokeCustomValidator(test, validatorType, true, value, field));\n                    return;\n                  } // If value is null, built-in validators should not run (only custom validators have to run) (see #9134).\n\n\n                  if (value === null || value === undefined) {\n                    return;\n                  }\n\n                  var validatorPromise = _this3._invokeBuiltinValidator(value, test, validatorType, field); // errors are handled in settling, stub this\n\n\n                  validatorPromise.catch(function () {});\n                  validators.push(validatorPromise);\n                });\n\n                return _context6.abrupt(\"return\", Promise.all(validators.map(function (validator) {\n                  return validator.catch(function (rejection) {\n                    var isBuiltIn = !!rejection.validatorName;\n\n                    _this3._pushError(isBuiltIn, field, rejection, value, rejection.validatorName, rejection.validatorArgs);\n                  });\n                })));\n\n              case 5:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _singleAttrValidate(_x, _x2, _x3) {\n        return _singleAttrValidate2.apply(this, arguments);\n      }\n\n      return _singleAttrValidate;\n    }()\n    /**\n     * Prepare and invoke a custom validator.\n     *\n     * @private\n     *\n     * @param {Function} validator The custom validator.\n     * @param {string} validatorType the custom validator type (name).\n     * @param {boolean} optAttrDefined Set to true if custom validator was defined from the attribute\n     * @param {*} optValue value for attribute\n     * @param {string} optField field for attribute\n     *\n     * @returns {Promise} A promise.\n     */\n\n  }, {\n    key: \"_invokeCustomValidator\",\n    value: function () {\n      var _invokeCustomValidator2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(validator, validatorType, optAttrDefined, optValue, optField) {\n        var isAsync, validatorArity, asyncArity, errorKey, invokeArgs;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                isAsync = false;\n                validatorArity = validator.length; // check if validator is async and requires a callback\n\n                asyncArity = 1;\n                errorKey = validatorType;\n\n                if (optAttrDefined) {\n                  asyncArity = 2;\n                  invokeArgs = optValue;\n                  errorKey = optField;\n                }\n\n                if (validatorArity === asyncArity) {\n                  isAsync = true;\n                }\n\n                if (!isAsync) {\n                  _context7.next = 20;\n                  break;\n                }\n\n                _context7.prev = 7;\n\n                if (!optAttrDefined) {\n                  _context7.next = 12;\n                  break;\n                }\n\n                _context7.next = 11;\n                return promisify(validator.bind(this.modelInstance, invokeArgs))();\n\n              case 11:\n                return _context7.abrupt(\"return\", _context7.sent);\n\n              case 12:\n                _context7.next = 14;\n                return promisify(validator.bind(this.modelInstance))();\n\n              case 14:\n                return _context7.abrupt(\"return\", _context7.sent);\n\n              case 17:\n                _context7.prev = 17;\n                _context7.t0 = _context7[\"catch\"](7);\n                return _context7.abrupt(\"return\", this._pushError(false, errorKey, _context7.t0, optValue, validatorType));\n\n              case 20:\n                _context7.prev = 20;\n                _context7.next = 23;\n                return validator.call(this.modelInstance, invokeArgs);\n\n              case 23:\n                return _context7.abrupt(\"return\", _context7.sent);\n\n              case 26:\n                _context7.prev = 26;\n                _context7.t1 = _context7[\"catch\"](20);\n                return _context7.abrupt(\"return\", this._pushError(false, errorKey, _context7.t1, optValue, validatorType));\n\n              case 29:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[7, 17], [20, 26]]);\n      }));\n\n      function _invokeCustomValidator(_x4, _x5, _x6, _x7, _x8) {\n        return _invokeCustomValidator2.apply(this, arguments);\n      }\n\n      return _invokeCustomValidator;\n    }()\n    /**\n     * Prepare and invoke a build-in validator.\n     *\n     * @private\n     *\n     * @param {*} value Anything.\n     * @param {*} test The test case.\n     * @param {string} validatorType One of known to Sequelize validators.\n     * @param {string} field The field that is being validated\n     *\n     * @returns {object} An object with specific keys to invoke the validator.\n     */\n\n  }, {\n    key: \"_invokeBuiltinValidator\",\n    value: function () {\n      var _invokeBuiltinValidator2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(value, test, validatorType, field) {\n        var valueString, validatorArgs;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                // Cast value as string to pass new Validator.js string requirement\n                valueString = String(value); // check if Validator knows that kind of validation test\n\n                if (!(typeof validator[validatorType] !== 'function')) {\n                  _context8.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Invalid validator function: \".concat(validatorType));\n\n              case 3:\n                validatorArgs = this._extractValidatorArgs(test, validatorType, field);\n\n                if (validator[validatorType].apply(validator, [valueString].concat(_toConsumableArray(validatorArgs)))) {\n                  _context8.next = 6;\n                  break;\n                }\n\n                throw Object.assign(new Error(test.msg || \"Validation \".concat(validatorType, \" on \").concat(field, \" failed\")), {\n                  validatorName: validatorType,\n                  validatorArgs: validatorArgs\n                });\n\n              case 6:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function _invokeBuiltinValidator(_x9, _x10, _x11, _x12) {\n        return _invokeBuiltinValidator2.apply(this, arguments);\n      }\n\n      return _invokeBuiltinValidator;\n    }()\n    /**\n     * Will extract arguments for the validator.\n     *\n     * @param {*} test The test case.\n     * @param {string} validatorType One of known to Sequelize validators.\n     * @param {string} field The field that is being validated.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_extractValidatorArgs\",\n    value: function _extractValidatorArgs(test, validatorType, field) {\n      var validatorArgs = test.args || test;\n      var isLocalizedValidator = typeof validatorArgs !== 'string' && (validatorType === 'isAlpha' || validatorType === 'isAlphanumeric' || validatorType === 'isMobilePhone');\n\n      if (!Array.isArray(validatorArgs)) {\n        if (validatorType === 'isImmutable') {\n          validatorArgs = [validatorArgs, field, this.modelInstance];\n        } else if (isLocalizedValidator || validatorType === 'isIP') {\n          validatorArgs = [];\n        } else {\n          validatorArgs = [validatorArgs];\n        }\n      } else {\n        validatorArgs = validatorArgs.slice(0);\n      }\n\n      return validatorArgs;\n    }\n    /**\n     * Will validate a single field against its schema definition (isnull).\n     *\n     * @param {object} rawAttribute As defined in the Schema.\n     * @param {string} field The field name.\n     * @param {*} value anything.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_validateSchema\",\n    value: function _validateSchema(rawAttribute, field, value) {\n      if (rawAttribute.allowNull === false && (value === null || value === undefined)) {\n        var association = Object.values(this.modelInstance.constructor.associations).find(function (association) {\n          return association instanceof BelongsTo && association.foreignKey === rawAttribute.fieldName;\n        });\n\n        if (!association || !this.modelInstance.get(association.associationAccessor)) {\n          var validators = this.modelInstance.validators[field];\n\n          var errMsg = _.get(validators, 'notNull.msg', \"\".concat(this.modelInstance.constructor.name, \".\").concat(field, \" cannot be null\"));\n\n          this.errors.push(new sequelizeError.ValidationErrorItem(errMsg, 'notNull Violation', // sequelizeError.ValidationErrorItem.Origins.CORE,\n          field, value, this.modelInstance, 'is_null'));\n        }\n      }\n\n      if (rawAttribute.type instanceof DataTypes.STRING || rawAttribute.type instanceof DataTypes.TEXT || rawAttribute.type instanceof DataTypes.CITEXT) {\n        if (Array.isArray(value) || _.isObject(value) && !(value instanceof Utils.SequelizeMethod) && !Buffer.isBuffer(value)) {\n          this.errors.push(new sequelizeError.ValidationErrorItem(\"\".concat(field, \" cannot be an array or an object\"), 'string violation', // sequelizeError.ValidationErrorItem.Origins.CORE,\n          field, value, this.modelInstance, 'not_a_string'));\n        }\n      }\n    }\n    /**\n     * Signs all errors retaining the original.\n     *\n     * @param {boolean}       isBuiltin   - Determines if error is from builtin validator.\n     * @param {string}        errorKey    - name of invalid attribute.\n     * @param {Error|string}  rawError    - The original error.\n     * @param {string|number} value       - The data that triggered the error.\n     * @param {string}        fnName      - Name of the validator, if any\n     * @param {Array}         fnArgs      - Arguments for the validator [function], if any\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_pushError\",\n    value: function _pushError(isBuiltin, errorKey, rawError, value, fnName, fnArgs) {\n      var message = rawError.message || rawError || 'Validation error';\n      var error = new sequelizeError.ValidationErrorItem(message, 'Validation error', // sequelizeError.ValidationErrorItem.Origins.FUNCTION,\n      errorKey, value, this.modelInstance, fnName, isBuiltin ? fnName : undefined, isBuiltin ? fnArgs : undefined);\n      error[InstanceValidator.RAW_KEY_NAME] = rawError;\n      this.errors.push(error);\n    }\n  }]);\n\n  return InstanceValidator;\n}();\n/**\n * The error key for arguments as passed by custom validators\n *\n * @type {string}\n * @private\n */\n\n\nInstanceValidator.RAW_KEY_NAME = 'original';\nmodule.exports = InstanceValidator;\nmodule.exports.InstanceValidator = InstanceValidator;\nmodule.exports.default = InstanceValidator;","map":null,"metadata":{},"sourceType":"script"}