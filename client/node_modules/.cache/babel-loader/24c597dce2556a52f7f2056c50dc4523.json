{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _defineProperty = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar _ = require('lodash');\n\nvar Utils = require('../../utils');\n\nvar AbstractQuery = require('../abstract/query');\n\nvar QueryTypes = require('../../query-types');\n\nvar sequelizeErrors = require('../../errors');\n\nvar parserStore = require('../parserStore')('sqlite');\n\nvar _require = require('../../utils/logger'),\n    logger = _require.logger;\n\nvar debug = logger.debugContext('sql:sqlite');\n\nvar Query = /*#__PURE__*/function (_AbstractQuery) {\n  _inherits(Query, _AbstractQuery);\n\n  function Query() {\n    _classCallCheck(this, Query);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Query).apply(this, arguments));\n  }\n\n  _createClass(Query, [{\n    key: \"getInsertIdField\",\n    value: function getInsertIdField() {\n      return 'lastID';\n    }\n    /**\n     * rewrite query with parameters.\n     *\n     * @param {string} sql\n     * @param {Array|object} values\n     * @param {string} dialect\n     * @private\n     */\n\n  }, {\n    key: \"_collectModels\",\n    value: function _collectModels(include, prefix) {\n      var ret = {};\n\n      if (include) {\n        var _iterator = _createForOfIteratorHelper(include),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _include = _step.value;\n            var key = void 0;\n\n            if (!prefix) {\n              key = _include.as;\n            } else {\n              key = \"\".concat(prefix, \".\").concat(_include.as);\n            }\n\n            ret[key] = _include.model;\n\n            if (_include.include) {\n              _.merge(ret, this._collectModels(_include.include, key));\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"_handleQueryResponse\",\n    value: function _handleQueryResponse(metaData, columnTypes, err, results) {\n      var _this = this;\n\n      if (err) {\n        err.sql = this.sql;\n        throw this.formatError(err);\n      }\n\n      var result = this.instance; // add the inserted row id to the instance\n\n      if (this.isInsertQuery(results, metaData)) {\n        this.handleInsertQuery(results, metaData);\n\n        if (!this.instance) {\n          // handle bulkCreate AI primary key\n          if (metaData.constructor.name === 'Statement' && this.model && this.model.autoIncrementAttribute && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute && this.model.rawAttributes[this.model.primaryKeyAttribute]) {\n            var startId = metaData[this.getInsertIdField()] - metaData.changes + 1;\n            result = [];\n\n            for (var i = startId; i < startId + metaData.changes; i++) {\n              result.push(_defineProperty({}, this.model.rawAttributes[this.model.primaryKeyAttribute].field, i));\n            }\n          } else {\n            result = metaData[this.getInsertIdField()];\n          }\n        }\n      }\n\n      if (this.isShowTablesQuery()) {\n        return results.map(function (row) {\n          return row.name;\n        });\n      }\n\n      if (this.isShowConstraintsQuery()) {\n        result = results;\n\n        if (results && results[0] && results[0].sql) {\n          result = this.parseConstraintsFromSql(results[0].sql);\n        }\n\n        return result;\n      }\n\n      if (this.isSelectQuery()) {\n        if (this.options.raw) {\n          return this.handleSelectQuery(results);\n        } // This is a map of prefix strings to models, e.g. user.projects -> Project model\n\n\n        var prefixes = this._collectModels(this.options.include);\n\n        results = results.map(function (result) {\n          return _.mapValues(result, function (value, name) {\n            var model;\n\n            if (name.includes('.')) {\n              var lastind = name.lastIndexOf('.');\n              model = prefixes[name.substr(0, lastind)];\n              name = name.substr(lastind + 1);\n            } else {\n              model = _this.options.model;\n            }\n\n            var tableName = model.getTableName().toString().replace(/`/g, '');\n            var tableTypes = columnTypes[tableName] || {};\n\n            if (tableTypes && !(name in tableTypes)) {\n              // The column is aliased\n              _.forOwn(model.rawAttributes, function (attribute, key) {\n                if (name === key && attribute.field) {\n                  name = attribute.field;\n                  return false;\n                }\n              });\n            }\n\n            return Object.prototype.hasOwnProperty.call(tableTypes, name) ? _this.applyParsers(tableTypes[name], value) : value;\n          });\n        });\n        return this.handleSelectQuery(results);\n      }\n\n      if (this.isShowOrDescribeQuery()) {\n        return results;\n      }\n\n      if (this.sql.includes('PRAGMA INDEX_LIST')) {\n        return this.handleShowIndexesQuery(results);\n      }\n\n      if (this.sql.includes('PRAGMA INDEX_INFO')) {\n        return results;\n      }\n\n      if (this.sql.includes('PRAGMA TABLE_INFO')) {\n        // this is the sqlite way of getting the metadata of a table\n        result = {};\n        var defaultValue;\n\n        var _iterator2 = _createForOfIteratorHelper(results),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _result = _step2.value;\n\n            if (_result.dflt_value === null) {\n              // Column schema omits any \"DEFAULT ...\"\n              defaultValue = undefined;\n            } else if (_result.dflt_value === 'NULL') {\n              // Column schema is a \"DEFAULT NULL\"\n              defaultValue = null;\n            } else {\n              defaultValue = _result.dflt_value;\n            }\n\n            result[_result.name] = {\n              type: _result.type,\n              allowNull: _result.notnull === 0,\n              defaultValue: defaultValue,\n              primaryKey: _result.pk !== 0\n            };\n\n            if (result[_result.name].type === 'TINYINT(1)') {\n              result[_result.name].defaultValue = {\n                '0': false,\n                '1': true\n              }[result[_result.name].defaultValue];\n            }\n\n            if (typeof result[_result.name].defaultValue === 'string') {\n              result[_result.name].defaultValue = result[_result.name].defaultValue.replace(/'/g, '');\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        return result;\n      }\n\n      if (this.sql.includes('PRAGMA foreign_keys;')) {\n        return results[0];\n      }\n\n      if (this.sql.includes('PRAGMA foreign_keys')) {\n        return results;\n      }\n\n      if (this.sql.includes('PRAGMA foreign_key_list')) {\n        return results;\n      }\n\n      if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].includes(this.options.type)) {\n        return metaData.changes;\n      }\n\n      if (this.options.type === QueryTypes.VERSION) {\n        return results[0].version;\n      }\n\n      if (this.options.type === QueryTypes.RAW) {\n        return [results, metaData];\n      }\n\n      if (this.isUpsertQuery()) {\n        return [result, null];\n      }\n\n      if (this.isUpdateQuery() || this.isInsertQuery()) {\n        return [result, metaData.changes];\n      }\n\n      return result;\n    }\n  }, {\n    key: \"run\",\n    value: function () {\n      var _run = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(sql, parameters) {\n        var _this2 = this;\n\n        var conn, method, complete;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                conn = this.connection;\n                this.sql = sql;\n                method = this.getDatabaseMethod();\n\n                if (method === 'exec') {\n                  // exec does not support bind parameter\n                  sql = AbstractQuery.formatBindParameters(sql, this.options.bind, this.options.dialect || 'sqlite', {\n                    skipUnescape: true\n                  })[0];\n                  this.sql = sql;\n                  complete = this._logQuery(sql, debug);\n                } else {\n                  complete = this._logQuery(sql, debug, parameters);\n                }\n\n                return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  return conn.serialize( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                    var columnTypes, executeSql, tableNames;\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            columnTypes = {};\n\n                            executeSql = function executeSql() {\n                              if (sql.startsWith('-- ')) {\n                                return resolve();\n                              }\n\n                              var query = _this2; // cannot use arrow function here because the function is bound to the statement\n\n                              function afterExecute(executionError, results) {\n                                try {\n                                  complete(); // `this` is passed from sqlite, we have no control over this.\n                                  // eslint-disable-next-line no-invalid-this\n\n                                  resolve(query._handleQueryResponse(this, columnTypes, executionError, results));\n                                  return;\n                                } catch (error) {\n                                  reject(error);\n                                }\n                              }\n\n                              if (method === 'exec') {\n                                // exec does not support bind parameter\n                                conn[method](sql, afterExecute);\n                              } else {\n                                if (!parameters) parameters = [];\n                                conn[method](sql, parameters, afterExecute);\n                              }\n\n                              return null;\n                            };\n\n                            if (!(_this2.getDatabaseMethod() === 'all')) {\n                              _context.next = 10;\n                              break;\n                            }\n\n                            tableNames = [];\n\n                            if (_this2.options && _this2.options.tableNames) {\n                              tableNames = _this2.options.tableNames;\n                            } else if (/FROM `(.*?)`/i.exec(_this2.sql)) {\n                              tableNames.push(/FROM `(.*?)`/i.exec(_this2.sql)[1]);\n                            } // If we already have the metadata for the table, there's no need to ask for it again\n\n\n                            tableNames = tableNames.filter(function (tableName) {\n                              return !(tableName in columnTypes) && tableName !== 'sqlite_master';\n                            });\n\n                            if (tableNames.length) {\n                              _context.next = 8;\n                              break;\n                            }\n\n                            return _context.abrupt(\"return\", executeSql());\n\n                          case 8:\n                            _context.next = 10;\n                            return Promise.all(tableNames.map(function (tableName) {\n                              return new Promise(function (resolve) {\n                                tableName = tableName.replace(/`/g, '');\n                                columnTypes[tableName] = {};\n                                conn.all(\"PRAGMA table_info(`\".concat(tableName, \"`)\"), function (err, results) {\n                                  if (!err) {\n                                    var _iterator3 = _createForOfIteratorHelper(results),\n                                        _step3;\n\n                                    try {\n                                      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                                        var result = _step3.value;\n                                        columnTypes[tableName][result.name] = result.type;\n                                      }\n                                    } catch (err) {\n                                      _iterator3.e(err);\n                                    } finally {\n                                      _iterator3.f();\n                                    }\n                                  }\n\n                                  resolve();\n                                });\n                              });\n                            }));\n\n                          case 10:\n                            return _context.abrupt(\"return\", executeSql());\n\n                          case 11:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  })));\n                }));\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function run(_x, _x2) {\n        return _run.apply(this, arguments);\n      }\n\n      return run;\n    }()\n  }, {\n    key: \"parseConstraintsFromSql\",\n    value: function parseConstraintsFromSql(sql) {\n      var constraints = sql.split('CONSTRAINT ');\n      var referenceTableName, referenceTableKeys, updateAction, deleteAction;\n      constraints.splice(0, 1);\n      constraints = constraints.map(function (constraintSql) {\n        //Parse foreign key snippets\n        if (constraintSql.includes('REFERENCES')) {\n          //Parse out the constraint condition form sql string\n          updateAction = constraintSql.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n          deleteAction = constraintSql.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n\n          if (updateAction) {\n            updateAction = updateAction[1];\n          }\n\n          if (deleteAction) {\n            deleteAction = deleteAction[1];\n          }\n\n          var referencesRegex = /REFERENCES.+\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/;\n          var referenceConditions = constraintSql.match(referencesRegex)[0].split(' ');\n          referenceTableName = Utils.removeTicks(referenceConditions[1]);\n          var columnNames = referenceConditions[2];\n          columnNames = columnNames.replace(/\\(|\\)/g, '').split(', ');\n          referenceTableKeys = columnNames.map(function (column) {\n            return Utils.removeTicks(column);\n          });\n        }\n\n        var constraintCondition = constraintSql.match(/\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/)[0];\n        constraintSql = constraintSql.replace(/\\(.+\\)/, '');\n        var constraint = constraintSql.split(' ');\n\n        if (constraint[1] === 'PRIMARY' || constraint[1] === 'FOREIGN') {\n          constraint[1] += ' KEY';\n        }\n\n        return {\n          constraintName: Utils.removeTicks(constraint[0]),\n          constraintType: constraint[1],\n          updateAction: updateAction,\n          deleteAction: deleteAction,\n          sql: sql.replace(/\"/g, '`'),\n          //Sqlite returns double quotes for table name\n          constraintCondition: constraintCondition,\n          referenceTableName: referenceTableName,\n          referenceTableKeys: referenceTableKeys\n        };\n      });\n      return constraints;\n    }\n  }, {\n    key: \"applyParsers\",\n    value: function applyParsers(type, value) {\n      if (type.includes('(')) {\n        // Remove the length part\n        type = type.substr(0, type.indexOf('('));\n      }\n\n      type = type.replace('UNSIGNED', '').replace('ZEROFILL', '');\n      type = type.trim().toUpperCase();\n      var parse = parserStore.get(type);\n\n      if (value !== null && parse) {\n        return parse(value, {\n          timezone: this.sequelize.options.timezone\n        });\n      }\n\n      return value;\n    }\n  }, {\n    key: \"formatError\",\n    value: function formatError(err) {\n      switch (err.code) {\n        case 'SQLITE_CONSTRAINT':\n          {\n            if (err.message.includes('FOREIGN KEY constraint failed')) {\n              return new sequelizeErrors.ForeignKeyConstraintError({\n                parent: err\n              });\n            }\n\n            var fields = []; // Sqlite pre 2.2 behavior - Error: SQLITE_CONSTRAINT: columns x, y are not unique\n\n            var match = err.message.match(/columns (.*?) are/);\n\n            if (match !== null && match.length >= 2) {\n              fields = match[1].split(', ');\n            } else {\n              // Sqlite post 2.2 behavior - Error: SQLITE_CONSTRAINT: UNIQUE constraint failed: table.x, table.y\n              match = err.message.match(/UNIQUE constraint failed: (.*)/);\n\n              if (match !== null && match.length >= 2) {\n                fields = match[1].split(', ').map(function (columnWithTable) {\n                  return columnWithTable.split('.')[1];\n                });\n              }\n            }\n\n            var errors = [];\n            var message = 'Validation error';\n\n            var _iterator4 = _createForOfIteratorHelper(fields),\n                _step4;\n\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                var field = _step4.value;\n                errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), 'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,\n                field, this.instance && this.instance[field], this.instance, 'not_unique'));\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n\n            if (this.model) {\n              _.forOwn(this.model.uniqueKeys, function (constraint) {\n                if (_.isEqual(constraint.fields, fields) && !!constraint.msg) {\n                  message = constraint.msg;\n                  return false;\n                }\n              });\n            }\n\n            return new sequelizeErrors.UniqueConstraintError({\n              message: message,\n              errors: errors,\n              parent: err,\n              fields: fields\n            });\n          }\n\n        case 'SQLITE_BUSY':\n          return new sequelizeErrors.TimeoutError(err);\n\n        default:\n          return new sequelizeErrors.DatabaseError(err);\n      }\n    }\n  }, {\n    key: \"handleShowIndexesQuery\",\n    value: function () {\n      var _handleShowIndexesQuery = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(data) {\n        var _this3 = this;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt(\"return\", Promise.all(data.reverse().map( /*#__PURE__*/function () {\n                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(item) {\n                    var columns, _iterator5, _step5, column;\n\n                    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                      while (1) {\n                        switch (_context3.prev = _context3.next) {\n                          case 0:\n                            item.fields = [];\n                            item.primary = false;\n                            item.unique = !!item.unique;\n                            item.constraintName = item.name;\n                            _context3.next = 6;\n                            return _this3.run(\"PRAGMA INDEX_INFO(`\".concat(item.name, \"`)\"));\n\n                          case 6:\n                            columns = _context3.sent;\n                            _iterator5 = _createForOfIteratorHelper(columns);\n\n                            try {\n                              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                                column = _step5.value;\n                                item.fields[column.seqno] = {\n                                  attribute: column.name,\n                                  length: undefined,\n                                  order: undefined\n                                };\n                              }\n                            } catch (err) {\n                              _iterator5.e(err);\n                            } finally {\n                              _iterator5.f();\n                            }\n\n                            return _context3.abrupt(\"return\", item);\n\n                          case 10:\n                          case \"end\":\n                            return _context3.stop();\n                        }\n                      }\n                    }, _callee3);\n                  }));\n\n                  return function (_x4) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }())));\n\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function handleShowIndexesQuery(_x3) {\n        return _handleShowIndexesQuery.apply(this, arguments);\n      }\n\n      return handleShowIndexesQuery;\n    }()\n  }, {\n    key: \"getDatabaseMethod\",\n    value: function getDatabaseMethod() {\n      if (this.isUpsertQuery()) {\n        return 'exec'; // Needed to run multiple queries in one\n      }\n\n      if (this.isInsertQuery() || this.isUpdateQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes('CREATE TEMPORARY TABLE'.toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {\n        return 'run';\n      }\n\n      return 'all';\n    }\n  }], [{\n    key: \"formatBindParameters\",\n    value: function formatBindParameters(sql, values, dialect) {\n      var bindParam;\n\n      if (Array.isArray(values)) {\n        bindParam = {};\n        values.forEach(function (v, i) {\n          bindParam[\"$\".concat(i + 1)] = v;\n        });\n        sql = AbstractQuery.formatBindParameters(sql, values, dialect, {\n          skipValueReplace: true\n        })[0];\n      } else {\n        bindParam = {};\n\n        if (typeof values === 'object') {\n          for (var _i = 0, _Object$keys = Object.keys(values); _i < _Object$keys.length; _i++) {\n            var k = _Object$keys[_i];\n            bindParam[\"$\".concat(k)] = values[k];\n          }\n        }\n\n        sql = AbstractQuery.formatBindParameters(sql, values, dialect, {\n          skipValueReplace: true\n        })[0];\n      }\n\n      return [sql, bindParam];\n    }\n  }]);\n\n  return Query;\n}(AbstractQuery);\n\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;","map":null,"metadata":{},"sourceType":"script"}