{"ast":null,"code":"'use strict';\n\nvar inherits = require('util').inherits;\n\nvar glob = require('glob');\n\nvar extend = require('extend');\n\nvar Readable = require('readable-stream').Readable;\n\nvar globParent = require('glob-parent');\n\nvar toAbsoluteGlob = require('to-absolute-glob');\n\nvar removeTrailingSeparator = require('remove-trailing-separator');\n\nvar globErrMessage1 = 'File not found with singular glob: ';\nvar globErrMessage2 = ' (if this was purposeful, use `allowEmpty` option)';\n\nfunction getBasePath(ourGlob, opt) {\n  return globParent(toAbsoluteGlob(ourGlob, opt));\n}\n\nfunction globIsSingular(glob) {\n  var globSet = glob.minimatch.set;\n\n  if (globSet.length !== 1) {\n    return false;\n  }\n\n  return globSet[0].every(function isString(value) {\n    return typeof value === 'string';\n  });\n}\n\nfunction GlobStream(ourGlob, negatives, opt) {\n  if (!(this instanceof GlobStream)) {\n    return new GlobStream(ourGlob, negatives, opt);\n  }\n\n  var ourOpt = extend({}, opt);\n  Readable.call(this, {\n    objectMode: true,\n    highWaterMark: ourOpt.highWaterMark || 16\n  }); // Delete `highWaterMark` after inheriting from Readable\n\n  delete ourOpt.highWaterMark;\n  var self = this;\n\n  function resolveNegatives(negative) {\n    return toAbsoluteGlob(negative, ourOpt);\n  }\n\n  var ourNegatives = negatives.map(resolveNegatives);\n  ourOpt.ignore = ourNegatives;\n  var cwd = ourOpt.cwd;\n  var allowEmpty = ourOpt.allowEmpty || false; // Extract base path from glob\n\n  var basePath = ourOpt.base || getBasePath(ourGlob, ourOpt); // Remove path relativity to make globs make sense\n\n  ourGlob = toAbsoluteGlob(ourGlob, ourOpt); // Delete `root` after all resolving done\n\n  delete ourOpt.root;\n  var globber = new glob.Glob(ourGlob, ourOpt);\n  this._globber = globber;\n  var found = false;\n  globber.on('match', function (filepath) {\n    found = true;\n    var obj = {\n      cwd: cwd,\n      base: basePath,\n      path: removeTrailingSeparator(filepath)\n    };\n\n    if (!self.push(obj)) {\n      globber.pause();\n    }\n  });\n  globber.once('end', function () {\n    if (allowEmpty !== true && !found && globIsSingular(globber)) {\n      var err = new Error(globErrMessage1 + ourGlob + globErrMessage2);\n      return self.destroy(err);\n    }\n\n    self.push(null);\n  });\n\n  function onError(err) {\n    self.destroy(err);\n  }\n\n  globber.once('error', onError);\n}\n\ninherits(GlobStream, Readable);\n\nGlobStream.prototype._read = function () {\n  this._globber.resume();\n};\n\nGlobStream.prototype.destroy = function (err) {\n  var self = this;\n\n  this._globber.abort();\n\n  process.nextTick(function () {\n    if (err) {\n      self.emit('error', err);\n    }\n\n    self.emit('close');\n  });\n};\n\nmodule.exports = GlobStream;","map":null,"metadata":{},"sourceType":"script"}