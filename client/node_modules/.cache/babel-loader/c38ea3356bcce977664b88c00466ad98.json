{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('sequelize-pool'),\n    Pool = _require.Pool,\n    TimeoutError = _require.TimeoutError;\n\nvar _ = require('lodash');\n\nvar semver = require('semver');\n\nvar errors = require('../../errors');\n\nvar _require2 = require('../../utils/logger'),\n    logger = _require2.logger;\n\nvar deprecations = require('../../utils/deprecations');\n\nvar debug = logger.debugContext('pool');\n/**\n * Abstract Connection Manager\n *\n * Connection manager which handles pooling & replication.\n * Uses sequelize-pool for pooling\n *\n * @private\n */\n\nvar ConnectionManager = /*#__PURE__*/function () {\n  function ConnectionManager(dialect, sequelize) {\n    _classCallCheck(this, ConnectionManager);\n\n    var config = _.cloneDeep(sequelize.config);\n\n    this.sequelize = sequelize;\n    this.config = config;\n    this.dialect = dialect;\n    this.versionPromise = null;\n    this.dialectName = this.sequelize.options.dialect;\n\n    if (config.pool === false) {\n      throw new Error('Support for pool:false was removed in v4.0');\n    }\n\n    config.pool = _.defaults(config.pool || {}, {\n      max: 5,\n      min: 0,\n      idle: 10000,\n      acquire: 60000,\n      evict: 1000,\n      validate: this._validate.bind(this)\n    });\n    this.initPools();\n  }\n\n  _createClass(ConnectionManager, [{\n    key: \"refreshTypeParser\",\n    value: function refreshTypeParser(dataTypes) {\n      var _this = this;\n\n      _.each(dataTypes, function (dataType) {\n        if (Object.prototype.hasOwnProperty.call(dataType, 'parse')) {\n          if (dataType.types[_this.dialectName]) {\n            _this._refreshTypeParser(dataType);\n          } else {\n            throw new Error(\"Parse function not supported for type \".concat(dataType.key, \" in dialect \").concat(_this.dialectName));\n          }\n        }\n      });\n    }\n    /**\n     * Try to load dialect module from various configured options.\n     * Priority goes like dialectModulePath > dialectModule > require(default)\n     *\n     * @param {string} moduleName Name of dialect module to lookup\n     *\n     * @private\n     * @returns {object}\n     */\n\n  }, {\n    key: \"_loadDialectModule\",\n    value: function _loadDialectModule(moduleName) {\n      try {\n        if (this.sequelize.config.dialectModulePath) {\n          return require(this.sequelize.config.dialectModulePath);\n        }\n\n        if (this.sequelize.config.dialectModule) {\n          return this.sequelize.config.dialectModule;\n        }\n\n        return require(moduleName);\n      } catch (err) {\n        if (err.code === 'MODULE_NOT_FOUND') {\n          if (this.sequelize.config.dialectModulePath) {\n            throw new Error(\"Unable to find dialect at \".concat(this.sequelize.config.dialectModulePath));\n          }\n\n          throw new Error(\"Please install \".concat(moduleName, \" package manually\"));\n        }\n\n        throw err;\n      }\n    }\n    /**\n     * Handler which executes on process exit or connection manager shutdown\n     *\n     * @private\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"_onProcessExit\",\n    value: function () {\n      var _onProcessExit2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.pool) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 2:\n                _context.next = 4;\n                return this.pool.drain();\n\n              case 4:\n                debug('connection drain due to process exit');\n                _context.next = 7;\n                return this.pool.destroyAllNow();\n\n              case 7:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _onProcessExit() {\n        return _onProcessExit2.apply(this, arguments);\n      }\n\n      return _onProcessExit;\n    }()\n    /**\n     * Drain the pool and close it permanently\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                // Mark close of pool\n                this.getConnection = /*#__PURE__*/function () {\n                  var _getConnection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n                    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            throw new Error('ConnectionManager.getConnection was called after the connection manager was closed!');\n\n                          case 1:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee2);\n                  }));\n\n                  function getConnection() {\n                    return _getConnection.apply(this, arguments);\n                  }\n\n                  return getConnection;\n                }();\n\n                _context3.next = 3;\n                return this._onProcessExit();\n\n              case 3:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n    /**\n     * Initialize connection pool. By default pool autostart is set to false, so no connection will be\n     * be created unless `pool.acquire` is called.\n     */\n\n  }, {\n    key: \"initPools\",\n    value: function initPools() {\n      var _this2 = this;\n\n      var config = this.config;\n\n      if (!config.replication) {\n        this.pool = new Pool({\n          name: 'sequelize',\n          create: function create() {\n            return _this2._connect(config);\n          },\n          destroy: function () {\n            var _destroy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(connection) {\n              var result;\n              return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                while (1) {\n                  switch (_context4.prev = _context4.next) {\n                    case 0:\n                      _context4.next = 2;\n                      return _this2._disconnect(connection);\n\n                    case 2:\n                      result = _context4.sent;\n                      debug('connection destroy');\n                      return _context4.abrupt(\"return\", result);\n\n                    case 5:\n                    case \"end\":\n                      return _context4.stop();\n                  }\n                }\n              }, _callee4);\n            }));\n\n            function destroy(_x) {\n              return _destroy.apply(this, arguments);\n            }\n\n            return destroy;\n          }(),\n          validate: config.pool.validate,\n          max: config.pool.max,\n          min: config.pool.min,\n          acquireTimeoutMillis: config.pool.acquire,\n          idleTimeoutMillis: config.pool.idle,\n          reapIntervalMillis: config.pool.evict,\n          maxUses: config.pool.maxUses\n        });\n        debug(\"pool created with max/min: \".concat(config.pool.max, \"/\").concat(config.pool.min, \", no replication\"));\n        return;\n      }\n\n      if (!Array.isArray(config.replication.read)) {\n        config.replication.read = [config.replication.read];\n      } // Map main connection config\n\n\n      config.replication.write = _.defaults(config.replication.write, _.omit(config, 'replication')); // Apply defaults to each read config\n\n      config.replication.read = config.replication.read.map(function (readConfig) {\n        return _.defaults(readConfig, _.omit(_this2.config, 'replication'));\n      }); // custom pooling for replication (original author @janmeier)\n\n      var reads = 0;\n      this.pool = {\n        release: function release(client) {\n          if (client.queryType === 'read') {\n            _this2.pool.read.release(client);\n          } else {\n            _this2.pool.write.release(client);\n          }\n        },\n        acquire: function acquire(queryType, useMaster) {\n          useMaster = useMaster === undefined ? false : useMaster;\n\n          if (queryType === 'SELECT' && !useMaster) {\n            return _this2.pool.read.acquire();\n          }\n\n          return _this2.pool.write.acquire();\n        },\n        destroy: function destroy(connection) {\n          _this2.pool[connection.queryType].destroy(connection);\n\n          debug('connection destroy');\n        },\n        destroyAllNow: function () {\n          var _destroyAllNow = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n            return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n              while (1) {\n                switch (_context5.prev = _context5.next) {\n                  case 0:\n                    _context5.next = 2;\n                    return Promise.all([_this2.pool.read.destroyAllNow(), _this2.pool.write.destroyAllNow()]);\n\n                  case 2:\n                    debug('all connections destroyed');\n\n                  case 3:\n                  case \"end\":\n                    return _context5.stop();\n                }\n              }\n            }, _callee5);\n          }));\n\n          function destroyAllNow() {\n            return _destroyAllNow.apply(this, arguments);\n          }\n\n          return destroyAllNow;\n        }(),\n        drain: function () {\n          var _drain = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n            return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n              while (1) {\n                switch (_context6.prev = _context6.next) {\n                  case 0:\n                    return _context6.abrupt(\"return\", Promise.all([_this2.pool.write.drain(), _this2.pool.read.drain()]));\n\n                  case 1:\n                  case \"end\":\n                    return _context6.stop();\n                }\n              }\n            }, _callee6);\n          }));\n\n          function drain() {\n            return _drain.apply(this, arguments);\n          }\n\n          return drain;\n        }(),\n        read: new Pool({\n          name: 'sequelize:read',\n          create: function () {\n            var _create = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n              var nextRead, connection;\n              return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n                while (1) {\n                  switch (_context7.prev = _context7.next) {\n                    case 0:\n                      // round robin config\n                      nextRead = reads++ % config.replication.read.length;\n                      _context7.next = 3;\n                      return _this2._connect(config.replication.read[nextRead]);\n\n                    case 3:\n                      connection = _context7.sent;\n                      connection.queryType = 'read';\n                      return _context7.abrupt(\"return\", connection);\n\n                    case 6:\n                    case \"end\":\n                      return _context7.stop();\n                  }\n                }\n              }, _callee7);\n            }));\n\n            function create() {\n              return _create.apply(this, arguments);\n            }\n\n            return create;\n          }(),\n          destroy: function destroy(connection) {\n            return _this2._disconnect(connection);\n          },\n          validate: config.pool.validate,\n          max: config.pool.max,\n          min: config.pool.min,\n          acquireTimeoutMillis: config.pool.acquire,\n          idleTimeoutMillis: config.pool.idle,\n          reapIntervalMillis: config.pool.evict,\n          maxUses: config.pool.maxUses\n        }),\n        write: new Pool({\n          name: 'sequelize:write',\n          create: function () {\n            var _create2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n              var connection;\n              return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n                while (1) {\n                  switch (_context8.prev = _context8.next) {\n                    case 0:\n                      _context8.next = 2;\n                      return _this2._connect(config.replication.write);\n\n                    case 2:\n                      connection = _context8.sent;\n                      connection.queryType = 'write';\n                      return _context8.abrupt(\"return\", connection);\n\n                    case 5:\n                    case \"end\":\n                      return _context8.stop();\n                  }\n                }\n              }, _callee8);\n            }));\n\n            function create() {\n              return _create2.apply(this, arguments);\n            }\n\n            return create;\n          }(),\n          destroy: function destroy(connection) {\n            return _this2._disconnect(connection);\n          },\n          validate: config.pool.validate,\n          max: config.pool.max,\n          min: config.pool.min,\n          acquireTimeoutMillis: config.pool.acquire,\n          idleTimeoutMillis: config.pool.idle,\n          reapIntervalMillis: config.pool.evict,\n          maxUses: config.pool.maxUses\n        })\n      };\n      debug(\"pool created with max/min: \".concat(config.pool.max, \"/\").concat(config.pool.min, \", with replication\"));\n    }\n    /**\n     * Get connection from pool. It sets database version if it's not already set.\n     * Call pool.acquire to get a connection\n     *\n     * @param {object}   [options]                 Pool options\n     * @param {string}   [options.type]            Set which replica to use. Available options are `read` and `write`\n     * @param {boolean}  [options.useMaster=false] Force master or write replica to get connection from\n     *\n     * @returns {Promise<Connection>}\n     */\n\n  }, {\n    key: \"getConnection\",\n    value: function () {\n      var _getConnection2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(options) {\n        var _this3 = this;\n\n        var result;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                options = options || {};\n\n                if (!(this.sequelize.options.databaseVersion === 0)) {\n                  _context10.next = 5;\n                  break;\n                }\n\n                if (!this.versionPromise) {\n                  this.versionPromise = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n                    var connection, _options, version, parsedVersion;\n\n                    return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n                      while (1) {\n                        switch (_context9.prev = _context9.next) {\n                          case 0:\n                            _context9.prev = 0;\n                            _context9.next = 3;\n                            return _this3._connect(_this3.config.replication.write || _this3.config);\n\n                          case 3:\n                            connection = _context9.sent;\n                            _options = {};\n                            _options.transaction = {\n                              connection: connection\n                            }; // Cheat .query to use our private connection\n\n                            _options.logging = function () {};\n\n                            _options.logging.__testLoggingFn = true; //connection might have set databaseVersion value at initialization,\n                            //avoiding a useless round trip\n\n                            if (!(_this3.sequelize.options.databaseVersion === 0)) {\n                              _context9.next = 14;\n                              break;\n                            }\n\n                            _context9.next = 11;\n                            return _this3.sequelize.databaseVersion(_options);\n\n                          case 11:\n                            version = _context9.sent;\n                            parsedVersion = _.get(semver.coerce(version), 'version') || version;\n                            _this3.sequelize.options.databaseVersion = semver.valid(parsedVersion) ? parsedVersion : _this3.dialect.defaultVersion;\n\n                          case 14:\n                            if (semver.lt(_this3.sequelize.options.databaseVersion, _this3.dialect.defaultVersion)) {\n                              deprecations.unsupportedEngine();\n                              debug(\"Unsupported database engine version \".concat(_this3.sequelize.options.databaseVersion));\n                            }\n\n                            _this3.versionPromise = null;\n                            _context9.next = 18;\n                            return _this3._disconnect(connection);\n\n                          case 18:\n                            return _context9.abrupt(\"return\", _context9.sent);\n\n                          case 21:\n                            _context9.prev = 21;\n                            _context9.t0 = _context9[\"catch\"](0);\n                            _this3.versionPromise = null;\n                            throw _context9.t0;\n\n                          case 25:\n                          case \"end\":\n                            return _context9.stop();\n                        }\n                      }\n                    }, _callee9, null, [[0, 21]]);\n                  }))();\n                }\n\n                _context10.next = 5;\n                return this.versionPromise;\n\n              case 5:\n                _context10.prev = 5;\n                _context10.next = 8;\n                return this.pool.acquire(options.type, options.useMaster);\n\n              case 8:\n                result = _context10.sent;\n                _context10.next = 16;\n                break;\n\n              case 11:\n                _context10.prev = 11;\n                _context10.t0 = _context10[\"catch\"](5);\n\n                if (!(_context10.t0 instanceof TimeoutError)) {\n                  _context10.next = 15;\n                  break;\n                }\n\n                throw new errors.ConnectionAcquireTimeoutError(_context10.t0);\n\n              case 15:\n                throw _context10.t0;\n\n              case 16:\n                debug('connection acquired');\n                return _context10.abrupt(\"return\", result);\n\n              case 18:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[5, 11]]);\n      }));\n\n      function getConnection(_x2) {\n        return _getConnection2.apply(this, arguments);\n      }\n\n      return getConnection;\n    }()\n    /**\n     * Release a pooled connection so it can be utilized by other connection requests\n     *\n     * @param {Connection} connection\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"releaseConnection\",\n    value: function () {\n      var _releaseConnection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(connection) {\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                this.pool.release(connection);\n                debug('connection released');\n\n              case 2:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function releaseConnection(_x3) {\n        return _releaseConnection.apply(this, arguments);\n      }\n\n      return releaseConnection;\n    }()\n    /**\n     * Call dialect library to get connection\n     *\n     * @param {*} config Connection config\n     * @private\n     * @returns {Promise<Connection>}\n     */\n\n  }, {\n    key: \"_connect\",\n    value: function () {\n      var _connect2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(config) {\n        var connection;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.next = 2;\n                return this.sequelize.runHooks('beforeConnect', config);\n\n              case 2:\n                _context12.next = 4;\n                return this.dialect.connectionManager.connect(config);\n\n              case 4:\n                connection = _context12.sent;\n                _context12.next = 7;\n                return this.sequelize.runHooks('afterConnect', connection, config);\n\n              case 7:\n                return _context12.abrupt(\"return\", connection);\n\n              case 8:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function _connect(_x4) {\n        return _connect2.apply(this, arguments);\n      }\n\n      return _connect;\n    }()\n    /**\n     * Call dialect library to disconnect a connection\n     *\n     * @param {Connection} connection\n     * @private\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"_disconnect\",\n    value: function () {\n      var _disconnect2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(connection) {\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.next = 2;\n                return this.sequelize.runHooks('beforeDisconnect', connection);\n\n              case 2:\n                _context13.next = 4;\n                return this.dialect.connectionManager.disconnect(connection);\n\n              case 4:\n                return _context13.abrupt(\"return\", this.sequelize.runHooks('afterDisconnect', connection));\n\n              case 5:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function _disconnect(_x5) {\n        return _disconnect2.apply(this, arguments);\n      }\n\n      return _disconnect;\n    }()\n    /**\n     * Determine if a connection is still valid or not\n     *\n     * @param {Connection} connection\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"_validate\",\n    value: function _validate(connection) {\n      if (!this.dialect.connectionManager.validate) {\n        return true;\n      }\n\n      return this.dialect.connectionManager.validate(connection);\n    }\n  }]);\n\n  return ConnectionManager;\n}();\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":null,"metadata":{},"sourceType":"script"}