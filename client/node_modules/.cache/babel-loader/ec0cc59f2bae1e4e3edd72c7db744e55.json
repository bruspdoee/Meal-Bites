{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar Command = require('./command.js');\n\nvar Packets = require('../packets/index.js');\n\nvar ClientConstants = require('../constants/client.js');\n\nvar CharsetToEncoding = require('../constants/charset_encodings.js');\n\nvar auth41 = require('../auth_41.js');\n\nfunction flagNames(flags) {\n  var res = [];\n\n  for (var c in ClientConstants) {\n    if (flags & ClientConstants[c]) {\n      res.push(c.replace(/_/g, ' ').toLowerCase());\n    }\n  }\n\n  return res;\n}\n\nvar ClientHandshake = /*#__PURE__*/function (_Command) {\n  _inherits(ClientHandshake, _Command);\n\n  function ClientHandshake(clientFlags) {\n    var _this;\n\n    _classCallCheck(this, ClientHandshake);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ClientHandshake).call(this));\n    _this.handshake = null;\n    _this.clientFlags = clientFlags;\n    return _this;\n  }\n\n  _createClass(ClientHandshake, [{\n    key: \"start\",\n    value: function start() {\n      return ClientHandshake.prototype.handshakeInit;\n    }\n  }, {\n    key: \"sendSSLRequest\",\n    value: function sendSSLRequest(connection) {\n      var sslRequest = new Packets.SSLRequest(this.clientFlags, connection.config.charsetNumber);\n      connection.writePacket(sslRequest.toPacket());\n    }\n  }, {\n    key: \"sendCredentials\",\n    value: function sendCredentials(connection) {\n      if (connection.config.debug) {\n        // eslint-disable-next-line\n        console.log('Sending handshake packet: flags:%d=(%s)', this.clientFlags, flagNames(this.clientFlags).join(', '));\n      }\n\n      this.user = connection.config.user;\n      this.password = connection.config.password;\n      this.passwordSha1 = connection.config.passwordSha1;\n      this.database = connection.config.database;\n      this.autPluginName = this.handshake.autPluginName;\n      var handshakeResponse = new Packets.HandshakeResponse({\n        flags: this.clientFlags,\n        user: this.user,\n        database: this.database,\n        password: this.password,\n        passwordSha1: this.passwordSha1,\n        charsetNumber: connection.config.charsetNumber,\n        authPluginData1: this.handshake.authPluginData1,\n        authPluginData2: this.handshake.authPluginData2,\n        compress: connection.config.compress,\n        connectAttributes: connection.config.connectAttributes\n      });\n      connection.writePacket(handshakeResponse.toPacket());\n    }\n  }, {\n    key: \"calculateNativePasswordAuthToken\",\n    value: function calculateNativePasswordAuthToken(authPluginData) {\n      // TODO: dont split into authPluginData1 and authPluginData2, instead join when 1 & 2 received\n      var authPluginData1 = authPluginData.slice(0, 8);\n      var authPluginData2 = authPluginData.slice(8, 20);\n      var authToken;\n\n      if (this.passwordSha1) {\n        authToken = auth41.calculateTokenFromPasswordSha(this.passwordSha1, authPluginData1, authPluginData2);\n      } else {\n        authToken = auth41.calculateToken(this.password, authPluginData1, authPluginData2);\n      }\n\n      return authToken;\n    }\n  }, {\n    key: \"handshakeInit\",\n    value: function handshakeInit(helloPacket, connection) {\n      var _this2 = this;\n\n      this.on('error', function (e) {\n        connection._fatalError = e;\n        connection._protocolError = e;\n      });\n      this.handshake = Packets.Handshake.fromPacket(helloPacket);\n\n      if (connection.config.debug) {\n        // eslint-disable-next-line\n        console.log('Server hello packet: capability flags:%d=(%s)', this.handshake.capabilityFlags, flagNames(this.handshake.capabilityFlags).join(', '));\n      }\n\n      connection.serverCapabilityFlags = this.handshake.capabilityFlags;\n      connection.serverEncoding = CharsetToEncoding[this.handshake.characterSet];\n      connection.connectionId = this.handshake.connectionId;\n      var serverSSLSupport = this.handshake.capabilityFlags & ClientConstants.SSL; // use compression only if requested by client and supported by server\n\n      connection.config.compress = connection.config.compress && this.handshake.capabilityFlags & ClientConstants.COMPRESS;\n      this.clientFlags = this.clientFlags | connection.config.compress;\n\n      if (connection.config.ssl) {\n        // client requires SSL but server does not support it\n        if (!serverSSLSupport) {\n          var err = new Error('Server does not support secure connnection');\n          err.code = 'HANDSHAKE_NO_SSL_SUPPORT';\n          err.fatal = true;\n          this.emit('error', err);\n          return false;\n        } // send ssl upgrade request and immediately upgrade connection to secure\n\n\n        this.clientFlags |= ClientConstants.SSL;\n        this.sendSSLRequest(connection);\n        connection.startTLS(function (err) {\n          // after connection is secure\n          if (err) {\n            // SSL negotiation error are fatal\n            err.code = 'HANDSHAKE_SSL_ERROR';\n            err.fatal = true;\n\n            _this2.emit('error', err);\n\n            return;\n          } // rest of communication is encrypted\n\n\n          _this2.sendCredentials(connection);\n        });\n      } else {\n        this.sendCredentials(connection);\n      }\n\n      return ClientHandshake.prototype.handshakeResult;\n    }\n  }, {\n    key: \"handshakeResult\",\n    value: function handshakeResult(packet, connection) {\n      var marker = packet.peekByte();\n\n      if (marker === 0xfe || marker === 1) {\n        var authSwitch = require('./auth_switch');\n\n        try {\n          if (marker === 1) {\n            authSwitch.authSwitchRequestMoreData(packet, connection, this);\n          } else {\n            authSwitch.authSwitchRequest(packet, connection, this);\n          }\n\n          return ClientHandshake.prototype.handshakeResult;\n        } catch (err) {\n          if (this.onResult) {\n            this.onResult(err);\n          } else {\n            connection.emit('error', err);\n          }\n\n          return null;\n        }\n      }\n\n      if (marker !== 0) {\n        var err = new Error('Unexpected packet during handshake phase');\n\n        if (this.onResult) {\n          this.onResult(err);\n        } else {\n          connection.emit('error', err);\n        }\n\n        return null;\n      } // this should be called from ClientHandshake command only\n      // and skipped when called from ChangeUser command\n\n\n      if (!connection.authorized) {\n        connection.authorized = true;\n\n        if (connection.config.compress) {\n          var enableCompression = require('../compressed_protocol.js').enableCompression;\n\n          enableCompression(connection);\n        }\n      }\n\n      if (this.onResult) {\n        this.onResult(null);\n      }\n\n      return null;\n    }\n  }]);\n\n  return ClientHandshake;\n}(Command);\n\nmodule.exports = ClientHandshake;","map":null,"metadata":{},"sourceType":"script"}