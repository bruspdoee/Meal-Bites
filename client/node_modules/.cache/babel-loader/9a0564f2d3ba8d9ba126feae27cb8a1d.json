{"ast":null,"code":"'use strict'; // based on code from Brian White @mscdex mariasql library - https://github.com/mscdex/node-mariasql/blob/master/lib/Client.js#L272-L332\n// License: https://github.com/mscdex/node-mariasql/blob/master/LICENSE\n\nvar RE_PARAM = /(?:\\?)|(?::(\\d+|(?:[a-zA-Z][a-zA-Z0-9_]*)))/g,\n    DQUOTE = 34,\n    SQUOTE = 39,\n    BSLASH = 92;\n\nfunction parse(query) {\n  var ppos = RE_PARAM.exec(query);\n  var curpos = 0;\n  var start = 0;\n  var end;\n  var parts = [];\n  var inQuote = false;\n  var escape = false;\n  var qchr;\n  var tokens = [];\n  var qcnt = 0;\n  var lastTokenEndPos = 0;\n  var i;\n\n  if (ppos) {\n    do {\n      for (i = curpos, end = ppos.index; i < end; ++i) {\n        var chr = query.charCodeAt(i);\n        if (chr === BSLASH) escape = !escape;else {\n          if (escape) {\n            escape = false;\n            continue;\n          }\n\n          if (inQuote && chr === qchr) {\n            if (query.charCodeAt(i + 1) === qchr) {\n              // quote escaped via \"\" or ''\n              ++i;\n              continue;\n            }\n\n            inQuote = false;\n          } else if (chr === DQUOTE || chr === SQUOTE) {\n            inQuote = true;\n            qchr = chr;\n          }\n        }\n      }\n\n      if (!inQuote) {\n        parts.push(query.substring(start, end));\n        tokens.push(ppos[0].length === 1 ? qcnt++ : ppos[1]);\n        start = end + ppos[0].length;\n        lastTokenEndPos = start;\n      }\n\n      curpos = end + ppos[0].length;\n    } while (ppos = RE_PARAM.exec(query));\n\n    if (tokens.length) {\n      if (curpos < query.length) {\n        parts.push(query.substring(lastTokenEndPos));\n      }\n\n      return [parts, tokens];\n    }\n  }\n\n  return [query];\n}\n\n;\n\nvar EMPTY_LRU_FN = function EMPTY_LRU_FN(key, value) {};\n\nfunction createCompiler(config) {\n  if (!config) config = {};\n\n  if (!config.placeholder) {\n    config.placeholder = '?';\n  }\n\n  var ncache = 100;\n  var cache;\n\n  if (typeof config.cache === 'number') {\n    ncache = config.cache;\n  }\n\n  if (typeof config.cache === 'object') {\n    cache = config.cache;\n  }\n\n  if (config.cache !== false && !cache) {\n    cache = require('lru-cache')({\n      max: ncache,\n      dispose: EMPTY_LRU_FN\n    });\n  }\n\n  function toArrayParams(tree, params) {\n    var arr = [];\n\n    if (tree.length == 1) {\n      return [tree[0], []];\n    }\n\n    if (typeof params == 'undefined') throw new Error('Named query contains placeholders, but parameters object is undefined');\n    var tokens = tree[1];\n\n    for (var i = 0; i < tokens.length; ++i) {\n      arr.push(params[tokens[i]]);\n    }\n\n    return [tree[0], arr];\n  }\n\n  function noTailingSemicolon(s) {\n    if (s.slice(-1) == ':') {\n      return s.slice(0, -1);\n    }\n\n    return s;\n  }\n\n  function join(tree) {\n    if (tree.length == 1) {\n      return tree;\n    }\n\n    var unnamed = noTailingSemicolon(tree[0][0]);\n\n    for (var i = 1; i < tree[0].length; ++i) {\n      if (tree[0][i - 1].slice(-1) == ':') {\n        unnamed += config.placeholder;\n      }\n\n      unnamed += config.placeholder;\n      unnamed += noTailingSemicolon(tree[0][i]);\n    }\n\n    var last = tree[0][tree[0].length - 1];\n\n    if (tree[0].length == tree[1].length) {\n      if (last.slice(-1) == ':') {\n        unnamed += config.placeholder;\n      }\n\n      unnamed += config.placeholder;\n    }\n\n    return [unnamed, tree[1]];\n  }\n\n  function compile(query, paramsObj) {\n    var tree;\n\n    if (cache && (tree = cache.get(query))) {\n      return toArrayParams(tree, paramsObj);\n    }\n\n    tree = join(parse(query));\n\n    if (cache) {\n      cache.set(query, tree);\n    }\n\n    return toArrayParams(tree, paramsObj);\n  }\n\n  compile.parse = parse;\n  return compile;\n} // named :one :two to postgres-style numbered $1 $2 $3\n\n\nfunction toNumbered(q, params) {\n  var tree = parse(q);\n  var paramsArr = [];\n\n  if (tree.length == 1) {\n    return [tree[0], paramsArr];\n  }\n\n  var pIndexes = {};\n  var pLastIndex = 0;\n  var qs = '';\n  var varIndex;\n  var varNames = [];\n\n  for (var i = 0; i < tree[0].length; ++i) {\n    varIndex = pIndexes[tree[1][i]];\n\n    if (!varIndex) {\n      varIndex = ++pLastIndex;\n      pIndexes[tree[1][i]] = varIndex;\n    }\n\n    if (tree[1][i]) {\n      varNames[varIndex - 1] = tree[1][i];\n      qs += tree[0][i] + '$' + varIndex;\n    } else {\n      qs += tree[0][i];\n    }\n  }\n\n  return [qs, varNames.map(function (n) {\n    return params[n];\n  })];\n}\n\nmodule.exports = createCompiler;\nmodule.exports.toNumbered = toNumbered;","map":null,"metadata":{},"sourceType":"script"}