{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar Utils = require('./../utils');\n\nvar Helpers = require('./helpers');\n\nvar _ = require('lodash');\n\nvar Association = require('./base');\n\nvar Op = require('../operators');\n/**\n * One-to-many association\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.hasMany(Project)` the getter will be `user.getProjects()`.\n * If the association is aliased, use the alias instead, e.g. `User.hasMany(Project, { as: 'jobs' })` will be `user.getJobs()`.\n *\n * @see {@link Model.hasMany}\n */\n\n\nvar HasMany = /*#__PURE__*/function (_Association) {\n  _inherits(HasMany, _Association);\n\n  function HasMany(source, target, options) {\n    var _this;\n\n    _classCallCheck(this, HasMany);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(HasMany).call(this, source, target, options));\n    _this.associationType = 'HasMany';\n    _this.targetAssociation = null;\n    _this.sequelize = source.sequelize;\n    _this.isMultiAssociation = true;\n    _this.foreignKeyAttribute = {};\n\n    if (_this.options.through) {\n      throw new Error('N:M associations are not supported with hasMany. Use belongsToMany instead');\n    }\n    /*\n    * If self association, this is the target association\n    */\n\n\n    if (_this.isSelfAssociation) {\n      _this.targetAssociation = _assertThisInitialized(_assertThisInitialized(_this));\n    }\n\n    if (_this.as) {\n      _this.isAliased = true;\n\n      if (_.isPlainObject(_this.as)) {\n        _this.options.name = _this.as;\n        _this.as = _this.as.plural;\n      } else {\n        _this.options.name = {\n          plural: _this.as,\n          singular: Utils.singularize(_this.as)\n        };\n      }\n    } else {\n      _this.as = _this.target.options.name.plural;\n      _this.options.name = _this.target.options.name;\n    }\n    /*\n     * Foreign key setup\n     */\n\n\n    if (_.isObject(_this.options.foreignKey)) {\n      _this.foreignKeyAttribute = _this.options.foreignKey;\n      _this.foreignKey = _this.foreignKeyAttribute.name || _this.foreignKeyAttribute.fieldName;\n    } else if (_this.options.foreignKey) {\n      _this.foreignKey = _this.options.foreignKey;\n    }\n\n    if (!_this.foreignKey) {\n      _this.foreignKey = Utils.camelize([_this.source.options.name.singular, _this.source.primaryKeyAttribute].join('_'));\n    }\n\n    if (_this.target.rawAttributes[_this.foreignKey]) {\n      _this.identifierField = _this.target.rawAttributes[_this.foreignKey].field || _this.foreignKey;\n      _this.foreignKeyField = _this.target.rawAttributes[_this.foreignKey].field || _this.foreignKey;\n    }\n    /*\n     * Source key setup\n     */\n\n\n    _this.sourceKey = _this.options.sourceKey || _this.source.primaryKeyAttribute;\n\n    if (_this.source.rawAttributes[_this.sourceKey]) {\n      _this.sourceKeyAttribute = _this.sourceKey;\n      _this.sourceKeyField = _this.source.rawAttributes[_this.sourceKey].field || _this.sourceKey;\n    } else {\n      _this.sourceKeyAttribute = _this.source.primaryKeyAttribute;\n      _this.sourceKeyField = _this.source.primaryKeyField;\n    } // Get singular and plural names\n    // try to uppercase the first letter, unless the model forbids it\n\n\n    var plural = _.upperFirst(_this.options.name.plural);\n\n    var singular = _.upperFirst(_this.options.name.singular);\n\n    _this.associationAccessor = _this.as;\n    _this.accessors = {\n      get: \"get\".concat(plural),\n      set: \"set\".concat(plural),\n      addMultiple: \"add\".concat(plural),\n      add: \"add\".concat(singular),\n      create: \"create\".concat(singular),\n      remove: \"remove\".concat(singular),\n      removeMultiple: \"remove\".concat(plural),\n      hasSingle: \"has\".concat(singular),\n      hasAll: \"has\".concat(plural),\n      count: \"count\".concat(plural)\n    };\n    return _this;\n  } // the id is in the target table\n  // or in an extra table which connects two tables\n\n\n  _createClass(HasMany, [{\n    key: \"_injectAttributes\",\n    value: function _injectAttributes() {\n      var newAttributes = {}; // Create a new options object for use with addForeignKeyConstraints, to avoid polluting this.options in case it is later used for a n:m\n\n      var constraintOptions = _.clone(this.options);\n\n      newAttributes[this.foreignKey] = _.defaults({}, this.foreignKeyAttribute, {\n        type: this.options.keyType || this.source.rawAttributes[this.sourceKeyAttribute].type,\n        allowNull: true\n      });\n\n      if (this.options.constraints !== false) {\n        var target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n        constraintOptions.onDelete = constraintOptions.onDelete || (target.allowNull ? 'SET NULL' : 'CASCADE');\n        constraintOptions.onUpdate = constraintOptions.onUpdate || 'CASCADE';\n      }\n\n      Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, constraintOptions, this.sourceKeyField);\n      Utils.mergeDefaults(this.target.rawAttributes, newAttributes);\n      this.target.refreshAttributes();\n      this.source.refreshAttributes();\n      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n      this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n      this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n      Helpers.checkNamingCollision(this);\n      return this;\n    }\n  }, {\n    key: \"mixin\",\n    value: function mixin(obj) {\n      var methods = ['get', 'count', 'hasSingle', 'hasAll', 'set', 'add', 'addMultiple', 'remove', 'removeMultiple', 'create'];\n      var aliases = {\n        hasSingle: 'has',\n        hasAll: 'has',\n        addMultiple: 'add',\n        removeMultiple: 'remove'\n      };\n      Helpers.mixinMethods(this, obj, methods, aliases);\n    }\n    /**\n     * Get everything currently associated with this, using an optional where clause.\n     *\n     * @param {Model|Array<Model>} instances source instances\n     * @param {Object} [options] find options\n     * @param {Object} [options.where] An optional where clause to limit the associated models\n     * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n     * @param {string} [options.schema] Apply a schema on the related model\n     *\n     * @see\n     * {@link Model.findAll}  for a full explanation of options\n     *\n     * @returns {Promise<Array<Model>>}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(instances) {\n      var _this2 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var where = {};\n      var Model = this.target;\n      var instance;\n      var values;\n\n      if (!Array.isArray(instances)) {\n        instance = instances;\n        instances = undefined;\n      }\n\n      options = Object.assign({}, options);\n\n      if (this.scope) {\n        Object.assign(where, this.scope);\n      }\n\n      if (instances) {\n        values = instances.map(function (instance) {\n          return instance.get(_this2.sourceKey, {\n            raw: true\n          });\n        });\n\n        if (options.limit && instances.length > 1) {\n          options.groupedLimit = {\n            limit: options.limit,\n            on: this,\n            // association\n            values: values\n          };\n          delete options.limit;\n        } else {\n          where[this.foreignKey] = _defineProperty({}, Op.in, values);\n          delete options.groupedLimit;\n        }\n      } else {\n        where[this.foreignKey] = instance.get(this.sourceKey, {\n          raw: true\n        });\n      }\n\n      options.where = options.where ? _defineProperty({}, Op.and, [where, options.where]) : where;\n\n      if (Object.prototype.hasOwnProperty.call(options, 'scope')) {\n        if (!options.scope) {\n          Model = Model.unscoped();\n        } else {\n          Model = Model.scope(options.scope);\n        }\n      }\n\n      if (Object.prototype.hasOwnProperty.call(options, 'schema')) {\n        Model = Model.schema(options.schema, options.schemaDelimiter);\n      }\n\n      return Model.findAll(options).then(function (results) {\n        if (instance) return results;\n        var result = {};\n\n        var _iterator = _createForOfIteratorHelper(instances),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _instance = _step.value;\n            result[_instance.get(_this2.sourceKey, {\n              raw: true\n            })] = [];\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        var _iterator2 = _createForOfIteratorHelper(results),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _instance2 = _step2.value;\n\n            result[_instance2.get(_this2.foreignKey, {\n              raw: true\n            })].push(_instance2);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        return result;\n      });\n    }\n    /**\n     * Count everything currently associated with this, using an optional where clause.\n     *\n     * @param {Model}        instance the source instance\n     * @param {Object}         [options] find & count options\n     * @param {Object}         [options.where] An optional where clause to limit the associated models\n     * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n     *\n     * @returns {Promise<number>}\n     */\n\n  }, {\n    key: \"count\",\n    value: function count(instance, options) {\n      options = Utils.cloneDeep(options);\n      options.attributes = [[this.sequelize.fn('COUNT', this.sequelize.col(\"\".concat(this.target.name, \".\").concat(this.target.primaryKeyField))), 'count']];\n      options.raw = true;\n      options.plain = true;\n      return this.get(instance, options).then(function (result) {\n        return parseInt(result.count, 10);\n      });\n    }\n    /**\n     * Check if one or more rows are associated with `this`.\n     *\n     * @param {Model} sourceInstance the source instance\n     * @param {Model|Model[]|string[]|string|number[]|number} [targetInstances] Can be an array of instances or their primary keys\n     * @param {Object} [options] Options passed to getAssociations\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(sourceInstance, targetInstances, options) {\n      var _this3 = this;\n\n      var where = {};\n\n      if (!Array.isArray(targetInstances)) {\n        targetInstances = [targetInstances];\n      }\n\n      options = Object.assign({}, options, {\n        scope: false,\n        attributes: [this.target.primaryKeyAttribute],\n        raw: true\n      });\n      where[Op.or] = targetInstances.map(function (instance) {\n        if (instance instanceof _this3.target) {\n          return instance.where();\n        }\n\n        return _defineProperty({}, _this3.target.primaryKeyAttribute, instance);\n      });\n      options.where = _defineProperty({}, Op.and, [where, options.where]);\n      return this.get(sourceInstance, options).then(function (associatedObjects) {\n        return associatedObjects.length === targetInstances.length;\n      });\n    }\n    /**\n     * Set the associated models by passing an array of persisted instances or their primary keys. Everything that is not in the passed array will be un-associated\n     *\n     * @param {Model} sourceInstance source instance to associate new instances with\n     * @param {Model|Model[]|string[]|string|number[]|number} [targetInstances] An array of persisted instances or primary key of instances to associate with this. Pass `null` or `undefined` to remove all associations.\n     * @param {Object} [options] Options passed to `target.findAll` and `update`.\n     * @param {Object} [options.validate] Run validation for the join model\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(sourceInstance, targetInstances, options) {\n      var _this4 = this;\n\n      if (targetInstances === null) {\n        targetInstances = [];\n      } else {\n        targetInstances = this.toInstanceArray(targetInstances);\n      }\n\n      return this.get(sourceInstance, _.defaults({\n        scope: false,\n        raw: true\n      }, options)).then(function (oldAssociations) {\n        var promises = [];\n        var obsoleteAssociations = oldAssociations.filter(function (old) {\n          return !targetInstances.find(function (obj) {\n            return obj[_this4.target.primaryKeyAttribute] === old[_this4.target.primaryKeyAttribute];\n          });\n        });\n        var unassociatedObjects = targetInstances.filter(function (obj) {\n          return !oldAssociations.find(function (old) {\n            return obj[_this4.target.primaryKeyAttribute] === old[_this4.target.primaryKeyAttribute];\n          });\n        });\n        var updateWhere;\n        var update;\n\n        if (obsoleteAssociations.length > 0) {\n          update = {};\n          update[_this4.foreignKey] = null;\n          updateWhere = _defineProperty({}, _this4.target.primaryKeyAttribute, obsoleteAssociations.map(function (associatedObject) {\n            return associatedObject[_this4.target.primaryKeyAttribute];\n          }));\n          promises.push(_this4.target.unscoped().update(update, _.defaults({\n            where: updateWhere\n          }, options)));\n        }\n\n        if (unassociatedObjects.length > 0) {\n          updateWhere = {};\n          update = {};\n          update[_this4.foreignKey] = sourceInstance.get(_this4.sourceKey);\n          Object.assign(update, _this4.scope);\n          updateWhere[_this4.target.primaryKeyAttribute] = unassociatedObjects.map(function (unassociatedObject) {\n            return unassociatedObject[_this4.target.primaryKeyAttribute];\n          });\n          promises.push(_this4.target.unscoped().update(update, _.defaults({\n            where: updateWhere\n          }, options)));\n        }\n\n        return Utils.Promise.all(promises).return(sourceInstance);\n      });\n    }\n    /**\n     * Associate one or more target rows with `this`. This method accepts a Model / string / number to associate a single row,\n     * or a mixed array of Model / string / numbers to associate multiple rows.\n     *\n     * @param {Model} sourceInstance the source instance\n     * @param {Model|Model[]|string[]|string|number[]|number} [targetInstances] A single instance or primary key, or a mixed array of persisted instances or primary keys\n     * @param {Object} [options] Options passed to `target.update`.\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(sourceInstance, targetInstances) {\n      var _this5 = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (!targetInstances) return Utils.Promise.resolve();\n      var update = {};\n      targetInstances = this.toInstanceArray(targetInstances);\n      update[this.foreignKey] = sourceInstance.get(this.sourceKey);\n      Object.assign(update, this.scope);\n\n      var where = _defineProperty({}, this.target.primaryKeyAttribute, targetInstances.map(function (unassociatedObject) {\n        return unassociatedObject.get(_this5.target.primaryKeyAttribute);\n      }));\n\n      return this.target.unscoped().update(update, _.defaults({\n        where: where\n      }, options)).return(sourceInstance);\n    }\n    /**\n     * Un-associate one or several target rows.\n     *\n     * @param {Model} sourceInstance instance to un associate instances with\n     * @param {Model|Model[]|string|string[]|number|number[]} [targetInstances] Can be an Instance or its primary key, or a mixed array of instances and primary keys\n     * @param {Object} [options] Options passed to `target.update`\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(sourceInstance, targetInstances) {\n      var _this6 = this,\n          _where2;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var update = _defineProperty({}, this.foreignKey, null);\n\n      targetInstances = this.toInstanceArray(targetInstances);\n      var where = (_where2 = {}, _defineProperty(_where2, this.foreignKey, sourceInstance.get(this.sourceKey)), _defineProperty(_where2, this.target.primaryKeyAttribute, targetInstances.map(function (targetInstance) {\n        return targetInstance.get(_this6.target.primaryKeyAttribute);\n      })), _where2);\n      return this.target.unscoped().update(update, _.defaults({\n        where: where\n      }, options)).return(this);\n    }\n    /**\n     * Create a new instance of the associated model and associate it with this.\n     *\n     * @param {Model} sourceInstance source instance\n     * @param {Object} [values] values for target model instance\n     * @param {Object} [options] Options passed to `target.create`\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"create\",\n    value: function create(sourceInstance, values) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (Array.isArray(options)) {\n        options = {\n          fields: options\n        };\n      }\n\n      if (values === undefined) {\n        values = {};\n      }\n\n      if (this.scope) {\n        for (var _i = 0, _Object$keys = Object.keys(this.scope); _i < _Object$keys.length; _i++) {\n          var attribute = _Object$keys[_i];\n          values[attribute] = this.scope[attribute];\n          if (options.fields) options.fields.push(attribute);\n        }\n      }\n\n      values[this.foreignKey] = sourceInstance.get(this.sourceKey);\n      if (options.fields) options.fields.push(this.foreignKey);\n      return this.target.create(values, options);\n    }\n  }, {\n    key: \"verifyAssociationAlias\",\n    value: function verifyAssociationAlias(alias) {\n      if (typeof alias === 'string') {\n        return this.as === alias;\n      }\n\n      if (alias && alias.plural) {\n        return this.as === alias.plural;\n      }\n\n      return !this.isAliased;\n    }\n  }]);\n\n  return HasMany;\n}(Association);\n\nmodule.exports = HasMany;\nmodule.exports.HasMany = HasMany;\nmodule.exports.default = HasMany;","map":null,"metadata":{},"sourceType":"script"}