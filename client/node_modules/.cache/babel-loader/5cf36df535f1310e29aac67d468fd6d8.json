{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar CursorType = require('../constants/cursor');\n\nvar CommandCodes = require('../constants/commands');\n\nvar Types = require('../constants/types');\n\nvar Packet = require('../packets/packet');\n\nvar CharsetToEncoding = require('../constants/charset_encodings.js');\n\nfunction isJSON(value) {\n  return Array.isArray(value) || value.constructor === Object || typeof value.toJSON === 'function' && !Buffer.isBuffer(value);\n}\n/**\n * Converts a value to an object describing type, String/Buffer representation and length\n * @param {*} value\n */\n\n\nfunction toParameter(value, encoding, timezone) {\n  var type = Types.VAR_STRING;\n  var length;\n\n  var writer = function writer(value) {\n    // eslint-disable-next-line no-invalid-this\n    return Packet.prototype.writeLengthCodedString.call(this, value, encoding);\n  };\n\n  if (value !== null) {\n    switch (typeof value) {\n      case 'undefined':\n        throw new TypeError('Bind parameters must not contain undefined');\n\n      case 'number':\n        type = Types.DOUBLE;\n        length = 8;\n        writer = Packet.prototype.writeDouble;\n        break;\n\n      case 'boolean':\n        value = value | 0;\n        type = Types.TINY;\n        length = 1;\n        writer = Packet.prototype.writeInt8;\n        break;\n\n      case 'object':\n        if (Object.prototype.toString.call(value) === '[object Date]') {\n          type = Types.DATETIME;\n          length = 12;\n\n          writer = function writer(value) {\n            // eslint-disable-next-line no-invalid-this\n            return Packet.prototype.writeDate.call(this, value, timezone);\n          };\n        } else if (isJSON(value)) {\n          value = JSON.stringify(value);\n          type = Types.JSON;\n        } else if (Buffer.isBuffer(value)) {\n          length = Packet.lengthCodedNumberLength(value.length) + value.length;\n          writer = Packet.prototype.writeLengthCodedBuffer;\n        }\n\n        break;\n\n      default:\n        value = value.toString();\n    }\n  } else {\n    value = '';\n    type = Types.NULL;\n  }\n\n  if (!length) {\n    length = Packet.lengthCodedStringLength(value, encoding);\n  }\n\n  return {\n    value: value,\n    type: type,\n    length: length,\n    writer: writer\n  };\n}\n\nvar Execute = /*#__PURE__*/function () {\n  function Execute(id, parameters, charsetNumber, timezone) {\n    _classCallCheck(this, Execute);\n\n    this.id = id;\n    this.parameters = parameters;\n    this.encoding = CharsetToEncoding[charsetNumber];\n    this.timezone = timezone;\n  }\n\n  _createClass(Execute, [{\n    key: \"toPacket\",\n    value: function toPacket() {\n      var _this = this;\n\n      // TODO: don't try to calculate packet length in advance, allocate some big buffer in advance (header + 256 bytes?)\n      // and copy + reallocate if not enough\n      // 0 + 4 - length, seqId\n      // 4 + 1 - COM_EXECUTE\n      // 5 + 4 - stmtId\n      // 9 + 1 - flags\n      // 10 + 4 - iteration-count (always 1)\n      var length = 14;\n      var parameters;\n\n      if (this.parameters && this.parameters.length > 0) {\n        length += Math.floor((this.parameters.length + 7) / 8);\n        length += 1; // new-params-bound-flag\n\n        length += 2 * this.parameters.length; // type byte for each parameter if new-params-bound-flag is set\n\n        parameters = this.parameters.map(function (value) {\n          return toParameter(value, _this.encoding, _this.timezone);\n        });\n        length += parameters.reduce(function (accumulator, parameter) {\n          return accumulator + parameter.length;\n        }, 0);\n      }\n\n      var buffer = Buffer.allocUnsafe(length);\n      var packet = new Packet(0, buffer, 0, length);\n      packet.offset = 4;\n      packet.writeInt8(CommandCodes.STMT_EXECUTE);\n      packet.writeInt32(this.id);\n      packet.writeInt8(CursorType.NO_CURSOR); // flags\n\n      packet.writeInt32(1); // iteration-count, always 1\n\n      if (parameters) {\n        var bitmap = 0;\n        var bitValue = 1;\n        parameters.forEach(function (parameter) {\n          if (parameter.type === Types.NULL) {\n            bitmap += bitValue;\n          }\n\n          bitValue *= 2;\n\n          if (bitValue === 256) {\n            packet.writeInt8(bitmap);\n            bitmap = 0;\n            bitValue = 1;\n          }\n        });\n\n        if (bitValue !== 1) {\n          packet.writeInt8(bitmap);\n        } // TODO: explain meaning of the flag\n        // afaik, if set n*2 bytes with type of parameter are sent before parameters\n        // if not, previous execution types are used (TODO prooflink)\n\n\n        packet.writeInt8(1); // new-params-bound-flag\n        // Write parameter types\n\n        parameters.forEach(function (parameter) {\n          packet.writeInt8(parameter.type); // field type\n\n          packet.writeInt8(0); // parameter flag\n        }); // Write parameter values\n\n        parameters.forEach(function (parameter) {\n          if (parameter.type !== Types.NULL) {\n            parameter.writer.call(packet, parameter.value);\n          }\n        });\n      }\n\n      return packet;\n    }\n  }]);\n\n  return Execute;\n}();\n\nmodule.exports = Execute;","map":null,"metadata":{},"sourceType":"script"}