{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _get = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar AbstractConnectionManager = require('../abstract/connection-manager');\n\nvar Promise = require('../../promise');\n\nvar _require = require('../../utils/logger'),\n    logger = _require.logger;\n\nvar debug = logger.debugContext('connection:sqlite');\n\nvar dataTypes = require('../../data-types').sqlite;\n\nvar sequelizeErrors = require('../../errors');\n\nvar parserStore = require('../parserStore')('sqlite');\n\nvar ConnectionManager = /*#__PURE__*/function (_AbstractConnectionMa) {\n  _inherits(ConnectionManager, _AbstractConnectionMa);\n\n  function ConnectionManager(dialect, sequelize) {\n    var _this;\n\n    _classCallCheck(this, ConnectionManager);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ConnectionManager).call(this, dialect, sequelize)); // We attempt to parse file location from a connection uri\n    // but we shouldn't match sequelize default host.\n\n    if (_this.sequelize.options.host === 'localhost') {\n      delete _this.sequelize.options.host;\n    }\n\n    _this.connections = {};\n    _this.lib = _this._loadDialectModule('sqlite3').verbose();\n\n    _this.refreshTypeParser(dataTypes);\n\n    return _this;\n  }\n\n  _createClass(ConnectionManager, [{\n    key: \"_onProcessExit\",\n    value: function _onProcessExit() {\n      var _this2 = this;\n\n      var promises = Object.getOwnPropertyNames(this.connections).map(function (connection) {\n        return Promise.fromCallback(function (callback) {\n          return _this2.connections[connection].close(callback);\n        });\n      });\n      return Promise.all(promises).then(function () {\n        return _get(_getPrototypeOf(ConnectionManager.prototype), \"_onProcessExit\", _this2).call(_this2);\n      });\n    } // Expose this as a method so that the parsing may be updated when the user has added additional, custom types\n\n  }, {\n    key: \"_refreshTypeParser\",\n    value: function _refreshTypeParser(dataType) {\n      parserStore.refresh(dataType);\n    }\n  }, {\n    key: \"_clearTypeParser\",\n    value: function _clearTypeParser() {\n      parserStore.clear();\n    }\n  }, {\n    key: \"getConnection\",\n    value: function getConnection(options) {\n      var _this3 = this;\n\n      options = options || {};\n      options.uuid = options.uuid || 'default';\n      options.inMemory = (this.sequelize.options.storage || this.sequelize.options.host || ':memory:') === ':memory:' ? 1 : 0;\n      var dialectOptions = this.sequelize.options.dialectOptions;\n      options.readWriteMode = dialectOptions && dialectOptions.mode;\n\n      if (this.connections[options.inMemory || options.uuid]) {\n        return Promise.resolve(this.connections[options.inMemory || options.uuid]);\n      }\n\n      return new Promise(function (resolve, reject) {\n        _this3.connections[options.inMemory || options.uuid] = new _this3.lib.Database(_this3.sequelize.options.storage || _this3.sequelize.options.host || ':memory:', options.readWriteMode || _this3.lib.OPEN_READWRITE | _this3.lib.OPEN_CREATE, // default mode\n        function (err) {\n          if (err) return reject(new sequelizeErrors.ConnectionError(err));\n          debug(\"connection acquired \".concat(options.uuid));\n          resolve(_this3.connections[options.inMemory || options.uuid]);\n        });\n      }).tap(function (connection) {\n        if (_this3.sequelize.config.password) {\n          // Make it possible to define and use password for sqlite encryption plugin like sqlcipher\n          connection.run(\"PRAGMA KEY=\".concat(_this3.sequelize.escape(_this3.sequelize.config.password)));\n        }\n\n        if (_this3.sequelize.options.foreignKeys !== false) {\n          // Make it possible to define and use foreign key constraints unless\n          // explicitly disallowed. It's still opt-in per relation\n          connection.run('PRAGMA FOREIGN_KEYS=ON');\n        }\n      });\n    }\n  }, {\n    key: \"releaseConnection\",\n    value: function releaseConnection(connection, force) {\n      if (connection.filename === ':memory:' && force !== true) return;\n\n      if (connection.uuid) {\n        connection.close();\n        debug(\"connection released \".concat(connection.uuid));\n        delete this.connections[connection.uuid];\n      }\n    }\n  }]);\n\n  return ConnectionManager;\n}(AbstractConnectionManager);\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":null,"metadata":{},"sourceType":"script"}