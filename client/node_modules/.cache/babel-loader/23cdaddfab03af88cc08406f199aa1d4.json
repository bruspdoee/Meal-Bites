{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _defineProperty = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _objectSpread = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar Utils = require('./../utils');\n\nvar Helpers = require('./helpers');\n\nvar _ = require('lodash');\n\nvar Association = require('./base');\n\nvar Op = require('../operators');\n/**\n * One-to-many association\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.hasMany(Project)` the getter will be `user.getProjects()`.\n * If the association is aliased, use the alias instead, e.g. `User.hasMany(Project, { as: 'jobs' })` will be `user.getJobs()`.\n *\n * @see {@link Model.hasMany}\n */\n\n\nvar HasMany = /*#__PURE__*/function (_Association) {\n  _inherits(HasMany, _Association);\n\n  function HasMany(source, target, options) {\n    var _this;\n\n    _classCallCheck(this, HasMany);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(HasMany).call(this, source, target, options));\n    _this.associationType = 'HasMany';\n    _this.targetAssociation = null;\n    _this.sequelize = source.sequelize;\n    _this.isMultiAssociation = true;\n    _this.foreignKeyAttribute = {};\n\n    if (_this.options.through) {\n      throw new Error('N:M associations are not supported with hasMany. Use belongsToMany instead');\n    }\n    /*\n    * If self association, this is the target association\n    */\n\n\n    if (_this.isSelfAssociation) {\n      _this.targetAssociation = _assertThisInitialized(_assertThisInitialized(_this));\n    }\n\n    if (_this.as) {\n      _this.isAliased = true;\n\n      if (_.isPlainObject(_this.as)) {\n        _this.options.name = _this.as;\n        _this.as = _this.as.plural;\n      } else {\n        _this.options.name = {\n          plural: _this.as,\n          singular: Utils.singularize(_this.as)\n        };\n      }\n    } else {\n      _this.as = _this.target.options.name.plural;\n      _this.options.name = _this.target.options.name;\n    }\n    /*\n     * Foreign key setup\n     */\n\n\n    if (_.isObject(_this.options.foreignKey)) {\n      _this.foreignKeyAttribute = _this.options.foreignKey;\n      _this.foreignKey = _this.foreignKeyAttribute.name || _this.foreignKeyAttribute.fieldName;\n    } else if (_this.options.foreignKey) {\n      _this.foreignKey = _this.options.foreignKey;\n    }\n\n    if (!_this.foreignKey) {\n      _this.foreignKey = Utils.camelize([_this.source.options.name.singular, _this.source.primaryKeyAttribute].join('_'));\n    }\n\n    if (_this.target.rawAttributes[_this.foreignKey]) {\n      _this.identifierField = _this.target.rawAttributes[_this.foreignKey].field || _this.foreignKey;\n      _this.foreignKeyField = _this.target.rawAttributes[_this.foreignKey].field || _this.foreignKey;\n    }\n    /*\n     * Source key setup\n     */\n\n\n    _this.sourceKey = _this.options.sourceKey || _this.source.primaryKeyAttribute;\n\n    if (_this.source.rawAttributes[_this.sourceKey]) {\n      _this.sourceKeyAttribute = _this.sourceKey;\n      _this.sourceKeyField = _this.source.rawAttributes[_this.sourceKey].field || _this.sourceKey;\n    } else {\n      _this.sourceKeyAttribute = _this.source.primaryKeyAttribute;\n      _this.sourceKeyField = _this.source.primaryKeyField;\n    } // Get singular and plural names\n    // try to uppercase the first letter, unless the model forbids it\n\n\n    var plural = _.upperFirst(_this.options.name.plural);\n\n    var singular = _.upperFirst(_this.options.name.singular);\n\n    _this.associationAccessor = _this.as;\n    _this.accessors = {\n      get: \"get\".concat(plural),\n      set: \"set\".concat(plural),\n      addMultiple: \"add\".concat(plural),\n      add: \"add\".concat(singular),\n      create: \"create\".concat(singular),\n      remove: \"remove\".concat(singular),\n      removeMultiple: \"remove\".concat(plural),\n      hasSingle: \"has\".concat(singular),\n      hasAll: \"has\".concat(plural),\n      count: \"count\".concat(plural)\n    };\n    return _this;\n  } // the id is in the target table\n  // or in an extra table which connects two tables\n\n\n  _createClass(HasMany, [{\n    key: \"_injectAttributes\",\n    value: function _injectAttributes() {\n      var newAttributes = _defineProperty({}, this.foreignKey, _objectSpread({\n        type: this.options.keyType || this.source.rawAttributes[this.sourceKeyAttribute].type,\n        allowNull: true\n      }, this.foreignKeyAttribute)); // Create a new options object for use with addForeignKeyConstraints, to avoid polluting this.options in case it is later used for a n:m\n\n\n      var constraintOptions = _objectSpread({}, this.options);\n\n      if (this.options.constraints !== false) {\n        var target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n        constraintOptions.onDelete = constraintOptions.onDelete || (target.allowNull ? 'SET NULL' : 'CASCADE');\n        constraintOptions.onUpdate = constraintOptions.onUpdate || 'CASCADE';\n      }\n\n      Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, constraintOptions, this.sourceKeyField);\n      Utils.mergeDefaults(this.target.rawAttributes, newAttributes);\n      this.target.refreshAttributes();\n      this.source.refreshAttributes();\n      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n      this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n      this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n      Helpers.checkNamingCollision(this);\n      return this;\n    }\n  }, {\n    key: \"mixin\",\n    value: function mixin(obj) {\n      var methods = ['get', 'count', 'hasSingle', 'hasAll', 'set', 'add', 'addMultiple', 'remove', 'removeMultiple', 'create'];\n      var aliases = {\n        hasSingle: 'has',\n        hasAll: 'has',\n        addMultiple: 'add',\n        removeMultiple: 'remove'\n      };\n      Helpers.mixinMethods(this, obj, methods, aliases);\n    }\n    /**\n     * Get everything currently associated with this, using an optional where clause.\n     *\n     * @param {Model|Array<Model>} instances source instances\n     * @param {object} [options] find options\n     * @param {object} [options.where] An optional where clause to limit the associated models\n     * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n     * @param {string} [options.schema] Apply a schema on the related model\n     *\n     * @see\n     * {@link Model.findAll}  for a full explanation of options\n     *\n     * @returns {Promise<Array<Model>>}\n     */\n\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(instances) {\n        var _this2 = this;\n\n        var options,\n            where,\n            Model,\n            instance,\n            values,\n            results,\n            result,\n            _iterator,\n            _step,\n            _instance,\n            _iterator2,\n            _step2,\n            _instance2,\n            _args = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n                where = {};\n                Model = this.target;\n\n                if (!Array.isArray(instances)) {\n                  instance = instances;\n                  instances = undefined;\n                }\n\n                options = _objectSpread({}, options);\n\n                if (this.scope) {\n                  Object.assign(where, this.scope);\n                }\n\n                if (instances) {\n                  values = instances.map(function (_instance) {\n                    return _instance.get(_this2.sourceKey, {\n                      raw: true\n                    });\n                  });\n\n                  if (options.limit && instances.length > 1) {\n                    options.groupedLimit = {\n                      limit: options.limit,\n                      on: this,\n                      // association\n                      values: values\n                    };\n                    delete options.limit;\n                  } else {\n                    where[this.foreignKey] = _defineProperty({}, Op.in, values);\n                    delete options.groupedLimit;\n                  }\n                } else {\n                  where[this.foreignKey] = instance.get(this.sourceKey, {\n                    raw: true\n                  });\n                }\n\n                options.where = options.where ? _defineProperty({}, Op.and, [where, options.where]) : where;\n\n                if (Object.prototype.hasOwnProperty.call(options, 'scope')) {\n                  if (!options.scope) {\n                    Model = Model.unscoped();\n                  } else {\n                    Model = Model.scope(options.scope);\n                  }\n                }\n\n                if (Object.prototype.hasOwnProperty.call(options, 'schema')) {\n                  Model = Model.schema(options.schema, options.schemaDelimiter);\n                }\n\n                _context.next = 12;\n                return Model.findAll(options);\n\n              case 12:\n                results = _context.sent;\n\n                if (!instance) {\n                  _context.next = 15;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", results);\n\n              case 15:\n                result = {};\n                _iterator = _createForOfIteratorHelper(instances);\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    _instance = _step.value;\n                    result[_instance.get(this.sourceKey, {\n                      raw: true\n                    })] = [];\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                _iterator2 = _createForOfIteratorHelper(results);\n\n                try {\n                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                    _instance2 = _step2.value;\n\n                    result[_instance2.get(this.foreignKey, {\n                      raw: true\n                    })].push(_instance2);\n                  }\n                } catch (err) {\n                  _iterator2.e(err);\n                } finally {\n                  _iterator2.f();\n                }\n\n                return _context.abrupt(\"return\", result);\n\n              case 21:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function get(_x) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n    /**\n     * Count everything currently associated with this, using an optional where clause.\n     *\n     * @param {Model}        instance the source instance\n     * @param {object}         [options] find & count options\n     * @param {object}         [options.where] An optional where clause to limit the associated models\n     * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n     *\n     * @returns {Promise<number>}\n     */\n\n  }, {\n    key: \"count\",\n    value: function () {\n      var _count = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(instance, options) {\n        var result;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                options = Utils.cloneDeep(options);\n                options.attributes = [[this.sequelize.fn('COUNT', this.sequelize.col(\"\".concat(this.target.name, \".\").concat(this.target.primaryKeyField))), 'count']];\n                options.raw = true;\n                options.plain = true;\n                _context2.next = 6;\n                return this.get(instance, options);\n\n              case 6:\n                result = _context2.sent;\n                return _context2.abrupt(\"return\", parseInt(result.count, 10));\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function count(_x2, _x3) {\n        return _count.apply(this, arguments);\n      }\n\n      return count;\n    }()\n    /**\n     * Check if one or more rows are associated with `this`.\n     *\n     * @param {Model} sourceInstance the source instance\n     * @param {Model|Model[]|string[]|string|number[]|number} [targetInstances] Can be an array of instances or their primary keys\n     * @param {object} [options] Options passed to getAssociations\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"has\",\n    value: function () {\n      var _has = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(sourceInstance, targetInstances, options) {\n        var _this3 = this;\n\n        var where, associatedObjects;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                where = {};\n\n                if (!Array.isArray(targetInstances)) {\n                  targetInstances = [targetInstances];\n                }\n\n                options = _objectSpread({}, options, {\n                  scope: false,\n                  attributes: [this.target.primaryKeyAttribute],\n                  raw: true\n                });\n                where[Op.or] = targetInstances.map(function (instance) {\n                  if (instance instanceof _this3.target) {\n                    return instance.where();\n                  }\n\n                  return _defineProperty({}, _this3.target.primaryKeyAttribute, instance);\n                });\n                options.where = _defineProperty({}, Op.and, [where, options.where]);\n                _context3.next = 7;\n                return this.get(sourceInstance, options);\n\n              case 7:\n                associatedObjects = _context3.sent;\n                return _context3.abrupt(\"return\", associatedObjects.length === targetInstances.length);\n\n              case 9:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function has(_x4, _x5, _x6) {\n        return _has.apply(this, arguments);\n      }\n\n      return has;\n    }()\n    /**\n     * Set the associated models by passing an array of persisted instances or their primary keys. Everything that is not in the passed array will be un-associated\n     *\n     * @param {Model} sourceInstance source instance to associate new instances with\n     * @param {Model|Model[]|string[]|string|number[]|number} [targetInstances] An array of persisted instances or primary key of instances to associate with this. Pass `null` or `undefined` to remove all associations.\n     * @param {object} [options] Options passed to `target.findAll` and `update`.\n     * @param {object} [options.validate] Run validation for the join model\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"set\",\n    value: function () {\n      var _set = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(sourceInstance, targetInstances, options) {\n        var _this4 = this;\n\n        var oldAssociations, promises, obsoleteAssociations, unassociatedObjects, updateWhere, update;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (targetInstances === null) {\n                  targetInstances = [];\n                } else {\n                  targetInstances = this.toInstanceArray(targetInstances);\n                }\n\n                _context4.next = 3;\n                return this.get(sourceInstance, _objectSpread({}, options, {\n                  scope: false,\n                  raw: true\n                }));\n\n              case 3:\n                oldAssociations = _context4.sent;\n                promises = [];\n                obsoleteAssociations = oldAssociations.filter(function (old) {\n                  return !targetInstances.find(function (obj) {\n                    return obj[_this4.target.primaryKeyAttribute] === old[_this4.target.primaryKeyAttribute];\n                  });\n                });\n                unassociatedObjects = targetInstances.filter(function (obj) {\n                  return !oldAssociations.find(function (old) {\n                    return obj[_this4.target.primaryKeyAttribute] === old[_this4.target.primaryKeyAttribute];\n                  });\n                });\n\n                if (obsoleteAssociations.length > 0) {\n                  update = {};\n                  update[this.foreignKey] = null;\n                  updateWhere = _defineProperty({}, this.target.primaryKeyAttribute, obsoleteAssociations.map(function (associatedObject) {\n                    return associatedObject[_this4.target.primaryKeyAttribute];\n                  }));\n                  promises.push(this.target.unscoped().update(update, _objectSpread({}, options, {\n                    where: updateWhere\n                  })));\n                }\n\n                if (unassociatedObjects.length > 0) {\n                  updateWhere = {};\n                  update = {};\n                  update[this.foreignKey] = sourceInstance.get(this.sourceKey);\n                  Object.assign(update, this.scope);\n                  updateWhere[this.target.primaryKeyAttribute] = unassociatedObjects.map(function (unassociatedObject) {\n                    return unassociatedObject[_this4.target.primaryKeyAttribute];\n                  });\n                  promises.push(this.target.unscoped().update(update, _objectSpread({}, options, {\n                    where: updateWhere\n                  })));\n                }\n\n                _context4.next = 11;\n                return Promise.all(promises);\n\n              case 11:\n                return _context4.abrupt(\"return\", sourceInstance);\n\n              case 12:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function set(_x7, _x8, _x9) {\n        return _set.apply(this, arguments);\n      }\n\n      return set;\n    }()\n    /**\n     * Associate one or more target rows with `this`. This method accepts a Model / string / number to associate a single row,\n     * or a mixed array of Model / string / numbers to associate multiple rows.\n     *\n     * @param {Model} sourceInstance the source instance\n     * @param {Model|Model[]|string[]|string|number[]|number} [targetInstances] A single instance or primary key, or a mixed array of persisted instances or primary keys\n     * @param {object} [options] Options passed to `target.update`.\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"add\",\n    value: function () {\n      var _add = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(sourceInstance, targetInstances) {\n        var _this5 = this;\n\n        var options,\n            update,\n            where,\n            _args5 = arguments;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                options = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : {};\n\n                if (targetInstances) {\n                  _context5.next = 3;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", Promise.resolve());\n\n              case 3:\n                targetInstances = this.toInstanceArray(targetInstances);\n                update = _objectSpread(_defineProperty({}, this.foreignKey, sourceInstance.get(this.sourceKey)), this.scope);\n                where = _defineProperty({}, this.target.primaryKeyAttribute, targetInstances.map(function (unassociatedObject) {\n                  return unassociatedObject.get(_this5.target.primaryKeyAttribute);\n                }));\n                _context5.next = 8;\n                return this.target.unscoped().update(update, _objectSpread({}, options, {\n                  where: where\n                }));\n\n              case 8:\n                return _context5.abrupt(\"return\", sourceInstance);\n\n              case 9:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function add(_x10, _x11) {\n        return _add.apply(this, arguments);\n      }\n\n      return add;\n    }()\n    /**\n     * Un-associate one or several target rows.\n     *\n     * @param {Model} sourceInstance instance to un associate instances with\n     * @param {Model|Model[]|string|string[]|number|number[]} [targetInstances] Can be an Instance or its primary key, or a mixed array of instances and primary keys\n     * @param {object} [options] Options passed to `target.update`\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"remove\",\n    value: function () {\n      var _remove = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(sourceInstance, targetInstances) {\n        var _this6 = this,\n            _where2;\n\n        var options,\n            update,\n            where,\n            _args6 = arguments;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                options = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : {};\n                update = _defineProperty({}, this.foreignKey, null);\n                targetInstances = this.toInstanceArray(targetInstances);\n                where = (_where2 = {}, _defineProperty(_where2, this.foreignKey, sourceInstance.get(this.sourceKey)), _defineProperty(_where2, this.target.primaryKeyAttribute, targetInstances.map(function (targetInstance) {\n                  return targetInstance.get(_this6.target.primaryKeyAttribute);\n                })), _where2);\n                _context6.next = 6;\n                return this.target.unscoped().update(update, _objectSpread({}, options, {\n                  where: where\n                }));\n\n              case 6:\n                return _context6.abrupt(\"return\", this);\n\n              case 7:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function remove(_x12, _x13) {\n        return _remove.apply(this, arguments);\n      }\n\n      return remove;\n    }()\n    /**\n     * Create a new instance of the associated model and associate it with this.\n     *\n     * @param {Model} sourceInstance source instance\n     * @param {object} [values] values for target model instance\n     * @param {object} [options] Options passed to `target.create`\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"create\",\n    value: function () {\n      var _create = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(sourceInstance, values) {\n        var options,\n            _i,\n            _Object$keys,\n            attribute,\n            _args7 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                options = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : {};\n\n                if (Array.isArray(options)) {\n                  options = {\n                    fields: options\n                  };\n                }\n\n                if (values === undefined) {\n                  values = {};\n                }\n\n                if (this.scope) {\n                  for (_i = 0, _Object$keys = Object.keys(this.scope); _i < _Object$keys.length; _i++) {\n                    attribute = _Object$keys[_i];\n                    values[attribute] = this.scope[attribute];\n                    if (options.fields) options.fields.push(attribute);\n                  }\n                }\n\n                values[this.foreignKey] = sourceInstance.get(this.sourceKey);\n                if (options.fields) options.fields.push(this.foreignKey);\n                _context7.next = 8;\n                return this.target.create(values, options);\n\n              case 8:\n                return _context7.abrupt(\"return\", _context7.sent);\n\n              case 9:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function create(_x14, _x15) {\n        return _create.apply(this, arguments);\n      }\n\n      return create;\n    }()\n  }, {\n    key: \"verifyAssociationAlias\",\n    value: function verifyAssociationAlias(alias) {\n      if (typeof alias === 'string') {\n        return this.as === alias;\n      }\n\n      if (alias && alias.plural) {\n        return this.as === alias.plural;\n      }\n\n      return !this.isAliased;\n    }\n  }]);\n\n  return HasMany;\n}(Association);\n\nmodule.exports = HasMany;\nmodule.exports.HasMany = HasMany;\nmodule.exports.default = HasMany;","map":null,"metadata":{},"sourceType":"script"}