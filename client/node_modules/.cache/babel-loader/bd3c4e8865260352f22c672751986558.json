{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jervisbay/project-tres/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Packet = require('../packets/packet');\n\nvar StringParser = require('../parsers/string');\n\nvar CharsetToEncoding = require('../constants/charset_encodings.js');\n\nvar fields = ['catalog', 'schema', 'table', 'orgTable', 'name', 'orgName']; // creating JS string is relatively expensive (compared to\n// reading few bytes from buffer) because all string properties\n// except for name are unlikely to be used we postpone\n// string conversion until property access\n//\n// TODO: watch for integration benchmarks (one with real network buffer)\n// there could be bad side effect as keeping reference to a buffer makes it\n// sit in the memory longer (usually until final .query() callback)\n// Latest v8 perform much better in regard to bufferer -> string conversion,\n// at some point of time this optimisation might become unnecessary\n// see https://github.com/sidorares/node-mysql2/pull/137\n//\n\nvar ColumnDefinition = /*#__PURE__*/function () {\n  function ColumnDefinition(packet, clientEncoding) {\n    _classCallCheck(this, ColumnDefinition);\n\n    this._buf = packet.buffer;\n    this._clientEncoding = clientEncoding;\n    this._catalogLength = packet.readLengthCodedNumber();\n    this._catalogStart = packet.offset;\n    packet.offset += this._catalogLength;\n    this._schemaLength = packet.readLengthCodedNumber();\n    this._schemaStart = packet.offset;\n    packet.offset += this._schemaLength;\n    this._tableLength = packet.readLengthCodedNumber();\n    this._tableStart = packet.offset;\n    packet.offset += this._tableLength;\n    this._orgTableLength = packet.readLengthCodedNumber();\n    this._orgTableStart = packet.offset;\n    packet.offset += this._orgTableLength; // name is always used, don't make it lazy\n\n    var _nameLength = packet.readLengthCodedNumber();\n\n    var _nameStart = packet.offset;\n    packet.offset += _nameLength;\n    this._orgNameLength = packet.readLengthCodedNumber();\n    this._orgNameStart = packet.offset;\n    packet.offset += this._orgNameLength;\n    packet.skip(1); //  length of the following fields (always 0x0c)\n\n    this.characterSet = packet.readInt16();\n    this.encoding = CharsetToEncoding[this.characterSet];\n    this.name = StringParser.decode(this._buf.slice(_nameStart, _nameStart + _nameLength), this.encoding === 'binary' ? this._clientEncoding : this.encoding);\n    this.columnLength = packet.readInt32();\n    this.columnType = packet.readInt8();\n    this.flags = packet.readInt16();\n    this.decimals = packet.readInt8();\n  }\n\n  _createClass(ColumnDefinition, [{\n    key: \"inspect\",\n    value: function inspect() {\n      return {\n        catalog: this.catalog,\n        schema: this.schema,\n        name: this.name,\n        orgName: this.orgName,\n        table: this.table,\n        orgTable: this.orgTable,\n        characterSet: this.characterSet,\n        columnLength: this.columnLength,\n        columnType: this.columnType,\n        flags: this.flags,\n        decimals: this.decimals\n      };\n    }\n  }, {\n    key: \"db\",\n    // node-mysql compatibility: alias \"db\" to \"schema\"\n    get: function get() {\n      var start = this._schemaStart;\n      var end = start._shemaLength;\n      return this._buf.utf8Slice(start, end);\n    }\n  }], [{\n    key: \"toPacket\",\n    value: function toPacket(column, sequenceId) {\n      var length = 17; // = 4 padding + 1 + 12 for the rest\n\n      fields.forEach(function (field) {\n        length += Packet.lengthCodedStringLength(column[field], CharsetToEncoding[column.characterSet]);\n      });\n      var buffer = Buffer.allocUnsafe(length);\n      var packet = new Packet(sequenceId, buffer, 0, length);\n\n      function writeField(name) {\n        packet.writeLengthCodedString(column[name], CharsetToEncoding[column.characterSet]);\n      }\n\n      packet.offset = 4;\n      fields.forEach(writeField);\n      packet.writeInt8(0x0c);\n      packet.writeInt16(column.characterSet);\n      packet.writeInt32(column.columnLength);\n      packet.writeInt8(column.columnType);\n      packet.writeInt16(column.flags);\n      packet.writeInt8(column.decimals);\n      packet.writeInt16(0); // filler\n\n      return packet;\n    }\n  }]);\n\n  return ColumnDefinition;\n}();\n\nvar addString = function addString(name) {\n  Object.defineProperty(ColumnDefinition.prototype, name, {\n    get: function get() {\n      var start = this[\"_\".concat(name, \"Start\")];\n      var end = start + this[\"_\".concat(name, \"Length\")];\n      return StringParser.decode(this._buf.slice(start, end), this.encoding === 'binary' ? this._clientEncoding : this.encoding);\n    }\n  });\n};\n\naddString('catalog');\naddString('schema');\naddString('table');\naddString('orgTable');\naddString('orgName');\nmodule.exports = ColumnDefinition;","map":null,"metadata":{},"sourceType":"script"}